# camera-usb.folk --
#
#     Hardware interface with USB webcams (v4l2).

if {$::tcl_platform(os) eq "darwin"} { return }

When the image library is /imageLib/ {

set camc [C]
$camc extend $imageLib
$camc include <string.h>
$camc include <math.h>

$camc include <errno.h>
$camc include <fcntl.h>
$camc include <sys/ioctl.h>
$camc include <sys/mman.h>
$camc include <asm/types.h>
$camc include <linux/videodev2.h>
$camc include <unistd.h>

$camc include <stdint.h>
$camc include <stdlib.h>

$camc include <jpeglib.h>

$camc struct CameraBuffer {
    uint8_t* start;
    size_t length;
}
$camc struct Camera {
    int fd;
    uint32_t width;
    uint32_t height;
    size_t buffer_count;
    CameraBuffer* buffers;
    CameraBuffer head;
}

$camc code {
    void quit(const char* msg) {
        FOLK_ERROR("camera-usb: Quitting: [%s] %d: %s\n",
                   msg, errno, strerror(errno));
    }

    int xioctl(int fd, int request, void* arg) {
        for (int i = 0; i < 100; i++) {
            int r = ioctl(fd, request, arg);
            if (r != -1 || errno != EINTR) return r;
            printf("camera-usb: Retrying: [%x][%d] %s\n",
                   request, i, strerror(errno));
        }
        return -1;
    }
}

$camc proc cameraOpen {char* device int width int height} Camera* {
    printf("camera-usb: Loading '%s'\n", device);
    // O_CLOEXEC is necessary so long-running child processes (like
    // fswatch) don't keep the camera open past the death of folk
    // itself, which causes EBUSY for the next Folk process.
    int fd = open(device, O_RDWR | O_NONBLOCK | O_CLOEXEC, 0);
    if (fd == -1) quit("open");
    Camera* camera = malloc(sizeof(Camera));
    camera->fd = fd;
    camera->width = width;
    camera->height = height;
    camera->buffer_count = 0;
    camera->buffers = NULL;
    camera->head.length = 0;
    camera->head.start = NULL;
    return camera;
}
$camc proc cameraClose {Camera* camera} void {
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (xioctl(camera->fd, VIDIOC_STREAMOFF, &type) == -1) {
        quit("VIDIOC_STREAMOFF");
    }

    struct v4l2_requestbuffers req = {0};
    // A count value of zero frees all buffers, after aborting or
    // finishing any DMA in progress, an implicit VIDIOC_STREAMOFF.
    req.count = 0;
    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    req.memory = V4L2_MEMORY_MMAP;
    if (xioctl(camera->fd, VIDIOC_REQBUFS, &req) == -1) {
        quit("VIDIOC_REQBUFS");
    }
    if (close(camera->fd) != 0) {
        quit("close");
    }
    free(camera);
}

$camc proc cameraInit {Camera* camera uint32_t requested_buffer_count} void {
    struct v4l2_capability cap;
    if (xioctl(camera->fd, VIDIOC_QUERYCAP, &cap) == -1) quit("VIDIOC_QUERYCAP");
    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) quit("no capture");
    if (!(cap.capabilities & V4L2_CAP_STREAMING)) quit("no streaming");

    struct v4l2_format format = {0};
    format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    format.fmt.pix.width = camera->width;
    format.fmt.pix.height = camera->height;
    format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;
    format.fmt.pix.field = V4L2_FIELD_NONE;
    int ret;
    do {
        ret = xioctl(camera->fd, VIDIOC_S_FMT, &format);
        fprintf(stderr, "camera-usb: VIDIOC_S_FMT: ret = %d (%d) (%s)\n",
                ret, errno, strerror(errno));
        usleep(100000);
    } while (ret == -1 && errno == EBUSY);
    if (ret == -1) quit("VIDIOC_S_FMT");

    struct v4l2_requestbuffers req = {0};
    req.count = requested_buffer_count;
    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    req.memory = V4L2_MEMORY_MMAP;
    if (xioctl(camera->fd, VIDIOC_REQBUFS, &req) == -1) quit("VIDIOC_REQBUFS");
    camera->buffer_count = req.count;
    camera->buffers = calloc(req.count, sizeof (CameraBuffer));

    printf("LATENCY: Camera buffer count: %d\n", req.count);
    fflush(stdout);

    struct v4l2_streamparm streamparm = {0};
    streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (xioctl(camera->fd, VIDIOC_G_PARM, &streamparm) == -1) quit("VIDIOC_G_PARM");
    if (streamparm.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) {
        int req_rate_numerator = 1;
        int req_rate_denominator = 60;
        streamparm.parm.capture.timeperframe.numerator = req_rate_numerator;
        streamparm.parm.capture.timeperframe.denominator = req_rate_denominator;
        if (xioctl(camera->fd, VIDIOC_S_PARM, &streamparm) == -1) { quit("VIDIOC_S_PARM"); }

        if (streamparm.parm.capture.timeperframe.numerator != req_rate_numerator ||
            streamparm.parm.capture.timeperframe.denominator != req_rate_denominator) {
            fprintf(stderr,
                    "the driver changed the time per frame from "
                    "%d/%d to %d/%d\n",
                    req_rate_numerator, req_rate_denominator,
                    streamparm.parm.capture.timeperframe.numerator,
                    streamparm.parm.capture.timeperframe.denominator);
        }
    }

    size_t buf_max = 0;
    for (size_t i = 0; i < camera->buffer_count; i++) {
        struct v4l2_buffer buf;
        memset(&buf, 0, sizeof buf);
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        buf.index = i;
        if (xioctl(camera->fd, VIDIOC_QUERYBUF, &buf) == -1) {
            quit("VIDIOC_QUERYBUF");
        }
        if (buf.length > buf_max) buf_max = buf.length;
        camera->buffers[i].length = buf.length;
        camera->buffers[i].start = 
          mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED,
             camera->fd, buf.m.offset);
        if (camera->buffers[i].start == MAP_FAILED) quit("mmap");
    }
    camera->head.start = malloc(buf_max);

    printf("camera %d; bufcount %zu\n", camera->fd, camera->buffer_count);
}

$camc proc cameraStart {Camera* camera} void {
    for (size_t i = 0; i < camera->buffer_count; i++) {
        struct v4l2_buffer buf;
        memset(&buf, 0, sizeof buf);
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        buf.index = i;
        if (xioctl(camera->fd, VIDIOC_QBUF, &buf) == -1) quit("VIDIOC_QBUF");
        printf("camera_start(%zu): %s\n", i, strerror(errno));
    }

    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (xioctl(camera->fd, VIDIOC_STREAMON, &type) == -1) {
        quit("VIDIOC_STREAMON");
    }
}

$camc code {
    int camera_capture(Camera* camera) {
        struct v4l2_buffer buf;
        memset(&buf, 0, sizeof buf);
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        if (xioctl(camera->fd, VIDIOC_DQBUF, &buf) == -1) {
            fprintf(stderr, "camera_capture: VIDIOC_DQBUF failed: %d: %s\n", errno, strerror(errno));
            return 0;
        }
        memcpy(camera->head.start, camera->buffers[buf.index].start, buf.bytesused);
        camera->head.length = buf.bytesused;
        if (xioctl(camera->fd, VIDIOC_QBUF, &buf) == -1) {
            fprintf(stderr, "camera_capture: VIDIOC_QBUF failed: %d: %s\n", errno, strerror(errno));
            return 0;
        }
        return 1;
    }
}

$camc proc cameraFrame {Camera* camera} int {
    struct timeval timeout;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(camera->fd, &fds);
    int r = select(camera->fd + 1, &fds, 0, 0, &timeout);
    // printf("r: %d\n", r);
    if (r == -1) quit("select");
    if (r == 0) {
        fprintf(stderr, "selection failed of fd %d\n", camera->fd);
        return 0;
    }
    return camera_capture(camera);
}

$camc proc setExposure {Camera* camera int value} void {
    struct v4l2_control c;

    c.id = V4L2_CID_EXPOSURE_AUTO;
    c.value = V4L2_EXPOSURE_MANUAL;
    FOLK_ENSURE(xioctl(camera->fd, VIDIOC_S_CTRL, &c) == 0);

    c.id = V4L2_CID_EXPOSURE_ABSOLUTE;
    c.value = value;
    FOLK_ENSURE(xioctl(camera->fd, VIDIOC_S_CTRL, &c) == 0);
}
$camc proc setExposureAuto {Camera* camera} void {
    struct v4l2_control c;
    c.id = V4L2_CID_EXPOSURE_AUTO;
    c.value = V4L2_EXPOSURE_APERTURE_PRIORITY;
    FOLK_ENSURE(xioctl(camera->fd, VIDIOC_S_CTRL, &c) == 0);
}

$camc proc cameraDecompressRgb {Camera* camera Image dest} void {
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_mem_src(&cinfo, camera->head.start, camera->head.length);
    if (jpeg_read_header(&cinfo, TRUE) != 1) {
        fprintf(stderr, "cameraDecompressRgb: Fail\n");
        exit(1);
    }
    jpeg_start_decompress(&cinfo);

    while (cinfo.output_scanline < cinfo.output_height) {
        unsigned char *buffer_array[1];
        buffer_array[0] = dest.data + (cinfo.output_scanline) * dest.width * cinfo.output_components;
        jpeg_read_scanlines(&cinfo, buffer_array, 1);
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
}
$camc proc cameraDecompressGray {Camera* camera Image dest} void {
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_mem_src(&cinfo, camera->head.start, camera->head.length);
    if (jpeg_read_header(&cinfo, TRUE) != 1) {
        fprintf(stderr, "cameraDecompressGray: Fail\n");
        exit(1);
    }
    cinfo.out_color_space = JCS_GRAYSCALE;
    jpeg_start_decompress(&cinfo);

    while (cinfo.output_scanline < cinfo.output_height) {
        unsigned char *buffer_array[1];
        buffer_array[0] = dest.data + (cinfo.output_scanline) * dest.width * cinfo.output_components;
        jpeg_read_scanlines(&cinfo, buffer_array, 1);
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
}
$camc proc rgbToGray {Image rgb} Image {
    uint8_t* gray = calloc(rgb.width * rgb.height, sizeof (uint8_t));
    for (int y = 0; y < rgb.height; y++) {
        for (int x = 0; x < rgb.width; x++) {
            // we're spending 10-20% of camera time here on Pi ... ??

            int i = (y * rgb.width + x) * 3;
            uint32_t r = rgb.data[i];
            uint32_t g = rgb.data[i + 1];
            uint32_t b = rgb.data[i + 2];
            // from https://mina86.com/2021/rgb-to-greyscale/
            uint32_t yy = 3567664 * r + 11998547 * g + 1211005 * b;
            gray[y * rgb.width + x] = ((yy + (1 << 23)) >> 24);
        }
    }
    return (Image) {
        .width = rgb.width, .height = rgb.height,
        .components = 1,
        .bytesPerRow = rgb.width,
        .data = gray
    };
}

$camc proc newImage {Camera* camera int components int uniq} Image {
    uint8_t* data = malloc(camera->width*components*camera->height);
    return (Image) {
        .width = camera->width,
        .height = camera->height,
        .components = components,
        .bytesPerRow = camera->width*components,
        .data = data,
        .uniq = uniq
    };
}
$camc proc freeImage {Image image} void {
    free(image.data);
}

# c loadlib [expr {$::tcl_platform(os) eq "Darwin" ?
#                  "/opt/homebrew/lib/libjpeg.dylib" :
#                  [lindex [exec /usr/sbin/ldconfig -p | grep libjpeg] end]}]
$camc endcflags -ljpeg
$camc cflags -Wall -Werror
set camLib [$camc compile]

When the image library is /imageLib/ &\
     /someone/ wishes $::thisNode uses camera /camera/ with /...options/ {
    if {[string match "/sys/bus/usb/devices/*" $camera]} {
        set devicePath $camera

        fn retryDevice {} {
            set videoDevices [glob -nocomplain [file join $devicePath video4linux video*]]
            if {[llength $videoDevices] > 0} {
                set camera [file tail [lindex [lsort -dict $videoDevices] 0]]
                set camera "/dev/$camera"
            } else {
                error "camera-usb: Unable to find video device for $devicePath"
            }

            Hold! -key [list retry $devicePath] \
                Wish $::thisNode uses camera $camera with {*}$options
        }

        When camera $camera failed with error /e/ {
            puts stderr "camera-usb: Restarting after failure with $e"
            retryDevice
        }
        retryDevice

        return
    }

    if {![string match "/dev/*" $camera]} { return }

    set width [dict get $options width]
    set height [dict get $options height]
    set bufferCount [dict getdef $options bufferCount 2]

    if {[dict exists $options crop]} {
        set crop [dict get $options crop]
    }

    namespace eval Camera {
        variable camLib [uplevel {set camLib}]
        proc unknown {procName args} {
            variable camLib; ::unknown $camLib $procName {*}$args
        }
        proc new {device width height bufferCount} {
            set camera [cameraOpen $device $width $height]
            puts "camera-usb: Loaded $device -> $camera"
            cameraInit $camera $bufferCount
            cameraStart $camera
            # skip 5 frames for booting a cam
            for {set i 0} {$i < 5} {incr i} {
                cameraFrame $camera
            }
            return $camera
        }
        proc frame {camera {uniq 0}} {
            if {![cameraFrame $camera]} {
                error "Failed to capture from camera"
            }
            set image [newImage $camera 3 $uniq]
            cameraDecompressRgb $camera $image
            return $image
        }
        proc grayFrame {camera {uniq 0}} {
            if {![cameraFrame $camera]} {
                error "Failed to capture from camera"
            }
            set image [newImage $camera 1 $uniq]
            cameraDecompressGray $camera $image
            return $image
        }
        proc close {camera} {
            cameraClose $camera
        }
    }

    set width [dict get $options width]
    set height [dict get $options height]
    set bufferCount [dict getdef $options bufferCount 4]
    set camObj [Camera::new $camera $width $height $bufferCount]

    try -signal {
        if {[info exists crop]} {
            Claim camera $camera has width [dict get $crop width] height [dict get $crop height]
        } else {
            Claim camera $camera has width $width height $height
        }

        When /someone/ wishes camera $camera uses exposure time /exposureTimeUs/ us {
            if {$exposureTimeUs eq "auto"} {
                $camLib setExposureAuto $camObj
            } else {
                $camLib setExposure $camObj [expr {int($exposureTimeUs / 100)}]
            }
        }

        while true {
            tracy zoneBegin

            set ms [clock milliseconds]
            set frame [Camera::grayFrame $camObj $ms]

            if {[info exists crop]} {
                dict with crop {
                    set cropped [$imageLib subimage $frame $x $y $width $height]
                }
            } else {
                set cropped $frame
            }
            set timestamp [expr {$ms / 1000.0}]
            tracy zoneName "camera-usb: $timestamp"
            Hold! -key camera \
                Claim camera $camera has frame $cropped at timestamp $timestamp \
                -destructor [list $camLib freeImage $frame]

            tracy zoneEnd
        }
    } on error e {
        puts stderr "camera-usb: Error $e"
        Hold! -key [list camera-error $camera] \
            Claim camera $camera failed with error $e
    } on signal sig {
        puts stderr "camera-usb: Signal $sig"
    } finally {
        puts "camera-usb: Close $camObj"
        Camera::close $camObj
    }
}

}

set cc [C]
$cc include <fcntl.h>
$cc include <unistd.h>
$cc include <sys/ioctl.h>
$cc include <linux/videodev2.h>
$cc proc enumerateFormatsForCamera {char* camera} Jim_Obj* {
    int fd = open(camera, O_RDWR);
    FOLK_ENSURE(fd >= 0);

    Jim_Obj *formatsList = Jim_NewListObj(interp, NULL, 0);

    // Enumerate pixel formats
    struct v4l2_fmtdesc fmt_desc = {0};
    fmt_desc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    
    while (ioctl(fd, VIDIOC_ENUM_FMT, &fmt_desc) == 0) {
        Jim_Obj *formatDict = Jim_NewDictObj(interp, NULL, 0);
        
        char fourcc_str[5];
        fourcc_str[0] = fmt_desc.pixelformat & 0xFF;
        fourcc_str[1] = (fmt_desc.pixelformat >> 8) & 0xFF;
        fourcc_str[2] = (fmt_desc.pixelformat >> 16) & 0xFF;
        fourcc_str[3] = (fmt_desc.pixelformat >> 24) & 0xFF;
        fourcc_str[4] = '\0';
        
        Jim_Obj *fourccKey = Jim_NewStringObj(interp, "fourcc", -1);
        Jim_Obj *fourccVal = Jim_NewStringObj(interp, fourcc_str, -1);
        Jim_DictAddElement(interp, formatDict, fourccKey, fourccVal);
        
        Jim_Obj *descKey = Jim_NewStringObj(interp, "description", -1);
        Jim_Obj *descVal = Jim_NewStringObj(interp, (char*)fmt_desc.description, -1);
        Jim_DictAddElement(interp, formatDict, descKey, descVal);
        
        Jim_Obj *resolutionsList = Jim_NewListObj(interp, NULL, 0);
        
        struct v4l2_frmsizeenum frm_size = {0};
        frm_size.pixel_format = fmt_desc.pixelformat;
        
        while (ioctl(fd, VIDIOC_ENUM_FRAMESIZES, &frm_size) == 0) {
            if (frm_size.type == V4L2_FRMSIZE_TYPE_DISCRETE) {
                Jim_Obj *resDict = Jim_NewDictObj(interp, NULL, 0);
                
                Jim_Obj *widthKey = Jim_NewStringObj(interp, "width", -1);
                Jim_Obj *widthVal = Jim_NewIntObj(interp, frm_size.discrete.width);
                Jim_DictAddElement(interp, resDict, widthKey, widthVal);
                
                Jim_Obj *heightKey = Jim_NewStringObj(interp, "height", -1);
                Jim_Obj *heightVal = Jim_NewIntObj(interp, frm_size.discrete.height);
                Jim_DictAddElement(interp, resDict, heightKey, heightVal);
                
                Jim_Obj *frameratesList = Jim_NewListObj(interp, NULL, 0);
                
                struct v4l2_frmivalenum frm_interval = {0};
                frm_interval.pixel_format = fmt_desc.pixelformat;
                frm_interval.width = frm_size.discrete.width;
                frm_interval.height = frm_size.discrete.height;
                
                while (ioctl(fd, VIDIOC_ENUM_FRAMEINTERVALS, &frm_interval) == 0) {
                    if (frm_interval.type == V4L2_FRMIVAL_TYPE_DISCRETE) {
                        double fps = (double)frm_interval.discrete.denominator / 
                                    frm_interval.discrete.numerator;
                        Jim_Obj *fpsVal = Jim_NewDoubleObj(interp, fps);
                        Jim_ListAppendElement(interp, frameratesList, fpsVal);
                    } else if (frm_interval.type == V4L2_FRMIVAL_TYPE_STEPWISE) {
                        // Create range dict for stepwise framerates
                        Jim_Obj *rangeDict = Jim_NewDictObj(interp, NULL, 0);
                        
                        double min_fps = (double)frm_interval.stepwise.max.denominator / 
                                        frm_interval.stepwise.max.numerator;
                        double max_fps = (double)frm_interval.stepwise.min.denominator / 
                                        frm_interval.stepwise.min.numerator;
                        
                        Jim_Obj *minKey = Jim_NewStringObj(interp, "min", -1);
                        Jim_Obj *minVal = Jim_NewDoubleObj(interp, min_fps);
                        Jim_DictAddElement(interp, rangeDict, minKey, minVal);
                        
                        Jim_Obj *maxKey = Jim_NewStringObj(interp, "max", -1);
                        Jim_Obj *maxVal = Jim_NewDoubleObj(interp, max_fps);
                        Jim_DictAddElement(interp, rangeDict, maxKey, maxVal);
                        
                        Jim_ListAppendElement(interp, frameratesList, rangeDict);
                    }
                    frm_interval.index++;
                }
                
                Jim_Obj *frameratesKey = Jim_NewStringObj(interp, "framerates", -1);
                Jim_DictAddElement(interp, resDict, frameratesKey, frameratesList);
                
                Jim_ListAppendElement(interp, resolutionsList, resDict);
            }
            frm_size.index++;
        }
        
        Jim_Obj *resolutionsKey = Jim_NewStringObj(interp, "resolutions", -1);
        Jim_DictAddElement(interp, formatDict, resolutionsKey, resolutionsList);
        
        Jim_ListAppendElement(interp, formatsList, formatDict);
        
        fmt_desc.index++;
    }

    close(fd);
    return formatsList;
}
set formatsLib [$cc compile]

foreach camera [glob -nocomplain "/dev/v4l/by-id/*"] {
    set modes [$formatsLib enumerateFormatsForCamera $camera]
    Claim $::thisNode has camera $camera with modes $modes
}
