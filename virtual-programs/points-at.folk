When when /rect/ points /direction/ with length /l/ at /someone/ /lambda/ with environment /e/ {
  if {[string match "/*" $rect]} { return }
  Wish $rect points $direction with length $l
}

When when /rect/ points /direction/ at /someone/ /lambda/ with environment /e/ {
  if {[string match "/*" $rect]} { return }
  Wish $rect points $direction with length 1
}

When the quad library is /quadLib/ &\
     the pose library is /poseLib/ &\
     the color map is /colorMap/ &\
     display /disp/ has width /displayWidth/ height /displayHeight/ &\
     display /display/ has intrinsics /displayIntrinsics/ &\
     /someone/ wishes /rect/ points /direction/ with length /l/ &\
     /rect/ has quad /quad/ {

    set scale $l

    if {$direction eq "up"} {
        set whiskerQuad [$quadLib scale $quad width 0.01px height $scale]
        set whiskerQuad [$quadLib move $whiskerQuad up 100%]
        set color blue
    } elseif {$direction eq "left"} {
        set whiskerQuad [$quadLib scale $quad height 0.01px width $scale]
        set whiskerQuad [$quadLib move $whiskerQuad left 100%]
        set color gold
    } elseif {$direction eq "right"} {
        set whiskerQuad [$quadLib scale $quad height 0.01px width $scale]
        set whiskerQuad [$quadLib move $whiskerQuad right 100%]
        set color green
    } elseif {$direction eq "down"} {
        set whiskerQuad [$quadLib scale $quad width 0.01px height $scale]
        set whiskerQuad [$quadLib move $whiskerQuad down 100%]
        set color white
    } else {
        error "points-at: Invalid direction $direction"
    }

    # HACK: This implementation is sort of inelegant in that it
    # happens entirely in screen-space, because we need to draw right
    # to the screen right now, and we don't have a surface-to-clip for
    # that.

    # Downproject the whisker to screen-space.
    lassign [lmap v [$quadLib vertices [$quadLib change $whiskerQuad "display $disp"]] {
        $poseLib project $displayIntrinsics \
            $displayWidth $displayHeight $v
    }] a b c d

    set dispResolution [list $displayWidth $displayHeight]
    set surfaceToClip \
        [list \
             [list [expr {2.0 / $displayWidth}] 0 -1.0] \
             [list 0 [expr {2.0 / $displayHeight}] -1.0] \
             [list 0 0 1]]
    set from $c
    set to $b
    set width 4
    set color [dict get $colorMap $color]
    Wish the GPU draws pipeline "line" \
        with arguments [list $dispResolution $surfaceToClip \
                            $from $to $width $color]
    Wish the GPU draws pipeline "circle" \
        with arguments [list $dispResolution $surfaceToClip \
                            $to 10 5 $color 0]

    fn contains {vertices p} {
        lassign $vertices d c b a

        set ab [vec2 sub $b $a]
        set ap [vec2 sub $p $a]
        set bc [vec2 sub $c $b]
        set bp [vec2 sub $p $b]
        set dot_abap [vec2 dot $ab $ap]
        set dot_bcbp [vec2 dot $bc $bp]

        expr {0 <= $dot_abap && $dot_abap <= [vec2 dot $ab $ab] && \
                  0 <= $dot_bcbp && $dot_bcbp <= [vec2 dot $bc $bc]}
    }
    When /target/ has quad /r2/ {
        if {$target eq $rect} { return }

        set displayVertices [lmap v [$quadLib vertices [$quadLib change $whiskerQuad "display $disp"]] {
            $poseLib project $displayIntrinsics \
                $displayWidth $displayHeight $v
        }]

        if {[contains $displayVertices $to]} {
            Claim $rect points $direction at $target
            Claim $rect points $direction with length $l at $target
        }
    }
}
