Wish $this has filename "_keyboard.folk"

Wish $this is outlined seagreen
Wish $this has neighbors

proc getOrigin region {
  lindex $region 0 0 
}

# dict set ::editors $this [expr {[dict exists $::editors $this] ? [dict get $::editors $this] : 0}]
if {![dict exists ::editors $this]} {
  dict set ::editors $this [dict create\
  cursor [dict create x 0 y 0]\
  editing false\
  chars [list]\
  keyLogSize 0\
  ]
}

When $this has region /kRegion/ {
  set kOrigin [getOrigin $kRegion]
  # TODO: make this dynamic based on neighborAbove's name!
  set filename ""
  if {$::isLaptop} {
    # TODO: generalize, this is just for cwervobook
    set filename "/Users/andrescuervo/code/folk/virtual-programs/camera-slice.folk"
  }
  lassign $kOrigin _ kOriginY
  When $this has neighbor /n/ {
    When $n has region /r/ {
      set neighborOrigin [getOrigin $r]
      lassign $neighborOrigin _ nOriginY

      if {$nOriginY < $kOriginY && [string is integer $n]} {
        Wish $this is labelled "keyboard origin: $kOriginY\nneighbor origin: $nOriginY"
        if {!$::isLaptop} {
          if {[string is integer $n]} {
            set filename "/home/folk/folk-printed-programs/$n.folk"
          } else {
            # filter out virtual programs
            return
            set filename [string map {^ .} "/home/folk/folk/$n"]
          }
        }
        #Wish $this is labelled "has a neighbor above: $filename"
        set editing [dict get $::editors $this editing]
        puts "in editing .... $editing"

        if {!$editing} {
          dict set ::editors $this editing true
          # read lines & append into a list called chars in ::editors -> $this
          set fp [open $filename r]
          set file_data [read $fp]
          close $fp

          set data [split $file_data "\n"]
          set thisDict [dict get $::editors $this]

          foreach line $data {
            set currentChars [dict get $::editors $this chars]
            dict set ::editors $this chars [lappend currentChars $line]
          }
        } else {
          When the keyboard character log is /keyLog/ {
            set keyLogSize [dict get $::editors $this keyLogSize]
            if {[expr [llength $keyLog] > $keyLogSize]} {
              dict set $::editors $this keyLogSize [llength $keyLog]
              set k [lindex $keyLog end]
              set cursor [dict get [dict get $::editors $this] cursor]
              set currentX [dict get $cursor x]
              set currentY [dict get $cursor y]
              Wish $this is labelled "keylogisze: $keyLogSize | keyLogLength: [llength $keyLog] | \n\$k: $k"
              set displayChars [dict get $::editors $this chars]
              
              set currentLine [lindex $displayChars $currentY]
              set cursorChar "_"
              When $::nodename has step count /c/ {
                # set $cursor
                if {[expr $c % 2 == 0]} {
                  set cursorChar " "
                }
                # Wish $this is labelled $cursorChar
              }
              
              set currentChar [string index $currentLine $currentX]
              set replacedLine [string replace $currentLine $currentX $currentX "$cursorChar$currentChar"]
              set displayChars [lreplace $displayChars $currentY $currentY $replacedLine]

              Wish $this is labelled "$cursorChar | chars:\n[join $displayChars \n]"

              switch -nocase $k {
                Up {
                  set currentY [dict get $cursor y]
                  if {$currentY > 0} {
                    dict set ::editors $this cursor y [expr {$currentY - 1}]
                  }
                }
                Right {
                  set currentX [dict get $cursor x]
                  # TODO: make an accessor method for the current lines' width
                  # make sure this is bounded by that 
                  dict set ::editors $this cursor x [expr {$currentX + 1}]
                }
                Down {
                  # TODO: make an accessor method for the current line count
                  # make sure this is bounded by that 
                  set currentY [dict get $cursor y]
                  dict set ::editors $this cursor y [expr {$currentY + 1}]
                }
                Left {
                  set currentX [dict get $cursor x]
                  if {$currentX > 0} {
                    dict set ::editors $this cursor x [expr {$currentX - 1}]
                  }
                }
                default {
                  # insert $k into cursor position
                }
              } 
              if {[info exists cursor]} {
                # puts "$::editors | cursors: $cursor" 
                puts "cursors: $cursor" 
              }
            }
          }
        }
      } else {
        # check for ::editors -> editing & set editing to false
        set editing [dict get $::editors $this editing]
        puts "editing? :: $editing"
      }
    }
  }
}

return
# ---- good simple keyboard controller code
When the keyboard character log is /keyLog/ {
  set k [lindex $keyLog end]
  Wish $this is labelled $k
  switch -nocase $k {
    Up { Wish $this is outlined red}
    Down { Wish $this is outlined green }
    Left { Wish $this is outlined blue}
    Right { Wish $this is outlined goldenrod}
  } 
  Wish $this is labelled $k
  #Wish $this is outlined $ca
}