On process "display" {
    set invBilinear $::invBilinear
    set rotate $::rotate
    # TODO: Do this with a wish, instead of hard-coding the global dict.
    dict set ::pipelines "image" [Gpu::pipeline {sampler2D image vec2 imageSize
                              vec2 pos float radians float scale
                              fn rotate} {
        vec2 a = pos + rotate(-imageSize/2, -radians);
        vec2 b = pos + rotate(vec2(imageSize.x, -imageSize.y)/2, -radians);
        vec2 c = pos + rotate(imageSize/2, -radians);
        vec2 d = pos + rotate(vec2(-imageSize.x, imageSize.y)/2, -radians);
        vec2 vertices[4] = vec2[4](a, b, d, c);
        return vertices[gl_VertexIndex];
    } {fn invBilinear fn rotate} {
        vec2 a = pos + rotate(-imageSize/2, -radians);
        vec2 b = pos + rotate(vec2(imageSize.x, -imageSize.y)/2, -radians);
        vec2 c = pos + rotate(imageSize/2, -radians);
        vec2 d = pos + rotate(vec2(-imageSize.x, imageSize.y)/2, -radians);
        vec2 p = gl_FragCoord.xy;
        vec2 uv = invBilinear(p, a, b, c, d);
        if( max( abs(uv.x-0.5), abs(uv.y-0.5))<0.5 ) {
            return texture(image, uv);
        }
        return vec4(0.0, 0.0, 0.0, 0.0);
    }]

    When the GPU has loaded /nfonts/ fonts {
        puts LOADING
        namespace eval ::ImageCache {
            # Backing store: stores triples of (GPU image handle, heap slot version, refcount).
            variable cache [dict create]
            variable CACHE_MAX_SIZE [- $Gpu::ImageManager::GPU_MAX_IMAGES [uplevel {set nfonts}]]

            proc getOrInsertAndIncr {im} {
                variable cache
                variable CACHE_MAX_SIZE
                if {[dict exists $cache $im]} {
                    lassign [dict get $cache $im] gim cachedVersion refcount
                    set version [Heap::folkHeapGetVersion [string map {uint8_t void} [::image_t data_ptr $im]]]
                    if {$version == $cachedVersion} {
                        dict set cache $im [list $gim $cachedVersion [+ $refcount 1]]
                        return $gim
                    } else {
                        remove $im
                    }
                }
                if {[dict size $cache] >= $CACHE_MAX_SIZE} {
                    evict
                }
                set version [Heap::folkHeapGetVersion [string map {uint8_t void} [::image_t data_ptr $im]]]
                set gim [Gpu::ImageManager::copyImageToGpu $im]
                dict set cache $im [list $gim $version 1]
                return $gim
            }

            proc decr {im} {
                variable cache
                set version [Heap::folkHeapGetVersion [string map {uint8_t void} [::image_t data_ptr $im]]]
                lassign [dict get $cache $im] gim cachedVersion refcount
                incr refcount -1
                if {$refcount == 0} {
                    remove $im
                } else {
                    dict set cache $im [list $gim $version $refcount]
                }
            }

            proc evict {} {
                variable cache
                # Evict stale.
                dict for {im v} $cache {
                    lassign $v gim expectedVersion
                    set version [Heap::folkHeapGetVersion [string map {uint8_t void} [::image_t data_ptr $im]]]
                    if {$expectedVersion != $version} {
                        Gpu::ImageManager::freeGpuImage $gim
                        dict unset cache $im
                    }
                }
                if {[dict size $cache] >= $CACHE_MAX_SIZE} {
                    error "image: Unable to evict enough from image cache."
                }
            }

            proc remove {im} {
                variable cache
                if {[dict exists $cache $im]} {
                    lassign [dict get $cache $im] gim
                    Gpu::ImageManager::freeGpuImage $gim
                }
                dict unset cache $im
            }
        }
    }

    Wish $::thisProcess receives statements like \
        [list /someone/ wishes to draw an image with /...options/]
    When /someone/ wishes to draw an image with /...options/ {
        if {[dict exists $options center]} {
            set center [dict get $options center]
        } else {
            set center [list [dict get $options x] [dict get $options y]]
        }
        set im [dict get $options image]
        set radians [dict get $options radians]
        set scale [dict_getdef $options scale 1.0]

        set gim [ImageCache::getOrInsertAndIncr $im]
        On unmatch { ImageCache::decr $im }

        Wish the GPU draws pipeline "image" with arguments \
            [list $gim [list [image_t width $im] [image_t height $im]] \
                 $center $radians $scale]
    }
}
