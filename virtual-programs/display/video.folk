# video.folk
On process "display" {
    # Load the video utilities module
    set video_module_loaded 0
    
    # Double-buffering variables for smoother playback
    variable currentFrameImage
    variable nextFrameImage
    
    # Store any error messages for debugging
    set ::lastError ""
    
    # Hard-coded absolute path to try first
    set folk_home [file normalize [file dirname [file dirname [info script]]]]
    set lib_path [file join $folk_home "lib" "video-utils.tcl"]
    
    puts stderr "Attempting to load video module from: $lib_path"
    if {![catch {source $lib_path} err]} {
        set video_module_loaded 1
        puts stderr "Successfully loaded video module from: $lib_path"
    } else {
        set ::lastError $err
        puts stderr "Error loading from $lib_path: $err"
        
        # Try alternate paths if needed
        puts stderr "Will attempt alternate paths for video-utils.tcl"
        # Improve path search order, ensure no duplicates
        foreach path {
            "./lib/video-utils.tcl"
            "../lib/video-utils.tcl" 
            "../../lib/video-utils.tcl" 
            "/home/folk/folk/lib/video-utils.tcl"
            "/home/folk/lib/video-utils.tcl"
            "/Users/cwervo/code/folk/lib/video-utils.tcl" 
        } {
            puts stderr "Trying path: $path"
            if {![catch {source $path} err]} {
                set video_module_loaded 1
                puts stderr "Successfully loaded video module from: $path"
                break
            } else {
                append ::lastError " | $path: $err"
                puts stderr "Error loading from $path: $err"
            }
        }
    }
    
    # Verify module loaded successfully and key functions are available
    if {!$video_module_loaded} {
        puts stderr "ERROR: Could not load video-utils.tcl from any location: $::lastError"
    } else {
        # Verify required commands/namespaces exist
        if {[namespace exists ::VideoState] && 
            [llength [info commands video::getVideoFrame]] > 0 &&
            [llength [info commands video::analyzeVideo]] > 0} {
            puts stderr "Video module loaded successfully with all required functions"
        } else {
            set video_module_loaded 0
            set ::lastError "Module loaded but functions missing: [info commands video::*]"
            puts stderr "ERROR: $::lastError"
        }
    }
    
    # Register for events
    Wish $::thisProcess receives statements like [list /someone/ wishes /thing/ displays video /videoSrc/]
    Wish $::thisProcess receives statements like [list /someone/ claims /thing/ has region /r/]
    Wish $::thisProcess shares statements like [list /someone/ wishes to draw an image with center /c/ image /im/ radians /radians/]
    Wish $::thisProcess shares statements like [list /someone/ wishes /thing/ is titled /title/]
    Wish $::thisProcess receives statements like [list /someone/ claims the clock time is /t/]

    # Handle video source
    When /someone/ wishes /thing/ displays video /videoSrc/ {
        # Check if video module is loaded
        if {![info exists video_module_loaded] || !$video_module_loaded} {
            puts stderr "ERROR: Cannot play video - video module not loaded"
            # Try to create a dummy video renderer
            Claim $thing has videoSource $videoSrc
            Claim $thing has videoStartTime 0
            Claim $thing has videoError "Module not loaded"
            return
        }
        
        # Verify video file exists and is accessible
        if {![file exists $videoSrc]} {
            puts stderr "ERROR: Video file does not exist: $videoSrc"
            Claim $thing has videoError "File not found"
            return
        }
        
        if {![file readable $videoSrc]} {
            puts stderr "ERROR: Video file is not readable: $videoSrc"
            Claim $thing has videoError "File not readable"
            return
        }
        
        # Get absolute path to avoid path resolution issues
        set absPath [file normalize $videoSrc]
        puts stderr "Will play video: $absPath (original: $videoSrc)"
        
        # Register the video source
        if {[catch {
            VideoState::registerSource $thing $absPath
            Claim $thing has videoSource $absPath
            Claim $thing has videoStartTime 0
            
            # Analyze the video to extract metadata
            if {[llength [info commands video::analyzeVideo]] > 0} {
                video::analyzeVideo $absPath
            } else {
                puts stderr "ERROR: video::analyzeVideo command not available"
            }
        } err]} {
            puts stderr "ERROR setting up video: $err"
            Claim $thing has videoError $err
        }
    }

    # Register region association for video regions
    When /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has region /r/ {
        Claim $thing has video region $r
    }

# Video playback with improved reactivity using frame number claims
    When the clock time is /t/ & /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has video region /r/ {
        Wish tag $thing is stabilized
        # Check if video module is loaded
        if {![info exists video_module_loaded] || !$video_module_loaded} {
            # Handle missing module by showing an error message in the region
            set center [region centroid $r]
            set dims [region dimensions $r]
            set width [lindex $dims 0]
            set height [lindex $dims 1]
            
            # Create a message display with error info
            set msg "Video module not loaded"
            if {[info exists ::lastError]} {
                set msg "$msg: $::lastError"
            }
            
            # Show error message in the region title
            Wish $thing is titled "VIDEO ERROR: $msg"
            return
        }
        
        # Get the absolute path using registered source or resolve it
        set sourceToUse $videoSrc
        if {[catch {
            # First try to get registered source
            set registeredSource [VideoState::getSource $thing]
            if {$registeredSource ne ""} {
                set sourceToUse $registeredSource
            } else {
                # Normalize path if file exists
                if {[file exists $videoSrc]} {
                    set sourceToUse [file normalize $videoSrc]
                } else {
                    # Try some common locations as a fallback
                    set found 0
                    foreach testPath [list \
                        [file join $folk_home $videoSrc] \
                        "/home/folk/$videoSrc" \
                        "/home/folk/folk/$videoSrc" \
                        "/tmp/$videoSrc"] {
                        
                        if {[file exists $testPath]} {
                            set sourceToUse $testPath
                            set found 1
                            break
                        }
                    }
                    
                    if {!$found} {
                        VideoState::log 0 "WARNING: Video file not found: $videoSrc"
                    }
                }
            }
        } err]} {
            VideoState::log 0 "Error resolving video path: $err"
        }

        # State variables
        variable lastFrame
        variable lastFrameNum
        variable lastFrameTime
        variable frameSkipCount
        variable errorCount
        
        # Get video metadata
        set metadata [VideoState::getMetadata $videoSrc]
        set fps [dict get $metadata fps]
        set totalFrames [dict get $metadata totalFrames]
        set duration [dict get $metadata duration]
        
        # Initialize if needed
        set startTime [VideoState::getStartTime $thing]
        if {$startTime == 0} {
            VideoState::setStartTime $thing $t
            Claim $thing has videoStartTime $t
            set startTime $t
            set lastFrameTime($thing) $t
            set frameSkipCount($thing) 0
            if {![info exists errorCount($thing)]} {
                set errorCount($thing) 0
            }
        }
        
        # Get frame number with proper looping
        set frameNum [VideoState::getFrameNumber $thing $t]
        
        # Check if we're at the end of the video and should loop
        if {$frameNum >= $totalFrames * 0.95} {
            # Force loop by resetting start time - this is important to prevent stuck playback
            set startTime $t
            VideoState::setStartTime $thing $t
            Claim $thing has videoStartTime $t
            set frameNum 1
            puts stderr "LOOP ENFORCED: Reset start time and forcing frame 1"
        }
        
        # DEBUG: Log frame calculation details
        puts stderr "FRAME_DEBUG: Calculating frame $frameNum for $thing at time $t (video: [file tail $sourceToUse])"
        
        # Claim the current frame number to trigger reactive updates
        Claim $thing has video frame $frameNum
        
        # Optimize frame progression for smoother playback, especially at loop boundaries
        variable lastFrameNum
        if {[info exists lastFrameNum($thing)]} {
            set prevFrame $lastFrameNum($thing)
            set frameDiff [expr {abs($frameNum - $prevFrame)}]
            
            # Simple frame smoothing
            if {$frameDiff > 5} {
                if {$frameNum > $prevFrame} {
                    # Forward jump - smooth it out
                    set frameNum [expr {$prevFrame + 2}]
                } else {
                    # Backward jump - likely loop boundary
                    if {$prevFrame >= ($totalFrames - 5) && $frameNum <= 5} {
                        # Loop boundary - go to first frame smoothly
                        set frameNum 1
                    } else {
                        # Regular backward jump
                        set frameNum [expr {$prevFrame - 2}]
                    }
                }
            }
        }
        
        # Adaptive throttling - balance between smooth playback and CPU usage
        set processFrame 1
        
        # Always process the first 10 frames to ensure video starts quickly
        set isInitialFrames 0
        if {![info exists frameSkipCount($thing)] || ![info exists lastFrameNum($thing)]} {
            set isInitialFrames 1
        } elseif {[info exists lastFrameNum($thing)] && $lastFrameNum($thing) < 10} {
            set isInitialFrames 1
        }
        
        # Skip throttling for initial frames to ensure quick startup
        if {!$isInitialFrames && [info exists lastFrameTime($thing)]} {
            set timeSince [expr {$t - $lastFrameTime($thing)}]
            
            # Base target frame rate on video properties
            # Shorter videos get higher frame rates for smoother looping
            if {$duration < 2.0} {
                set targetInterval 0.03  ;# ~30 fps
            } elseif {$duration < 5.0} {
                set targetInterval 0.04  ;# ~25 fps
            } else {
                set targetInterval 0.05  ;# ~20 fps
            }
            
            # Skip frame if we're trying to process too quickly
            if {$timeSince < $targetInterval} {
                set processFrame 0
                
                # Count skips for safety
                if {![info exists frameSkipCount($thing)]} {
                    set frameSkipCount($thing) 0
                }
                incr frameSkipCount($thing)
                
                # Force processing if we've skipped too many frames
                # This prevents getting stuck if throttling is too aggressive
                set maxSkips [expr {min(4, max(2, int($fps / 6)))}]
                if {$frameSkipCount($thing) > $maxSkips} {
                    set processFrame 1
                    set frameSkipCount($thing) 0
                }
            } else {
                # Reset skip counter and update timing
                set lastFrameTime($thing) $t
                set frameSkipCount($thing) 0
            }
        } else {
            # Initialize timing for initial frames
            set lastFrameTime($thing) $t
            set frameSkipCount($thing) 0
        }
        
        # Skip redundant frame processing - reuse last frame but ALWAYS redraw it
        if {!$processFrame || ([info exists lastFrameNum($thing)] && $lastFrameNum($thing) == $frameNum)} {
            if {[info exists lastFrame($thing)]} {
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Force subtle region changes for redraws
                set jiggle [expr {sin($t * 10) * 0.1}]
                set jiggleCenter [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
                
                # Always clear and redraw the frame to ensure it's visible even without region changes
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $lastFrame($thing) radians $angle
                
                # Create a simple frame hash for tracking redraws of cached frames
                set frameHash [expr {[image width $lastFrame($thing)] * [image height $lastFrame($thing)] + [clock milliseconds] % 1000}]
                puts stderr "REDRAW_DEBUG: Redrawing cached frame $frameNum with hash $frameHash at center $jiggleCenter | Jiggle: $jiggle"
                Claim $thing has frameHash $frameHash
                
                # Force a small change to ensure redraw
                set now [clock milliseconds]
                Wish $thing is titled "Video: [file tail $videoSrc] ($frameNum frames, loop active, t=$now)"
                return
            }
        }
        
        # Check if the next frame we need is already prefetched
        if {[info exists nextFrameImage($thing)] && 
            [info exists lastFrameNum($thing)] && 
            $frameNum == $lastFrameNum($thing) + 1} {
            
            # We have the next frame prefetched, use it directly
            set center [region centroid $r]
            set angle [region angle $r]
            set width [region width $r]
            set height [region height $r]
            
            # Force subtle region changes for prefetched frames
            set jiggle [expr {sin($t * 10) * 0.1}]
            set jiggleCenter [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
            
            # Clear region before drawing new frame
            Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
            
            # Draw the prefetched frame
            Wish to draw an image with center $jiggleCenter image $nextFrameImage($thing) radians $angle
            
            # Log jiggle details
            puts stderr "PREFETCH_DEBUG: Using prefetched frame $frameNum at center $jiggleCenter | Jiggle: $jiggle"
            
            # Update tracking
            set lastFrameNum($thing) $frameNum
            set lastFrame($thing) $nextFrameImage($thing)
            VideoState::log 2 "Using prefetched frame for $frameNum"
            
            # Simple next frame prefetch
            set nextFrameNum [expr {$frameNum + 1}]
            if {$nextFrameNum > $totalFrames * 0.9} {
                set nextFrameNum 1
                VideoState::log 0 "Prefetching at loop boundary: resetting to first frame"
            }
            
            catch {
                set nextFrameImage($thing) [video::getVideoFrame $sourceToUse $nextFrameNum]
            }
            
            # Update title with dynamic content to ensure frame updates are processed
            set elapsed [expr {$t - $startTime}]
            set loopCount [expr {int($elapsed / $duration)}]
            set playTime [format "%.1f" [expr {fmod($elapsed, $duration)}]]
            
            # Use current time in title to ensure constant updates
            set now [clock milliseconds]
            Wish $thing is titled "Video: [file tail $videoSrc] ($frameNum/$totalFrames, ${playTime}s, loop #$loopCount, t=$now)"
            
            return
        }
        
        # Update tracking
        set lastFrameNum($thing) $frameNum
        
        # Get and display frame
        if {[catch {
            # Verify video function is available
            if {[llength [info commands video::getVideoFrame]] == 0} {
                error "video::getVideoFrame command not available"
            }
            
            # Get the frame
            set frame [video::getVideoFrame $sourceToUse $frameNum]
            
            # Handle debug frames (indicates problems)
            variable debugFrameCount
            if {![info exists debugFrameCount($thing)]} {
                set debugFrameCount($thing) 0
            }
            
            # Check for debug frame (magenta placeholder)
            if {[expr {[image width $frame] == 256 && [image height $frame] == 144}]} {
                incr debugFrameCount($thing)
                
                # After multiple debug frames, try recovery steps
                if {$debugFrameCount($thing) > 3} {
                    # Try to reset decoder if problems persist
                    if {$debugFrameCount($thing) > 8} {
                        VideoState::log 0 "Resetting video decoder after debug frames"
                        VideoState::setStartTime $thing 0
                        video::freeCache $::interp
                        set debugFrameCount($thing) 0
                    }
                }
            } else {
                # Got good frame - reset debug counter
                set debugFrameCount($thing) 0
                
                # Store in our local cache
                set lastFrame($thing) $frame
                
                # Create a simple frame hash for tracking - uses image dimensions and first few pixels as a fingerprint
                set frameHash [expr {[image width $frame] * [image height $frame] + [clock milliseconds] % 1000}]
                puts stderr "FRAME_HASH: Frame $frameNum has hash $frameHash (w:[image width $frame] h:[image height $frame])"
                Claim $thing has frameHash $frameHash
                
                # Get region properties
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Track region movement for debugging
                variable lastRegionCenter
                set centerDiff {0 0}
                set diffMagnitude 0
                if {[info exists lastRegionCenter($thing)]} {
                    set prevCenter $lastRegionCenter($thing)
                    set diffX [expr {[lindex $center 0] - [lindex $prevCenter 0]}]
                    set diffY [expr {[lindex $center 1] - [lindex $prevCenter 1]}]
                    set centerDiff [list $diffX $diffY]
                    set diffMagnitude [expr {sqrt(pow($diffX, 2) + pow($diffY, 2))}]
                }
                set lastRegionCenter($thing) $center
                
                # Force subtle region changes to ensure redraw
                set jiggle [expr {sin($t * 10) * 0.1}]
                set jiggleCenter [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
                
                # Clear region before drawing new frame
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $frame radians $angle
                
                # DEBUG: Log draw request with region movement details
                puts stderr "DRAW_DEBUG: Drawing frame $frameNum with hash $frameHash at center $jiggleCenter | Movement: $centerDiff (mag: [format "%.2f" $diffMagnitude]) | Jiggle: $jiggle"
                
                # Basic frame buffer
                set currentFrameImage($thing) $frame
                
                # Simple prefetching logic
                set nextFrameNum [expr {$frameNum + 1}]
                if {$nextFrameNum > $totalFrames * 0.9} {
                    set nextFrameNum 1
                    VideoState::log 0 "Prefetching loop boundary: resetting to first frame"
                }
                
                # Only prefetch if not in initial frames startup
                if {!$isInitialFrames} {
                    catch {
                        set nextFrameImage($thing) [video::getVideoFrame $sourceToUse $nextFrameNum]
                    }
                }
                
                # Update title with playback info and current time to ensure constant updates
                set elapsed [expr {$t - $startTime}]
                set loopCount [expr {int($elapsed / $duration)}]
                set playTime [format "%.1f" [expr {fmod($elapsed, $duration)}]]
                set now [clock milliseconds]
                Wish $thing is titled "Video: [file tail $videoSrc] ($frameNum/$totalFrames, ${playTime}s, loop #$loopCount, t=$now)"
            }
        } err]} {
            # Error handling
            VideoState::log 0 "Error: $err"
            
            # Use cached frame as fallback if available
            if {[info exists lastFrame($thing)]} {
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Force movement in error recovery path
                set jiggle [expr {sin([clock milliseconds] * 0.01) * 0.1}]
                set jiggleCenter [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
                
                # Clear and draw with cached frame - always redraw to ensure visibility
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $lastFrame($thing) radians $angle
                
                # Log error recovery with jiggle
                puts stderr "ERROR_RECOVERY: Drawing error recovery frame at center $jiggleCenter | Jiggle: $jiggle"
                
                # Force update by changing title
                set now [clock milliseconds]
                Wish $thing is titled "Video: Error recovery ($now)"
            }
            
            # Track errors and reset decoder if they persist
            if {![info exists errorCount($thing)]} {
                set errorCount($thing) 0
            }
            incr errorCount($thing)
            
            if {$errorCount($thing) > 5} {
                VideoState::log 0 "Resetting video after repeated errors"
                VideoState::setStartTime $thing 0
                video::freeCache $::interp
                set errorCount($thing) 0
            }
        }
    }
}

# Add a purely reactive render path that responds to frame changes
When /thing/ has video frame /frameNum/ & /thing/ has video region /r/ & /thing/ has videoSource /videoSrc/ {
    # Get the frame from the cache or decode it
    variable lastFrame
    
    # DEBUG: Log reactive rule trigger
    puts stderr "REACTIVE_DEBUG: Reactive render triggered for $thing, frame $frameNum"
    
    if {![info exists video_module_loaded] || !$video_module_loaded} {
        puts stderr "REACTIVE_DEBUG: Video module not loaded, skipping reactive render"
        return
    }
    
    # Get the frame (use cached version if we have it)
    if {[info exists lastFrame($thing)] && $lastFrame($thing) != ""} {
        set frame $lastFrame($thing)
        
        # Update display
        set center [region centroid $r]
        set angle [region angle $r]
        
        # Track region movement for reactive rendering
        variable lastReactiveCenter
        set centerDiff {0 0}
        set diffMagnitude 0
        if {[info exists lastReactiveCenter($thing)]} {
            set prevCenter $lastReactiveCenter($thing)
            set diffX [expr {[lindex $center 0] - [lindex $prevCenter 0]}]
            set diffY [expr {[lindex $center 1] - [lindex $prevCenter 1]}]
            set centerDiff [list $diffX $diffY]
            set diffMagnitude [expr {sqrt(pow($diffX, 2) + pow($diffY, 2))}]
        }
        set lastReactiveCenter($thing) $center
        
        # Calculate a unique hash for this frame
        set frameHash [expr {[image width $frame] * [image height $frame] + [clock milliseconds] % 1000}]
        puts stderr "REACTIVE_HASH: Reactive rendering frame $frameNum with hash $frameHash at center $center | Movement: $centerDiff (mag: [format "%.2f" $diffMagnitude])"
        
        # Force subtle position changes to ensure redraw in reactive path
        set jiggle [expr {sin([clock milliseconds] * 0.01) * 0.1}]
        set jiggleCenter [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
        
        # Always redraw the frame
        Wish to draw a fill with center $jiggleCenter width [region width $r] height [region height $r] color {0 0 0 0}
        Wish to draw an image with center $jiggleCenter image $frame radians $angle
        
        # Log jiggle details
        puts stderr "REACTIVE_RENDER: Drawing reactive frame $frameNum at center $jiggleCenter | Jiggle: $jiggle"
        
        # Update title with dynamic content - include hash to ensure it's always different
        set now [clock milliseconds]
        Wish $thing is titled "Video: [file tail $videoSrc] (Frame: $frameNum, hash: $frameHash, t=$now)"
        
        # Update the frame hash claim to ensure reactivity
        Claim $thing has frameHash $frameHash
    } else {
        puts stderr "REACTIVE_DEBUG: No cached frame found for $thing"
    }
}

# Usage example:
# Wish $this displays video "/path/to/video.mp4"