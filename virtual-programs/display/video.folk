# video.folk - Optimized video display component for Folk
On process "display" {
    # Configuration options
    set video_debug 0         ;# Set to 1 for basic debugging, 2+ for verbose
    set enable_jiggle 1       ;# Enable subtle position changes to force redraw
    set jiggle_amplitude 0.1  ;# How much to jiggle (in pixels)
    
    # Load the video utilities module
    set video_module_loaded 0
    variable currentFrameImage
    variable nextFrameImage
    set ::lastError ""
    
    # Load video-utils.tcl from standard location first
    set folk_home [file normalize [file dirname [file dirname [info script]]]]
    set lib_path [file join $folk_home "lib" "video-utils.tcl"]
    
    if {![catch {source $lib_path} err]} {
        set video_module_loaded 1
        if {$video_debug} {
            puts stderr "Video module loaded from: $lib_path"
            # Set debug level in video utilities
            if {[info commands VideoState::setDebugLevel] != ""} {
                VideoState::setDebugLevel $video_debug
            }
        }
    } else {
        set ::lastError $err
        puts stderr "Error loading from $lib_path: $err"
        
        # Try alternate paths if needed
        foreach path {
            "./lib/video-utils.tcl"
            "../lib/video-utils.tcl" 
            "../../lib/video-utils.tcl" 
            "/home/folk/folk/lib/video-utils.tcl"
            "/home/folk/lib/video-utils.tcl"
            "/Users/cwervo/code/folk/lib/video-utils.tcl" 
        } {
            if {![catch {source $path} err]} {
                set video_module_loaded 1
                if {$video_debug} { puts stderr "Video module loaded from: $path" }
                break
            }
        }
    }
    
    # Verify module loaded successfully
    if {!$video_module_loaded} {
        puts stderr "ERROR: Could not load video-utils.tcl"
    } elseif {![namespace exists ::VideoState] || 
              [llength [info commands video::getVideoFrame]] == 0 ||
              [llength [info commands video::analyzeVideo]] == 0} {
        set video_module_loaded 0
        puts stderr "ERROR: Video module loaded but functions missing"
    }
    
    # Debug helper for video events
    proc debug {level message} {
        # Access the debug variable at the process level
        variable video_debug
        if {![info exists video_debug]} {
            set video_debug 0
        }
        
        if {$level <= $video_debug} {
            puts stderr "VIDEO($level): $message"
        }
    }

    # Create jiggled center coordinates to force redraw
    proc jiggleCenter {center time} {
        # Access variables at the process level
        variable enable_jiggle
        variable jiggle_amplitude
        
        # Use default values if not set
        if {![info exists enable_jiggle]} {
            set enable_jiggle 1
        }
        if {![info exists jiggle_amplitude]} {
            set jiggle_amplitude 0.1
        }
        
        # Return original center if jiggle disabled
        if {!$enable_jiggle} {
            return $center
        }
        
        # Calculate subtle jiggle based on time
        set jiggle [expr {sin($time * 10) * $jiggle_amplitude}]
        return [list [expr {[lindex $center 0] + $jiggle}] [lindex $center 1]]
    }
    
    # Register for events
    Wish $::thisProcess receives statements like [list /someone/ wishes /thing/ displays video /videoSrc/]
    Wish $::thisProcess receives statements like [list /someone/ claims /thing/ has region /r/]
    Wish $::thisProcess shares statements like [list /someone/ wishes to draw an image with center /c/ image /im/ radians /radians/]
    Wish $::thisProcess shares statements like [list /someone/ wishes /thing/ is titled /title/]
    Wish $::thisProcess receives statements like [list /someone/ claims the clock time is /t/]

    # Handle video source
    When /someone/ wishes /thing/ displays video /videoSrc/ {
        # Check if video module is loaded
        if {![info exists video_module_loaded] || !$video_module_loaded} {
            puts stderr "ERROR: Cannot play video - video module not loaded"
            Claim $thing has videoSource $videoSrc
            Claim $thing has videoStartTime 0
            Claim $thing has videoError "Module not loaded"
            return
        }
        
        # Verify video file exists and is accessible
        if {![file exists $videoSrc]} {
            puts stderr "ERROR: Video file does not exist: $videoSrc"
            Claim $thing has videoError "File not found"
            return
        }
        
        if {![file readable $videoSrc]} {
            puts stderr "ERROR: Video file is not readable: $videoSrc"
            Claim $thing has videoError "File not readable"
            return
        }
        
        # Get absolute path to avoid path resolution issues
        set absPath [file normalize $videoSrc]
        debug 1 "Playing video: $absPath"
        
        # Register the video source
        if {[catch {
            VideoState::registerSource $thing $absPath
            Claim $thing has videoSource $absPath
            Claim $thing has videoStartTime 0
            
            # Analyze the video to extract metadata
            if {[llength [info commands video::analyzeVideo]] > 0} {
                video::analyzeVideo $absPath
            }
        } err]} {
            puts stderr "ERROR setting up video: $err"
            Claim $thing has videoError $err
        }
    }

    # Register region association for video regions
    When /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has region /r/ {
        Claim $thing has video region $r
    }

    # Main video playback processor - runs on clock time
    When the clock time is /t/ & /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has video region /r/ {
        Wish tag $thing is stabilized
        
        # Check if video module is loaded
        if {![info exists video_module_loaded] || !$video_module_loaded} {
            Wish $thing is titled "VIDEO ERROR: Module not loaded"
            return
        }
        
        # Get the absolute path using registered source or resolve it
        set sourceToUse $videoSrc
        if {[catch {
            set registeredSource [VideoState::getSource $thing]
            if {$registeredSource ne ""} {
                set sourceToUse $registeredSource
            } elseif {[file exists $videoSrc]} {
                set sourceToUse [file normalize $videoSrc]
            } else {
                # Try some common locations as fallback
                foreach testPath [list \
                    [file join $folk_home $videoSrc] \
                    "/home/folk/$videoSrc" \
                    "/home/folk/folk/$videoSrc" \
                    "/tmp/$videoSrc"] {
                    if {[file exists $testPath]} {
                        set sourceToUse $testPath
                        break
                    }
                }
            }
        } err]} {
            VideoState::log 0 "Error resolving video path: $err"
        }

        # State tracking variables
        variable lastFrame
        variable lastFrameNum
        variable lastFrameTime
        variable frameSkipCount
        variable errorCount
        variable lastRegionCenter
        
        # Get video metadata
        set metadata [VideoState::getMetadata $videoSrc]
        set fps [dict get $metadata fps]
        set totalFrames [dict get $metadata totalFrames]
        set duration [dict get $metadata duration]
        
        # Initialize if needed
        set startTime [VideoState::getStartTime $thing]
        if {$startTime == 0} {
            VideoState::setStartTime $thing $t
            Claim $thing has videoStartTime $t
            set startTime $t
            set lastFrameTime($thing) $t
            set frameSkipCount($thing) 0
            if {![info exists errorCount($thing)]} {
                set errorCount($thing) 0
            }
        }
        
        # Get frame number with proper looping
        set frameNum [VideoState::getFrameNumber $thing $t]
        
        # Reset at end of video to ensure proper looping
        if {$frameNum >= $totalFrames * 0.95} {
            set startTime $t
            VideoState::setStartTime $thing $t
            Claim $thing has videoStartTime $t
            set frameNum 1
            debug 1 "Loop reset: forcing frame 1"
        }
        
        # Claim current frame to trigger reactive updates
        Claim $thing has video frame $frameNum
        
        # Smooth out frame jumps
        if {[info exists lastFrameNum($thing)]} {
            set prevFrame $lastFrameNum($thing)
            set frameDiff [expr {abs($frameNum - $prevFrame)}]
            
            if {$frameDiff > 5} {
                if {$frameNum > $prevFrame} {
                    # Forward jump - smooth it out
                    set frameNum [expr {$prevFrame + 2}]
                } elseif {$prevFrame >= ($totalFrames - 5) && $frameNum <= 5} {
                    # Loop boundary - go to first frame smoothly
                    set frameNum 1
                } else {
                    # Regular backward jump
                    set frameNum [expr {$prevFrame - 2}]
                }
            }
        }
        
        # Adaptive throttling for consistent frame rate
        set processFrame 1
        set isInitialFrames 0
        
        # Always process first 10 frames to ensure quick startup
        if {![info exists frameSkipCount($thing)] || 
            ![info exists lastFrameNum($thing)] || 
            [info exists lastFrameNum($thing)] && $lastFrameNum($thing) < 10} {
            set isInitialFrames 1
        }
        
        # Skip throttling for initial frames
        if {!$isInitialFrames && [info exists lastFrameTime($thing)]} {
            set timeSince [expr {$t - $lastFrameTime($thing)}]
            
            # Set target frame rate based on video duration
            if {$duration < 2.0} {
                set targetInterval 0.03  ;# ~30 fps
            } elseif {$duration < 5.0} {
                set targetInterval 0.04  ;# ~25 fps
            } else {
                set targetInterval 0.05  ;# ~20 fps
            }
            
            # Skip frame if we're processing too quickly
            if {$timeSince < $targetInterval} {
                set processFrame 0
                
                # Count skips for safety
                if {![info exists frameSkipCount($thing)]} {
                    set frameSkipCount($thing) 0
                }
                incr frameSkipCount($thing)
                
                # Force processing if we've skipped too many
                set maxSkips [expr {min(4, max(2, int($fps / 6)))}]
                if {$frameSkipCount($thing) > $maxSkips} {
                    set processFrame 1
                    set frameSkipCount($thing) 0
                }
            } else {
                # Reset skip counter and update timing
                set lastFrameTime($thing) $t
                set frameSkipCount($thing) 0
            }
        } else {
            # Initialize timing for initial frames
            set lastFrameTime($thing) $t
            set frameSkipCount($thing) 0
        }
        
        # Skip redundant frame processing - reuse last frame but always redraw it
        if {!$processFrame || ([info exists lastFrameNum($thing)] && $lastFrameNum($thing) == $frameNum)} {
            if {[info exists lastFrame($thing)]} {
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Get jiggled center for forced redraw
                set jiggleCenter [jiggleCenter $center $t]
                
                # Always clear and redraw to ensure visibility
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $lastFrame($thing) radians $angle
                
                # Dynamic timestamp in title to force UI updates
                set now [clock milliseconds]
                Wish $thing is titled "Video: [file tail $videoSrc] (frame $frameNum, t=$now)"
                return
            }
        }
        
        # Check if the next frame is already prefetched
        if {[info exists nextFrameImage($thing)] && 
            [info exists lastFrameNum($thing)] && 
            $frameNum == $lastFrameNum($thing) + 1} {
            
            # Use the prefetched frame directly
            set center [region centroid $r]
            set angle [region angle $r]
            set width [region width $r]
            set height [region height $r]
            
            # Get jiggled center for forced redraw
            set jiggleCenter [jiggleCenter $center $t]
            
            # Clear and draw new frame
            Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
            Wish to draw an image with center $jiggleCenter image $nextFrameImage($thing) radians $angle
            
            # Update tracking
            set lastFrameNum($thing) $frameNum
            set lastFrame($thing) $nextFrameImage($thing)
            debug 2 "Using prefetched frame $frameNum"
            
            # Prefetch next frame
            set nextFrameNum [expr {$frameNum + 1}]
            if {$nextFrameNum > $totalFrames * 0.9} {
                set nextFrameNum 1
                debug 1 "Prefetching at loop boundary: frame 1"
            }
            
            catch {
                set nextFrameImage($thing) [video::getVideoFrame $sourceToUse $nextFrameNum]
            }
            
            # Update playback info in title
            set elapsed [expr {$t - $startTime}]
            set loopCount [expr {int($elapsed / $duration)}]
            set playTime [format "%.1f" [expr {fmod($elapsed, $duration)}]]
            set now [clock milliseconds]
            Wish $thing is titled "Video: [file tail $videoSrc] ($frameNum/$totalFrames, ${playTime}s, loop #$loopCount)"
            
            return
        }
        
        # Update tracking for main render path
        set lastFrameNum($thing) $frameNum
        
        # Get and display frame
        if {[catch {
            # Get the frame
            set frame [video::getVideoFrame $sourceToUse $frameNum]
            
            # Handle debug frames (magenta placeholders)
            variable debugFrameCount
            if {![info exists debugFrameCount($thing)]} {
                set debugFrameCount($thing) 0
            }
            
            # Check for debug frame
            if {[expr {[image width $frame] == 256 && [image height $frame] == 144}]} {
                incr debugFrameCount($thing)
                
                # Reset decoder if problems persist
                if {$debugFrameCount($thing) > 8} {
                    VideoState::log 0 "Resetting video decoder after debug frames"
                    VideoState::setStartTime $thing 0
                    video::freeCache $::interp
                    set debugFrameCount($thing) 0
                }
            } else {
                # Got good frame - reset debug counter
                set debugFrameCount($thing) 0
                
                # Store in our local cache
                set lastFrame($thing) $frame
                
                # Calculate frame hash for tracking
                set frameHash [expr {[image width $frame] * [image height $frame] + [clock milliseconds] % 1000}]
                Claim $thing has frameHash $frameHash
                
                # Get region properties
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Track region movement
                set centerDiff {0 0}
                if {[info exists lastRegionCenter($thing)]} {
                    set prevCenter $lastRegionCenter($thing)
                    set diffX [expr {[lindex $center 0] - [lindex $prevCenter 0]}]
                    set diffY [expr {[lindex $center 1] - [lindex $prevCenter 1]}]
                    set centerDiff [list $diffX $diffY]
                }
                set lastRegionCenter($thing) $center
                
                # Get jiggled center for forced redraw
                set jiggleCenter [jiggleCenter $center $t]
                
                # Clear and draw new frame
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $frame radians $angle
                
                # Store frame for caching
                set currentFrameImage($thing) $frame
                
                # Prefetch next frame if not in startup
                set nextFrameNum [expr {$frameNum + 1}]
                if {$nextFrameNum > $totalFrames * 0.9} {
                    set nextFrameNum 1
                }
                
                if {!$isInitialFrames} {
                    catch {
                        set nextFrameImage($thing) [video::getVideoFrame $sourceToUse $nextFrameNum]
                    }
                }
                
                # Update title with playback info
                set elapsed [expr {$t - $startTime}]
                set loopCount [expr {int($elapsed / $duration)}]
                set playTime [format "%.1f" [expr {fmod($elapsed, $duration)}]]
                set now [clock milliseconds]
                Wish $thing is titled "Video: [file tail $videoSrc] ($frameNum/$totalFrames, ${playTime}s, loop #$loopCount)"
            }
        } err]} {
            # Error handling
            VideoState::log 0 "Error: $err"
            
            # Use cached frame as fallback
            if {[info exists lastFrame($thing)]} {
                set center [region centroid $r]
                set angle [region angle $r]
                set width [region width $r]
                set height [region height $r]
                
                # Get jiggled center for forced redraw
                set jiggleCenter [jiggleCenter $center $t]
                
                # Clear and draw with cached frame
                Wish to draw a fill with center $jiggleCenter width $width height $height color {0 0 0 0}
                Wish to draw an image with center $jiggleCenter image $lastFrame($thing) radians $angle
                
                # Force update in title
                set now [clock milliseconds]
                Wish $thing is titled "Video: Error recovery ($now)"
            }
            
            # Track errors and reset decoder if they persist
            if {![info exists errorCount($thing)]} {
                set errorCount($thing) 0
            }
            incr errorCount($thing)
            
            if {$errorCount($thing) > 5} {
                VideoState::log 0 "Resetting video after repeated errors"
                VideoState::setStartTime $thing 0
                video::freeCache $::interp
                set errorCount($thing) 0
            }
        }
    }
    
    # Reactive render path - activates when frame number changes
    When /thing/ has video frame /frameNum/ & /thing/ has video region /r/ & /thing/ has videoSource /videoSrc/ {
        # Only run if video module is loaded
        if {![info exists video_module_loaded] || !$video_module_loaded} {
            return
        }
        
        # Display the frame if we have it cached
        variable lastFrame
        if {[info exists lastFrame($thing)] && $lastFrame($thing) != ""} {
            set frame $lastFrame($thing)
            set center [region centroid $r]
            set angle [region angle $r]
            
            # Get current time for jiggle calculation
            set t [clock seconds].[format "%03d" [expr {[clock milliseconds] % 1000}]]
            set jiggleCenter [jiggleCenter $center $t]
            
            # Draw the frame
            Wish to draw a fill with center $jiggleCenter width [region width $r] height [region height $r] color {0 0 0 0}
            Wish to draw an image with center $jiggleCenter image $frame radians $angle
            
            # Calculate unique hash for frame tracking
            set frameHash [expr {[image width $frame] * [image height $frame] + [clock milliseconds] % 1000}]
            Claim $thing has frameHash $frameHash
            
            # Update title with dynamic content
            set now [clock milliseconds]
            Wish $thing is titled "Video: [file tail $videoSrc] (Frame: $frameNum, t=$now)"
        }
    }
}

# Usage example:
# Wish $this displays video "/path/to/video.mp4"