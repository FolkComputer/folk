On process "display" {
    namespace eval video {
        set cc [c create]
        ::defineImageType $cc
        # $cc cflags -lavcodec -lavformat -Wno-deprecated
        # Ignoring deprecated declarations because of version differences across systems
        # in libavcodec and libavformat as of June 20, 2024.
        $cc cflags -lavcodec -lavformat -Wno-deprecated-declarations
        c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/libavutil.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep libavutil] end]}]
        c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/libavcodec.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep libavcodec] end]}]
        c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/libavformat.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep libavformat] end]}]
        c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/swscale.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep swscale] end]}]
        $cc include <libavutil/imgutils.h>
        $cc include <libavcodec/avcodec.h>
        $cc include <libavformat/avformat.h>
        $cc include <libswscale/swscale.h>

        $cc import ::Heap::cc folkHeapAlloc as folkHeapAlloc
        $cc import ::Heap::cc folkHeapFree as folkHeapFree

        $cc proc init {} void {}

        $cc proc generateImageFromFrame {AVFrame* pRGBFrame int width int height} image_t {
            image_t ret;
            ret.width = width;
            ret.height = height;
            ret.components = 4;
            ret.bytesPerRow = ret.width * ret.components;
            ret.data = folkHeapAlloc(ret.bytesPerRow * ret.height);

            for (uint32_t y = 0; y < ret.height; ++y) {
                for (uint32_t x = 0; x < ret.width; ++x) {
                    int offset = y * ret.bytesPerRow + x * ret.components;
                    int src_offset = y * pRGBFrame->linesize[0] + x * 3;
                    ret.data[offset] = pRGBFrame->data[0][src_offset];       // R
                    ret.data[offset + 1] = pRGBFrame->data[0][src_offset + 1]; // G
                    ret.data[offset + 2] = pRGBFrame->data[0][src_offset + 2]; // B
                    ret.data[offset + 3] = 255; // A
                }
            }
            return ret;
        }

        $cc proc freeImage {image_t* im} void {
            folkHeapFree(im->data);
        }

        $cc proc generateImage {int R int G int B int A} image_t {
            image_t ret;
            ret.width = 400;
            ret.height = 400;
            ret.components = 4;
            ret.bytesPerRow = ret.width * ret.components;
            ret.data = folkHeapAlloc(ret.bytesPerRow * ret.height);
            int b = ret.bytesPerRow * ret.height * 0.2;
            uint8_t L = 0xBB;

            memset(ret.data, L, b);

            for (uint32_t y = 0; y < ret.height; ++y) {
                for (uint32_t x = 0; x < ret.width; ++x) {
                    ret.data[y * ret.bytesPerRow + x * ret.components] = R; // R
                    ret.data[y * ret.bytesPerRow + x * ret.components + 1] = G; // G
                    ret.data[y * ret.bytesPerRow + x * ret.components + 2] = B; // B
                    ret.data[y * ret.bytesPerRow + x * ret.components + 3] = A; // A
                }
            }
            printf("returning fake image");
            return ret;
        }
        $cc proc generateWhiteImage {} image_t {
            return generateImage(255, 255, 255, 255);
        }

        $cc proc video {char* filename} image_t {
            AVFormatContext *pFormatContext = avformat_alloc_context();
            if (!pFormatContext) { exit(1); }

            fprintf(stdout, "pFC: %p | %s\n", &pFormatContext, filename);

            if (avformat_open_input(&pFormatContext, filename, NULL, NULL) != 0) {
                fprintf(stderr, "Could not open input file: %s\n", filename);
                exit(1);
            }

            int ret = avformat_find_stream_info(pFormatContext, NULL);

            fprintf(stderr, "pFC: %p | %s\n", &pFormatContext, filename);
            fprintf(stderr, "Format: %s | Duration: %ld us | Bit rate: %ld \n", pFormatContext->iformat->long_name, pFormatContext->duration, pFormatContext->bit_rate);
            fprintf(stderr, "URL: %s\n", pFormatContext->url);

            if (ret < 0) {
                char errbuf[128];
                av_strerror(ret, errbuf, sizeof(errbuf));
                fprintf(stderr, "Could not find stream info: %s\n", errbuf);
                avformat_close_input(&pFormatContext);
                avformat_free_context(pFormatContext);
                exit(1);
            }

            const AVCodec *pCodec = NULL;
            const AVCodecParameters *pCodecParameters =  NULL;
            for (int i = 0; i < pFormatContext->nb_streams; i++) {
                AVCodecParameters *pLocalCodecParameters = pFormatContext->streams[i]->codecpar;
                const AVCodec *pLocalCodec = avcodec_find_decoder(pLocalCodecParameters->codec_id);
                if (pLocalCodecParameters->codec_type == AVMEDIA_TYPE_VIDEO) {
                    fprintf(stderr, "Video Codec: resolution %d x %d\n", pLocalCodecParameters->width, pLocalCodecParameters->height);
                    pCodec = pLocalCodec;
                    pCodecParameters = pLocalCodecParameters;
                } else if (pLocalCodecParameters->codec_type == AVMEDIA_TYPE_AUDIO) {
                    fprintf(stderr, "Audio Codec: sample rate %d\n", pLocalCodecParameters->sample_rate);
                }
            }

            if (!pCodec) {
                fprintf(stderr, "Codec not found\n");
                avformat_close_input(&pFormatContext);
                avformat_free_context(pFormatContext);
                exit(1);
            }

            AVCodecContext *pCodecContext = avcodec_alloc_context3(pCodec);
            avcodec_parameters_to_context(pCodecContext, pCodecParameters);
            avcodec_open2(pCodecContext, pCodec, NULL);

            AVPacket *pPacket = av_packet_alloc();
            AVFrame *pFrame = av_frame_alloc();
            while (av_read_frame(pFormatContext, pPacket) >= 0) {
                ret = avcodec_send_packet(pCodecContext, pPacket);
                if (ret < 0) {
                    char errbuf[128];
                    av_strerror(ret, errbuf, sizeof(errbuf));
                    fprintf(stderr, "Error sending packet for decoding: %s\n", errbuf);
                    continue;
                }

                while (ret >= 0) {
                    ret = avcodec_receive_frame(pCodecContext, pFrame);
                    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
                        break;
                    } else if (ret < 0) {
                        char errbuf[128];
                        av_strerror(ret, errbuf, sizeof(errbuf));
                        fprintf(stderr, "Error receiving frame from decoder: %s\n", errbuf);
                        exit(1);
                    }

                    if (pCodecContext->frame_number == 1) {
                        fprintf(stderr, "!!!!! On frame one ...\n");

                        AVFrame* pRGBFrame = av_frame_alloc();
                        if (!pRGBFrame) {
                            fprintf(stderr, "Could not allocate RGB frame\n");
                            exit(1);
                        }

                        pRGBFrame->format = AV_PIX_FMT_RGB24;
                        pRGBFrame->width = pFrame->width;
                        pRGBFrame->height = pFrame->height;

                        int numBytes = av_image_get_buffer_size(AV_PIX_FMT_RGB24, pRGBFrame->width, pRGBFrame->height, 1);
                        uint8_t* buffer = (uint8_t*)av_malloc(numBytes * sizeof(uint8_t));
                        if (!buffer) {
                            fprintf(stderr, "Could not allocate buffer for RGB frame\n");
                            av_frame_free(&pRGBFrame);
                            exit(1);
                        }

                        av_image_fill_arrays(pRGBFrame->data, pRGBFrame->linesize, buffer, AV_PIX_FMT_RGB24, pRGBFrame->width, pRGBFrame->height, 1);

                        struct SwsContext* sws_ctx = sws_getContext(pFrame->width,
                                                                    pFrame->height,
                                                                    pFrame->format,
                                                                    pFrame->width,
                                                                    pFrame->height,
                                                                    AV_PIX_FMT_RGB24,
                                                                    SWS_BICUBIC,
                                                                    NULL,
                                                                    NULL,
                                                                    NULL);
                        if (!sws_ctx) {
                            fprintf(stderr, "Could not initialize the conversion context\n");
                            av_free(buffer);
                            av_frame_free(&pRGBFrame);
                            exit(1);
                        }

                        int sts = sws_scale(sws_ctx,
                                            (const uint8_t * const*)pFrame->data,
                                            pFrame->linesize,
                                            0,
                                            pFrame->height,
                                            pRGBFrame->data,
                                            pRGBFrame->linesize);
                        if (sts < 0) {
                            fprintf(stderr, "Error while converting frame\n");
                        } else {
                            fprintf(stderr, "Successfully converted frame\n");
                            /*
                            TODO: Figure out where to page video memory to get successive frames
                            */
                            return generateImageFromFrame(pRGBFrame, pRGBFrame->width, pRGBFrame->height);
                        }

                        sws_freeContext(sws_ctx);
                        av_free(buffer);
                        av_frame_free(&pRGBFrame);

                        break;  // Exit after processing the first frame
                    }
                }
                av_packet_unref(pPacket);
                if (pCodecContext->frame_number > 1) break;  // Exit after processing the first frame
            }

            av_frame_free(&pFrame);
            av_packet_free(&pPacket);
            avcodec_free_context(&pCodecContext);
            avformat_close_input(&pFormatContext);
            avformat_free_context(pFormatContext);
            return generateWhiteImage();
        }

        $cc compile
        init

        namespace export *
        namespace ensemble create
    }

    puts "====== kicked off display video ====== [info procs ::video]"
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes /thing/ displays video /videoSrc/]
    # Note: need to adjust these receive statements to allow region info to be passed here as well
    Wish $::thisProcess receives statements like \
        [list /someone/ claims /thing/ has region /r/]
    Wish $::thisProcess shares statements like \
        [list /someone/ wishes to draw an image with center /c/ image /im/ radians /radians/]
    Wish $::thisProcess shares statements like \
        [list /someone/ wishes /thing/ is titled /title/]

    When /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has region /r/ {
        puts "---- go video $videoSrc"

        set center [region centroid $r]
        set firstFrame [video video $videoSrc]
        # Make this a result of a when eventually, hard coded rn 
        Wish to draw an image with center $center image $firstFrame radians 0
        Wish $thing is titled "should be displaying the first frame of $videoSrc"
    }
}

# e.g.
# Wish $this displays video "/home/folk/bunny_1s_mute.mp4"
# When /someone/ wishes /thing/ displays video /videoSrc/ & /thing/ has region /r/ {
#     set center [region centroid $r]
#     set firstFrame [video::video $videoSrc]
#     # Make this a result of a when eventually, hard coded rn 
#     Wish to draw an image with center $center image $firstFrame radians 0
#     Wish $thing is titled "should be displaying the first frame of $videoSrc"
# }