On process "display" {
    namespace eval font {
        proc load {name} {
            set csvFd [open "vendor/fonts/$name.csv" r]; set csv [read $csvFd]; close $csvFd
            set glyphInfos [dict create]
            foreach line [split $csv "\n"] {
                set info [lassign [split $line ,] glyph]
                lassign $info advance \
                    planeLeft planeBottom planeRight planeTop \
                    atlasLeft atlasBottom atlasRight atlasTop
                dict set glyphInfos $glyph \
                    [list $advance \
                         [list $planeLeft $planeBottom $planeRight $planeTop] \
                         [list $atlasLeft $atlasBottom $atlasRight $atlasTop]]
            }

            set im [image load "[pwd]/vendor/fonts/$name.png"]
            set gim [Gpu::ImageManager::copyImageToGpu $im]

            return [list $glyphInfos $im $gim]
        }
        proc hasGlyphInfo {font charCode} { dict exists [lindex $font 0] $charCode }
        proc glyphInfo {font charCode} { dict get [lindex $font 0] $charCode }
        proc atlasImage {font} { lindex $font 1 }
        proc gpuAtlasImage {font} { lindex $font 2 }

        namespace export *
        namespace ensemble create
    }
    set font [font load "PTSans-Regular"]

    set rotate $::rotate
    set invBilinear $::invBilinear
    set glyphMsd [Gpu::fn {sampler2D atlas vec4 atlasGlyphBounds vec2 glyphUv} vec4 {
        vec2 atlasUv = mix(atlasGlyphBounds.xw, atlasGlyphBounds.zy, glyphUv);
        return texture(atlas, vec2(atlasUv.x, 1.0-atlasUv.y));
    }]
    set median [Gpu::fn {float r float g float b} float {
        return max(min(r, g), min(max(r, g), b));
    }]
    set glyph [Gpu::pipeline \
                   {sampler2D atlas vec2 atlasSize
                       vec4 atlasGlyphBounds
                       vec4 planeGlyphBounds
                       vec2 pos float radians float em
                       fn rotate} {
         float left = planeGlyphBounds[0] * em;
         float bottom = planeGlyphBounds[1] * em;
         float right = planeGlyphBounds[2] * em;
         float top = planeGlyphBounds[3] * em;
         vec2 a = pos + rotate(vec2(left, -top), -radians);
         vec2 b = pos + rotate(vec2(right, -top), -radians);
         vec2 c = pos + rotate(vec2(right, -bottom), -radians);
         vec2 d = pos + rotate(vec2(left, -bottom), -radians);

         vec2 vertices[4] = vec2[4](a, b, d, c);
         return vertices[gl_VertexIndex];
    } {fn rotate fn invBilinear fn glyphMsd fn median} {
        float left = planeGlyphBounds[0] * em;
        float bottom = planeGlyphBounds[1] * em;
        float right = planeGlyphBounds[2] * em;
        float top = planeGlyphBounds[3] * em;
        vec2 a = pos + rotate(vec2(left, -top), -radians);
        vec2 b = pos + rotate(vec2(right, -top), -radians);
        vec2 c = pos + rotate(vec2(right, -bottom), -radians);
        vec2 d = pos + rotate(vec2(left, -bottom), -radians);

        vec2 glyphUv = invBilinear(gl_FragCoord.xy, a, b, c, d);
        if( max( abs(glyphUv.x-0.5), abs(glyphUv.y-0.5))>=0.5 ) {
            return vec4(0, 0, 0, 0);
        }
        vec3 msd = glyphMsd(atlas, atlasGlyphBounds/atlasSize.xyxy, glyphUv).rgb;
        float sd = median(msd.r, msd.g, msd.b);
        float screenPxDistance = 4.5*(sd - 0.5);
        float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
        return mix(vec4(0, 0, 0, 0), vec4(1, 1, 1, 1), opacity);
    }]    

    fn textExtent {text scale} {
        set em [* $scale 25.0]
        set x 0; set y 0
        set width 0
        for {set i 0} {$i < [string length $text]} {incr i} {
            set char [string index $text $i]
            if {$char eq "\n"} {
                set y [+ $y $em]; set x 0; continue
            }
            set charCode [scan $char %c]
            if {[font hasGlyphInfo $font $charCode]} {
                set glyphInfo [font glyphInfo $font $charCode]
            } else {
                set glyphInfo [font glyphInfo $font [scan ? %c]]
            }
            lassign $glyphInfo advance planeBounds atlasBounds
            set x [+ $x [* $advance $em]]
            if {$x > $width} { set width $x }
        }
        return [list $width [+ $y $em]]
    }

    Wish $::thisProcess receives statements like \
        [list /someone/ wishes to draw text with /...options/]

    When /someone/ wishes to draw text with /...options/ {
        set x0 [dict get $options x]
        set y0 [dict get $options y]
        set scale [dict_getdef $options scale 1.0]
        set text [dict get $options text]
        set radians [dict get $options radians]

        set fontAtlas [font gpuAtlasImage $font]
        set fontAtlasSize [list [::image width [font atlasImage $font]] \
                               [::image height [font atlasImage $font]]]

        set extent [vec2 rotate [textExtent $text $scale] $radians]

        set em [* $scale 25.0]

        # TODO: Add text alignment/anchor options (right now, this
        # setup centers the text).
        set x0 [expr {$x0 - [lindex $extent 0]/2}]
        set y0 [expr {$y0 - [lindex $extent 1]/2}]
        set x $x0; set y $y0

        set lineNum 0
        for {set i 0} {$i < [string length $text]} {incr i} {
            set char [string index $text $i]
            if {$char eq "\n"} {
                incr lineNum
                lassign [vec2 add [list $x0 $y0] \
                             [vec2 rotate [list 0 [* $lineNum $em]] $radians]] x y
                continue
            }
            set charCode [scan $char %c]
            if {[font hasGlyphInfo $font $charCode]} {
                set glyphInfo [font glyphInfo $font $charCode]
            } else {
                set glyphInfo [font glyphInfo $font [scan ? %c]]
            }
            lassign $glyphInfo advance planeBounds atlasBounds
            if {$char ne " "} {
                lappend ::displayList \
                    [list Gpu::draw $glyph $fontAtlas $fontAtlasSize \
                         $atlasBounds $planeBounds [list $x $y] $radians $em]
            }
            lassign [vec2 add [list $x $y] \
                         [vec2 rotate [list [* $advance $em] 0] $radians]] x y
        }
    }
}
