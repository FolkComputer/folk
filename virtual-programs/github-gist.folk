package require json
package require json::write

namespace eval ::githubGist {
    variable _token ""
    variable _tokenLoaded false
    variable _cacheDir "$::env(HOME)/.cache/folk-gists"
    variable _jqFilter "{files: (.files? | map_values({filename, content}) // {}), description: (.description? // \"\")}"

    proc _loadToken {} {
        variable _token
        variable _tokenLoaded
        set tokenLocation "$::env(HOME)/folk-secrets/github-gist-token.txt"

        if {$_tokenLoaded} {
            return
        }

        puts stderr "DEBUG: Attempting to load token from $tokenLocation"
        if {![file exists $tokenLocation]} {
            puts stderr "Warning: GitHub Gist token file not found at $tokenLocation. Gist posting/private access may fail."
            set _tokenLoaded true
            return
        }

        if {[catch {
            set fd [open $tokenLocation r]
            set _token [string trim [read $fd]]
            close $fd
            set _tokenLoaded true
            puts stderr "DEBUG: Token loaded successfully."
        } errMsg]} {
            puts stderr "Error loading GitHub Gist token from $tokenLocation: $errMsg"
            set _tokenLoaded true
        }
    }

    proc _commonApiHeaders {} {
        return [list \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28"]
    }

    #TODO: This should eventually all be replaced with Wishes to `Hold deeply
    #$gistID is $gistContent` and then we can treat that as the cache.
    proc _ensureCacheDir {} { variable _cacheDir if {![file isdirectory
        $_cacheDir]} { puts stderr "DEBUG: Cache directory not found. Creating
        $_cacheDir" if {[catch {file mkdir $_cacheDir} errMsg]} { puts
        stderr "Error creating gist cache directory $_cacheDir: $errMsg"
        return false } } return true }

        proc _fetchGistData {gistID {token ""}} {
        variable _cacheDir
        variable _jqFilter

        set cacheFilePath "${_cacheDir}/${gistID}.json"

        # Try to read from cache first
        if {[file readable $cacheFilePath]} {
            puts stderr "DEBUG: Attempting to read from cache file: $cacheFilePath"
            set cachedContent ""
            set cacheReadError [catch {
                set fd [open $cacheFilePath r]
                set cachedContent [read $fd]
                close $fd
            } errMsg]

            if {$cacheReadError} {
                puts stderr "Warning: Could not read cached gist file $cacheFilePath: $errMsg."
            } else {
                puts stderr "DEBUG: Raw cached content for '$gistID': \"$cachedContent\""
                set parsedCachedGist {}
                set jsonParseError [catch {
                    set parsedCachedGist [json::json2dict $cachedContent]
                } errMsg]

                if {$jsonParseError} {
                    puts stderr "Warning: Could not parse cached gist file $cacheFilePath: $errMsg. Fetching from network."
                } else {
                    # Validate cached content structure before returning
                    if {[dict exists $parsedCachedGist files] && [dict size [dict get $parsedCachedGist files]] > 0} {
                        puts stderr "DEBUG: Gist ID \"$gistID\" successfully served from cache."
                        return $parsedCachedGist
                    } else {
                        puts stderr "DEBUG: Cached gist ID \"$gistID\" was empty or malformed, fetching from network."
                    }
                }
            }
        }

        # If not found in cache or cache invalid, proceed with network fetch
        puts stderr "DEBUG: Fetching gist '$gistID' from network..."
        set headers [::githubGist::_commonApiHeaders]
        if {$token ne ""} {
            lappend headers -H "Authorization: Bearer $token"
        }
        puts stderr "DEBUG: Curl command headers: [join $headers " "]"

        # Step 1: Run curl and capture its raw output
        set rawCurlOutput ""
        if {[catch {
            set rawCurlOutput [exec curl -LsS {*}$headers "https://api.github.com/gists/$gistID"]
        } errMsg opts]} {
            if {[string match "*curl:*" $errMsg] || [string match "*Couldn't resolve host*" $errMsg] || [string match "*transfer closed with*" $errMsg]} {
                return -code error "Network or curl error accessing gist ID \"$gistID\": $errMsg"
            } elseif {[string match "*command not found*" $errMsg]} {
                return -code error "External command (curl) not found. Please ensure it is installed and in your system's PATH. Error: $errMsg"
            } else {
                return -code error "Failed to execute curl for gist ID \"$gistID\": $errMsg"
            }
        }
        puts stderr "DEBUG: Raw curl output for '$gistID': \"$rawCurlOutput\""

        if {[string trim $rawCurlOutput] eq "" || [string trim $rawCurlOutput] eq "null"} {
            return -code error "Gist ID \"$gistID\" returned empty or null data from GitHub. Possible rate limit or non-existent gist."
        }

        # Step 2: Attempt to parse rawCurlOutput as JSON in Tcl
        set githubApiResponse {}
        if {[catch {
            set githubApiResponse [json::json2dict $rawCurlOutput]
        } jsonErrMsg opts]} {
            return -code error "GitHub API returned invalid JSON for gist ID \"$gistID\". Error: $jsonErrMsg. Raw response: \"$rawCurlOutput\""
        }

        # Step 3: Check for GitHub API specific error messages
        if {[dict exists $githubApiResponse message]} {
            set apiMessage [dict get $githubApiResponse message]
            if {[string match "*Not Found*" $apiMessage]} {
                return -code error "Gist ID \"$gistID\" not found on GitHub. Verify the ID is correct."
            } elseif {[string match "*rate limit exceeded*" $apiMessage]} {
                return -code error "GitHub API rate limit exceeded for gist ID \"$gistID\". Please try again later."
            } elseif {[string match "*Bad credentials*" $apiMessage]} {
                return -code error "Authentication error for gist ID \"$gistID\". Check your GitHub token (if using getGist)."
            } else {
                return -code error "GitHub API Error for gist ID \"$gistID\": $apiMessage. Documentation: [dict get $githubApiResponse documentation_url {}]"
            }
        }

        # Step 4: If no API error, proceed with jq to reformat the valid gist data
        set filesAsJson ""
        if {[catch {
            set filesAsJson [exec echo $rawCurlOutput | jq -c $_jqFilter]
        } jqErrMsg opts]} {
            return -code error "Failed to process gist data for \"$gistID\" with jq. Error: $jqErrMsg. Raw JSON (pre-jq): \"$rawCurlOutput\""
        }
        puts stderr "DEBUG: JQ-filtered output for '$gistID': \"$filesAsJson\""

        # Step 5: Final Tcl JSON parsing and validation of jq's output
        if {[string trim $filesAsJson] eq "" || [string trim $filesAsJson] eq "null" || [string trim $filesAsJson] eq "{}"} {
            return -code error "Gist ID \"$gistID\" resulted in empty or null data after jq processing. This might indicate an empty gist or an issue with the jq filter for unusual gist structures."
        }

        set gistAsDictionary {}
        if {[catch {
            set gistAsDictionary [json::json2dict $filesAsJson]
        } finalJsonErrMsg opts]} {
            return -code error "Failed to finalize JSON parsing for gist ID \"$gistID\" (after jq). Error: $finalJsonErrMsg. JQ Output: \"$filesAsJson\""
        }

        if {![dict exists $gistAsDictionary files]} {
            return -code error "Internal error: Processed gist ID \"$gistID\" JSON missing 'files' key after jq. This should not happen."
        }
        if {[dict size [dict get $gistAsDictionary files]] == 0} {
            return -code error "Gist ID \"$gistID\" contains no files, or the source data was invalid/empty (handled by jq to empty object)."
        }

        # Write to cache after successful fetch and processing
        if {[::githubGist::_ensureCacheDir]} {
            if {[catch {
                set fd [open $cacheFilePath w]
                puts $fd $filesAsJson
                close $fd
                puts stderr "DEBUG: Gist ID \"$gistID\" cached successfully."
            } errMsg]} {
                puts stderr "Warning: Could not write gist to cache file $cacheFilePath: $errMsg"
            }
        }

        puts stderr "DEBUG: Final parsed dictionary for '$gistID': $gistAsDictionary"
        return $gistAsDictionary
    }

    # gist should be a dictionary with key=filename and value=contents
    proc postGist {gist description} {
        variable _token
        ::githubGist::_loadToken

        if {$_token eq ""} {
            return -code error "GitHub token not available. Cannot post gist."
        }

        puts stderr "DEBUG: Attempting to post gist with description: '$description'"
        set files_obj [json::write object {*}[dict map {filename contents} $gist {
            set contents_obj [json::write object content [json::write string $contents]]
            }]]
            set json_payload [json::write object \
                description [json::write string $description] \
                public true \
                files $files_obj]
            puts stderr "DEBUG: JSON payload for POST: $json_payload"

            set response_json ""

            if {[catch {
                set headers [::githubGist::_commonApiHeaders]
                lappend headers -H "Authorization: Bearer $_token"

                set response_json [exec \
                    echo $json_payload | \
                    curl -LsS \
                    -X POST \
                    {*}$headers \
                    -d @- \
                    https://api.github.com/gists]
                puts stderr "DEBUG: Raw response from POST: $response_json"

                set response_dict [json::json2dict $response_json]

                if {[dict exists $response_dict message]} {
                    set msg [dict get $response_dict message]
                    if {[string match "*rate limit exceeded*" $msg]} {
                        return -code error "GitHub API Error (Rate Limit): $msg"
                    } elseif {[string match "*Bad credentials*" $msg]} {
                        return -code error "GitHub API Error (Bad Credentials): $msg"
                    } elseif {[string match "*Validation failed*" $msg]} {
                        return -code error "GitHub API Error (Validation Failed): $msg. Errors: [dict get $response_dict errors {}]"
                    } else {
                        return -code error "GitHub API Error when posting gist: $msg. Documentation: [dict get $response_dict documentation_url {}]"
                    }
                }

                return $response_dict
            } errMsg opts]} {
                if {[string match "*curl:*" $errMsg] || [string match "*Couldn't resolve host*" $errMsg] || [string match "*transfer closed with*" $errMsg]} {
                    return -code error "Network or curl error when posting gist: $errMsg"
                } elseif {[string match "*command not found*" $errMsg]} {
                    return -code error "External command (curl) not found. Error: $errMsg"
                } elseif {[string match "*invalid JSON*" $errMsg] || [string match "*malformed JSON*" $errMsg]} {
                    return -code error "JSON parsing error on GitHub response: $errMsg. Raw response: \"$response_json\""
                } else {
                    return -code error "Failed to post gist: $errMsg"
                }
            }
        }

        proc getGist {gistID} {
            variable _token
            ::githubGist::_loadToken
            return [::githubGist::_fetchGistData $gistID $_token]
        }
    }

    When /anyone/ wishes /page/ runs gist /gistID/ & /page/ has region /r/ {
        puts "[clock seconds] ---- looking for $gistID"
        if {[catch {
            set gistAsDictionary [::githubGist::getGist $gistID]

            if {[dict size [dict get $gistAsDictionary files]] == 0} {
                error "Gist ID \"$gistID\" contains no files to display."
            }

            set fileNames [dict keys [dict get $gistAsDictionary files]]

            if {[llength $fileNames] == 0} {
                error "Gist ID \"$gistID\" contains no readable files."
            }

            set firstFileName [lindex $fileNames 0]
            set content [dict get $gistAsDictionary files $firstFileName content]


            Claim $page has program code $content

            set angle [region angle $r]
            set pos [region bottom $r]
            Wish $page draws text "Gist: $firstFileName\n-------------\n$content" with font NeomatrixCode scale 0.6 offset [list -100 300]
        } errMsg]} {
            puts stderr "Error processing gist $gistID: $errMsg"
            Wish $page draws text "Failed to load gist: $errMsg" with anchor bottomleft font NeomatrixCode color red
        }
    }

    Claim $this has a demo {
        Wish $this runs gist d08fc48ebbfd35d989bdf7ceb92210e3
    }
