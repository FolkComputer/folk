set ROWS 5
set COLS 7

Wish the web server handles route "/calibrate$" with handler [list apply {{ROWS COLS} {
    set calibrationBoardPs [apply {{ROWS COLS} {
        set margin 36
        set PageWidth 612; set PageHeight 792
        set tagSideLength 60
        set tagOuterLength [expr {$tagSideLength * 10/6}]
        subst {
            %!PS
            << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

            % (0, 0) is bottom-left of portrait page right now.
            90 rotate 1 -1 scale
            % Now (0, 0) is top-left of landscape page.

            gsave
            $margin [/ $margin 2] translate
            1 -1 scale
            0 setgray /Helvetica findfont 12 scalefont setfont
            newpath 0 0 moveto (Folk calibration board) show
            grestore

            $margin $margin translate

            [try {
                set images [list]
                for {set row 0} {$row < $ROWS} {incr row} {
                    for {set col 0} {$col < $COLS} {incr col} {
                        set id [expr {48600 + $row*$COLS + $col}]
                        # Leave a gap at every odd tag for projected tags.
                        if {$id % 2 == 1} { continue }
                        lappend images [subst {
                            gsave
                            [expr {$tagOuterLength*$col}] [expr {$tagOuterLength*$row + $tagOuterLength}] translate
                            $tagOuterLength -$tagOuterLength scale
                            [::tagPsForId $id]
                            grestore
                        }]
                    }
                }
                join $images "\n"
            }]
        }
    }} $ROWS $COLS]
    set fp [open [list |ps2pdf - - <<$calibrationBoardPs] rb]
    set calibrationBoardPdf [read $fp]; close $fp

    upvar ^html ^html
    html [csubst {
      <html>
      <body>

      <iframe width="500px" height="300px" src="data:application/pdf;base64,$[binary encode base64 $calibrationBoardPdf]">
      </iframe>

      <p>
        Print the above board, then measure the inner side length (6 blocks) of a tag in millimeters,
        <br>enter it here, and click Begin Calibration:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Begin Calibration</button>
      </p>

      <script>
        function uuidv4() {
          return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
        }
        const self = uuidv4();

        document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
          // Report the side length to a statement in Folk.

          const mm = document.getElementById("tag-side-length-mm").value;

          window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
          ws.onopen = () => {
            ws.send(`
              set ::checkerboardDetections [list]
              Retract \${self} claims the checkerboard tag side length is /anything/ mm
              Assert \${self} claims the checkerboard tag side length is \${mm} mm
           `);
          };
          window.onbeforeunload = () => {
            ws.send(`
              set ::checkerboardDetections [list]
              Retract \${self} claims the checkerboard tag side length is /anything/ mm
            `);
          }
        });
      </script>

      </body>
    </html>
  }]
}} $ROWS $COLS]

When the checkerboard tag side length is /sideLengthMm/ mm {
    # Project projected tags once the side length has been dialed in.
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            # Leave a gap at every even tag for printed tags.
            if {$id % 2 == 0} { continue }

            set center [list 0 0]
            set im [::tagImageForId $id]
            Wish to draw an image with center $center image $im radians 0 scale 1
        }
    }
}

fn isValidCheckerboardDetection {detection} {
    set numPrintedTags 0 ;# (even-numbered tags)
    set numProjectedTags 0 ;# (odd-numbered tags)
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            if {[dict exists $detection $id]} {
                if {$id % 2 == 0} {
                    incr numPrintedTags 
                } else {
                    incr numProjectedTags
                }
            }
        }
    }
    return [expr {$numPrintedTags > 0 && $numProjectedTags > 0}]

    # TODO: Check that the checkerboard occupies a solid majority of
    # the camera space.
}

package require math::linearalgebra
namespace import ::math::linearalgebra::*

fn findHomography {sideLength detection} {
    # Camera points, from the camera image.
    fn detectionTagCorner {row col corner} {
        set id [expr {48600 + $row*$COLS + $col}]
        return [lindex [dict get [dict get $detection $id] corners] $corner]
    }
    set points [list]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            lappend points [detectionTagCorner $row $col 0]
            lappend points [detectionTagCorner $row $col 1]
            lappend points [detectionTagCorner $row $col 2]
            lappend points [detectionTagCorner $row $col 3]
        }
    }

    # Model points, from the known geometry of the checkerboard (in
    # meters, where top-left corner of top-left AprilTag is 0, 0).
    set model [list]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            lappend model [list [* $col $sideLength 2] \
                               [+ [* $row $sideLength 2] $sideLength]] ;# bottom-left

            lappend model [list [+ [* $col $sideLength 2] $sideLength] \
                               [+ [* $row $sideLength 2] $sideLength]] ;# bottom-right

            lappend model [list [+ [* $col $sideLength 2] $sideLength] \
                               [* $row $sideLength 2]] ;# top-right

            lappend model [list [* $col $sideLength 2] [* $row $sideLength 2]] ;# top-left
        }
    }

    set A [list]
    set b [list]
    foreach imagePoint $points modelPoint $model {
        lassign $imagePoint u v
        lassign $modelPoint x y
        lappend A [list $x $y 1 0  0  0 [expr {-$x*$u}] [expr {-$y*$u}]]
        lappend A [list 0  0  0 $x $y 1 [expr {-$x*$v}] [expr {-$y*$v}]]
        lappend b $u $v
    }

    lassign [leastSquaresSVD $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]

    return $H
}

fn processHomography {H} {
    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}

exec mkdir -p "$::env(HOME)/folk-calibrate-detections"
fn calibrate {sideLength detections} {
    # sideLength is inner side length of a tag, in meters.
    # detections is a list of N dictionaries of detected tags.

    set fd [open "$::env(HOME)/folk-calibrate-detections/$::thisNode-detections-[clock milliseconds].tcl" w]
    puts $fd [subst {
        set sideLength $sideLength
        set detections {$detections}
    }]
    close $fd

    # The below calibration technique is from Zhang
    # (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf):

    # Compute N homographies (one homography for each detection):
    set Hs [lmap detection $detections {
        findHomography $sideLength $detection
    }]

    # puts "Detections {$detections}"
    # puts "Hs {$Hs}"

    # Try to solve for the camera intrinsics:
    try {
        # Construct V:
        set Vtop [list]; set Vbottom [list]
        foreach H $Hs {
            lassign [processHomography $H] Vtop_ Vbottom_
            lappend Vtop $Vtop_
            lappend Vbottom $Vbottom_
        }
        set V [list {*}$Vtop {*}$Vbottom]
        assert {[::math::linearalgebra::shape $V] eq [list [* 2 [llength $Hs]] 6]}

        # Solve Vb = 0:
        lassign [determineSVD [matmul [transpose $V] $V]] U S V'
        set b [lindex [transpose ${V'}] [lindex [lsort -real -indices $S] 0]]

        # Compute camera intrinsic matrix A:
        lassign $b B11 B12 B22 B13 B23 B33
        set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
        set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
        set alpha [expr {sqrt($lambda/$B11)}]
        set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
        set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
        set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
        foreach var {v0 lambda alpha beta gamma u0} {
            puts "$var = [set $var]"
        }

        puts "   Focal Length: \[ $alpha $beta ]"
        puts "Principal Point: \[ $u0 $v0 ]"
        puts "           Skew: \[ $gamma ] "

        # TODO: nlopt for better intrinsics + distortion parameters
    } on error e {
        puts stderr $::errorInfo
    }
}

set ::checkerboardDetections [list]
set ::checkerboardLastDetectionTimestamp 0
When the checkerboard tag side length is /sideLengthMm/ mm & \
     /someone/ detects tags /tags/ at /timestamp/ in time /aprilTime/ {

    if {[llength $::checkerboardDetections] >= 4} { return }

    set detection [dict create] ;# dict keyed by tag id for easy lookup
    foreach tag $tags { dict set detection [dict get $tag id] $tag }

    # Does it contain all of the calibration tags?
    if {($timestamp - $::checkerboardLastDetectionTimestamp > 2000) &&
        [isValidCheckerboardDetection $detection]} {
        puts "Capturing calibration checkerboard"
        lappend ::checkerboardDetections $detection
        set ::checkerboardLastDetectionTimestamp $timestamp
    }

    # if {[llength $::checkerboardDetections] == 4} {
    #     puts "Detected 4 checkerboards. Calibrating."
    #     set sideLength [/ $sideLengthMm 1000.0] ;# in meters
    #     calibrate $sideLength $::checkerboardDetections
    # }
}
