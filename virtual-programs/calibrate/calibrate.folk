package require math::linearalgebra
foreach p {add norm sub scale leastSquaresSVD matmul} {
    namespace import ::math::linearalgebra::$p
}

package require math::geometry
namespace import ::math::geometry::findLineIntersection ::math::geometry::pointInsidePolygon

package require math
namespace import ::math::mean

set ROWS 4
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `center` and `corners` which are
# model points (x, y). The tags on the outer perimeter will get
# projected to PostScript points and printed; the tags in the
# interior will get projected to Vulkan points and rendered on
# projector.
set MODEL [apply {{ROWS COLS} {
    set MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              center [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              corners [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set MODEL $id $modelTag
        }
    }
    return $MODEL
}} $ROWS $COLS]

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    # We print tags on the outer perimeter of the grid, and we project
    # tags in the interior.
    set idx [- $id 48600]
    set row [expr {$idx / $COLS}]
    set col [expr {$idx % $COLS}]
    return [expr {$row == 0 || $row == $ROWS - 1 ||
                  $col == 0 || $col == $COLS - 1}]
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    ! [isPrintedTag $id]
}

# Takes a list of at least 4 point pairs (model -> image) like
#
# [list \
#   [list x0 y0 u0 v0]] \
#   [list x1 y1 u1 v1] \
#   [list x2 y2 u2 v2] \
#   [list x3 y3 u3 v3]]
#
# Returns a 3x3 homography that maps model (x, y) to image (u, v)
# (using homogeneous coordinates).
fn estimateHomography {pointPairs} {
    set A [list]
    set b [list]
    foreach pair $pointPairs {
        lassign $pair x y u v
        lappend A [list $x $y 1 0  0  0 [expr {-$x*$u}] [expr {-$y*$u}]]
        lappend A [list 0  0  0 $x $y 1 [expr {-$x*$v}] [expr {-$y*$v}]]
        lappend b $u $v
    }

    lassign [leastSquaresSVD $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]
    return $H
}
fn applyHomography {H xy} {
    lassign [matmul $H [list {*}$xy 1]] u v w
    return [list [/ $u $w] [/ $v $w]]
}

Wish the web server handles route "/calibrate$" with handler [list apply {{MODEL ^isPrintedTag ^estimateHomography ^applyHomography} {
    set calibrationBoardPs [apply {{MODEL ^isPrintedTag ^estimateHomography ^applyHomography} {
        set marginTop 72; set marginLeft 36
        set PageWidth 612; set PageHeight 792

        set innerToOuter 0.333333

        set tagSideLengthPs 50
        set tagOuterLengthPs [expr {$tagSideLengthPs * 10/6}]

        set H_modelToPs [estimateHomography [subst {
            {1 1 $tagSideLengthPs $tagSideLengthPs}
            {1 0 $tagSideLengthPs 0}
            {0 1 0 $tagSideLengthPs}
            {0 0 0 0}
        }]]

        subst {
            %!PS
            << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

            % (0, 0) is bottom-left of portrait page right now.
            90 rotate 1 -1 scale
            % Now (0, 0) is top-left of landscape page.

            gsave
            $marginLeft [- $marginTop 18] translate
            1 -1 scale
            0 setgray /Helvetica findfont 12 scalefont setfont
            newpath 0 0 moveto (Folk calibration board) show
            grestore

            $marginLeft $marginTop translate

            [join [dict values [dict map {id modelTag} $MODEL {
                if {![isPrintedTag $id]} { continue }

                set modelInnerTopLeft [lindex [dict get $modelTag corners] 3]
                set modelOuterTopLeft [add $modelInnerTopLeft [list -$innerToOuter -$innerToOuter]]
                lassign [applyHomography $H_modelToPs $modelOuterTopLeft] psX psY
                subst {
                    gsave
                    $psX [+ $psY $tagOuterLengthPs] translate
                    $tagOuterLengthPs -$tagOuterLengthPs scale
                    [::tagPsForId $id]
                    grestore
                }
            }]] "\n"]
        }
    }} $MODEL ${^isPrintedTag} ${^estimateHomography} ${^applyHomography}]
    set fp [open [list |ps2pdf - - <<$calibrationBoardPs] rb]
    set calibrationBoardPdf [read $fp]; close $fp

    upvar ^html ^html
    html [csubst {
      <html>
      <head><title>Folk: Calibrate</title></head>
      <body>

      <iframe width="500px" height="300px" src="data:application/pdf;base64,$[binary encode base64 $calibrationBoardPdf]">
      </iframe>

      <p>
        Print the above board, then measure the inner side length (6 blocks) of a tag in millimeters,
        <br>enter it here, and click Begin Calibration:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Begin Calibration</button>
      </p>

      <script>
        function uuidv4() {
          return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
        }
        const self = uuidv4();

        document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
          // Report the side length to a statement in Folk.

          const mm = document.getElementById("tag-side-length-mm").value;

          window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
          ws.onopen = () => {
            ws.send(`
              set ::checkerboardDetections [list]
              Retract \${self} claims the printed tag side length is /anything/ mm
              Assert \${self} claims the printed tag side length is \${mm} mm
           `);
          };
          window.onbeforeunload = () => {
            ws.send(`
              set ::checkerboardDetections [list]
              Retract \${self} claims the printed tag side length is /anything/ mm
            `);
          }
        });
      </script>

      </body>
    </html>
  }]
}} $MODEL ${^isPrintedTag} ${^estimateHomography} ${^applyHomography}]

Wish the GPU compiles pipeline "apriltag" {
    {uvec4 tagBitsVec vec2 a vec2 b vec2 c vec2 d} {
        vec2 vertices[4] = vec2[4](a, b, d, c);
        return vertices[gl_VertexIndex];
    } {fn ::invBilinear} {
        vec2 p = gl_FragCoord.xy;
        vec2 uv = invBilinear(p, a, b, c, d);

        int x = int(uv.x * 10); int y = int(uv.y * 10);
        int bitIdx = y * 10 + x;
        uint bit = (tagBitsVec[bitIdx / 32] >> (bitIdx % 32)) & 0x1;
        return bit == 1 ? vec4(1, 1, 1, 1) : vec4(0, 0, 0, 1);
    }
}
When the display Display has width /displayWidth/ height /displayHeight/ &\
     the printed tag side length is /printedSideLengthMm/ mm {
    # Project projected tags once the printed side length has been
    # dialed in.

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set innerToOuter [expr {($tagOuterLength - $tagSideLength)/2}]
    set pad $tagSideLength

    When /nobody/ claims the calibration model-to-display homography is /anything/ at /_/ {
        set tagSideLengthPixels [expr {int(min($displayWidth/($COLS * ($tagOuterLength + $pad)),
                                               $displayHeight/($ROWS * ($tagOuterLength + $pad))))}]

        set H_modelToDisplay [estimateHomography [subst {
            {1 1 $tagSideLengthPixels $tagSideLengthPixels}
            {1 0 $tagSideLengthPixels 0}
            {0 1 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Commit H_modelToDisplay { Claim the calibration model-to-display homography is $H_modelToDisplay at [clock milliseconds] }
    }

    When the calibration model-to-display homography is /H_modelToDisplay/ at /timestamp/ {
        set instances [list]
        dict for {id modelTag} $MODEL {
            if {![isProjectedTag $id]} { continue }

            set tagImage [::tagImageForId $id]
            set tagBits [list]
            # 10x10 AprilTag -> 100 bits
            for {set y 0} {$y < 10} {incr y} {
                for {set x 0} {$x < 10} {incr x} {
                    set j [expr {$y * [image_t bytesPerRow $tagImage] + $x}]
                    set bit [== [image_t data $tagImage $j] 255]
                    lappend tagBits $bit
                }
            }
            # -> 4 32-bit integers
            set tagBitsVec [list 0b[join [lreverse [lrange $tagBits 0 31]] ""] \
                                0b[join [lreverse [lrange $tagBits 32 63]] ""] \
                                0b[join [lreverse [lrange $tagBits 64 95]] ""] \
                                0b[join [lreverse [lrange $tagBits 96 127]] ""]]
            set modelInnerCorners [dict get $modelTag corners]
            set modelOuterBottomLeft [add [lindex $modelInnerCorners 0] [list -$innerToOuter $innerToOuter]]
            set modelOuterBottomRight [add [lindex $modelInnerCorners 1] [list $innerToOuter $innerToOuter]]
            set modelOuterTopRight [add [lindex $modelInnerCorners 2] [list $innerToOuter -$innerToOuter]]
            set modelOuterTopLeft [add [lindex $modelInnerCorners 3] [list -$innerToOuter -$innerToOuter]]
            lappend instances \
                [list $tagBitsVec \
                     [applyHomography $H_modelToDisplay $modelOuterTopLeft]  \
                     [applyHomography $H_modelToDisplay $modelOuterTopRight] \
                     [applyHomography $H_modelToDisplay $modelOuterBottomRight] \
                     [applyHomography $H_modelToDisplay $modelOuterBottomLeft]]
        }
        Wish to draw a quad with \
            p0 [list 0 0] p1 [list $displayWidth 0] \
            p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
            color white layer 99
        Wish the GPU draws pipeline "apriltag" with instances $instances layer 100
    }

    # TODO: Look for valid detections and re-adjust.
    When /someone/ detects tags /tags/ at /timestamp/ in time /something/ &\
         the calibration model-to-display homography is /H_modelToDisplay/ at /hTimestamp/ {

        if {$timestamp - $hTimestamp < 500} { return }

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $MODEL $id]
            foreach modelCorner [dict get $modelTag corners] \
                cameraCorner [dict get $printedTag corners] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $MODEL [expr {48600 + 0*$COLS + 0}] corners] 3]
        set modelTopRight [lindex [dict get $MODEL [expr {48600 + 0*$COLS + $COLS-1}] corners] 2]
        set modelBottomRight [lindex [dict get $MODEL [expr {48600 + ($ROWS-1)*$COLS + 0}] corners] 1]
        set modelBottomLeft [lindex [dict get $MODEL [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] corners] 0]
        set printedCalibrationBoard [list {*}[applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomLeft]]

        set projectedTags [dict create]
        set outsideBoardProjectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }
            if {[pointInsidePolygon [dict get $tag center] $printedCalibrationBoard]} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            } else {
                dict set outsideBoardProjectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # puts "======\nHave board: {$printedCalibrationBoard}"
        # puts "Saw printed tags: ($printedTags)"
        # puts "Saw projected tags: ($projectedTags)"
        puts "======\nHave board: {$printedCalibrationBoard}"
        puts "Saw printed tags: [dict size $printedTags] ([expr {round(double([dict size $printedTags])/($ROWS*2 + 2*($COLS-2)) * 100)}]%)"
        puts "Saw projected tags: [dict size $projectedTags] ([expr {round(double([dict size $projectedTags])/(($ROWS-2)*($COLS-2)) * 100)}]%)"
        dict for {id tag} $projectedTags {
            set idx [- $id 48600]
            set row [expr {$idx / $COLS}]; set col [expr {$idx % $COLS}]
            puts "  Saw projected tag $id (row $row, col $col)"
        }
        puts "  Saw outside-board projected tags: [dict size $outsideBoardProjectedTags] ([expr {round(double([dict size $outsideBoardProjectedTags])/(($ROWS-2)*($COLS-2)) * 100)}]%)"

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $MODEL $id]
            foreach modelCorner [dict get $modelTag corners] \
                cameraCorner [dict get $projectedTag corners] {
                    set displayCorner [applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]

        set H_modelToDisplay [matmul $H_cameraToDisplay $H_modelToCameraViaPs]
        Commit H_modelToDisplay {
            Claim the calibration model-to-display homography is $H_modelToDisplay at $timestamp
        }

        # Are we ready to record these points for calibration?
        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }
        # Check if projected tag corners have been pretty stable since
        # the last frame.
        if {[info exists ::prevProjectedTags]} {
            set prevProjectedTags $::prevProjectedTags
            set ::prevProjectedTags $projectedTags
        } else {
            set ::prevProjectedTags $projectedTags
            return
        }
        set differencesFromPrevProjectedTags [list]
        dict for {id projectedTag} $projectedTags {
            if {![dict exists $prevProjectedTags $id]} { continue }
            set prevCorners [dict get $prevProjectedTags $id corners]
            set cornerDifferences [lmap corner [dict get $projectedTag corners] \
                                       prevCorner $prevCorners {
                norm [sub $corner $prevCorner]
            }]
            lappend differencesFromPrevProjectedTags {*}$cornerDifferences
        }
        puts "-----------\nMean: [mean {*}$differencesFromPrevProjectedTags]\n---------"
        if {[llength $differencesFromPrevProjectedTags] == 0 ||
            [mean {*}$differencesFromPrevProjectedTags] > 5} {
            return
        }

        # FIXME: Quick hack so you can tell calibration went through.
        Retract /someone/ claims the printed tag side length is /anything/ mm
        
        # TODO: Check if camera corners _have_ moved a lot since last saved
        # corners.

        set ::prevProjectedTags $projectedTags
    }
}

fn findHomography {sideLength detection} {
    # Camera points, from the camera image.
    fn detectionTagCorner {row col corner} {
        set id [expr {48600 + $row*$COLS + $col}]
        return [lindex [dict get [dict get $detection $id] corners] $corner]
    }
    set points [list]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            lappend points [detectionTagCorner $row $col 0]
            lappend points [detectionTagCorner $row $col 1]
            lappend points [detectionTagCorner $row $col 2]
            lappend points [detectionTagCorner $row $col 3]
        }
    }

    # Model points, from the known geometry of the checkerboard (in
    # meters, where top-left corner of top-left AprilTag is 0, 0).
    set model [list]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            lappend model [list [* $col $sideLength 2] \
                               [+ [* $row $sideLength 2] $sideLength]] ;# bottom-left

            lappend model [list [+ [* $col $sideLength 2] $sideLength] \
                               [+ [* $row $sideLength 2] $sideLength]] ;# bottom-right

            lappend model [list [+ [* $col $sideLength 2] $sideLength] \
                               [* $row $sideLength 2]] ;# top-right

            lappend model [list [* $col $sideLength 2] [* $row $sideLength 2]] ;# top-left
        }
    }

    set A [list]
    set b [list]
    foreach imagePoint $points modelPoint $model {
        lassign $imagePoint u v
        lassign $modelPoint x y
        lappend A [list $x $y 1 0  0  0 [expr {-$x*$u}] [expr {-$y*$u}]]
        lappend A [list 0  0  0 $x $y 1 [expr {-$x*$v}] [expr {-$y*$v}]]
        lappend b $u $v
    }

    lassign [leastSquaresSVD $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]

    return $H
}

fn processHomography {H} {
    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}

exec mkdir -p "$::env(HOME)/folk-calibrate-detections"
fn calibrate {sideLength detections} {
    # sideLength is inner side length of a tag, in meters.
    # detections is a list of N dictionaries of detected tags.

    set fd [open "$::env(HOME)/folk-calibrate-detections/$::thisNode-detections-[clock milliseconds].tcl" w]
    puts $fd [subst {
        set sideLength $sideLength
        set detections {$detections}
    }]
    close $fd

    # The below calibration technique is from Zhang
    # (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf):

    # Compute N homographies (one homography for each detection):
    set Hs [lmap detection $detections {
        findHomography $sideLength $detection
    }]

    # puts "Detections {$detections}"
    # puts "Hs {$Hs}"

    # Try to solve for the camera intrinsics:
    try {
        # Construct V:
        set Vtop [list]; set Vbottom [list]
        foreach H $Hs {
            lassign [processHomography $H] Vtop_ Vbottom_
            lappend Vtop $Vtop_
            lappend Vbottom $Vbottom_
        }
        set V [list {*}$Vtop {*}$Vbottom]
        assert {[::math::linearalgebra::shape $V] eq [list [* 2 [llength $Hs]] 6]}

        # Solve Vb = 0:
        lassign [determineSVD [matmul [transpose $V] $V]] U S V'
        set b [lindex [transpose ${V'}] [lindex [lsort -real -indices $S] 0]]

        # Compute camera intrinsic matrix A:
        lassign $b B11 B12 B22 B13 B23 B33
        set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
        set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
        set alpha [expr {sqrt($lambda/$B11)}]
        set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
        set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
        set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
        foreach var {v0 lambda alpha beta gamma u0} {
            puts "$var = [set $var]"
        }

        puts "   Focal Length: \[ $alpha $beta ]"
        puts "Principal Point: \[ $u0 $v0 ]"
        puts "           Skew: \[ $gamma ] "

        # TODO: nlopt for better intrinsics + distortion parameters
    } on error e {
        puts stderr $::errorInfo
    }
}

# set ::checkerboardDetections [list]
# set ::checkerboardLastDetectionTimestamp 0
When the printed tag side length is /sideLengthMm/ mm & \
     /someone/ detects tags /tags/ at /timestamp/ in time /aprilTime/ {

    # if {[llength $::checkerboardDetections] >= 4} { return }

    # set detection [dict create] ;# dict keyed by tag id for easy lookup
    # foreach tag $tags { dict set detection [dict get $tag id] $tag }

    # Does it contain all of the calibration tags?
    # if {($timestamp - $::checkerboardLastDetectionTimestamp > 2000) &&
    #     [isValidCheckerboardDetection $detection]} {
    #     puts "Capturing calibration checkerboard"
    #     lappend ::checkerboardDetections $detection
    #     set ::checkerboardLastDetectionTimestamp $timestamp
    # }

    # if {[llength $::checkerboardDetections] == 4} {
    #     puts "Detected 4 checkerboards. Calibrating."
    #     set sideLength [/ $sideLengthMm 1000.0] ;# in meters
    #     calibrate $sideLength $::checkerboardDetections
    # }
}
