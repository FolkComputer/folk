# calibrate.folk --
#
#     Implements camera-projector calibration: generate a calibration
#     pattern PDF, have the user measure its real-world dimension, run
#     iterative projector-camera process to get various poses of the
#     printed tags alongside projected tags, do linear fit and then
#     nonlinear refinement to find intrinsic and extrinsic parameters
#     for the camera and projector.
#
#     Closely based on the technique in Audet (2009):
#     http://www.ok.sc.e.titech.ac.jp/res/PCS/publications/procams2009.pdf
#

package require math::linearalgebra
# rename ::scale scaleTk
foreach p {add norm sub scale matmul
    getelem transpose determineSVD shape mkIdentity show
    solvePGauss crossproduct getcol setcol unitLengthVector det
} {
    namespace import ::math::linearalgebra::$p
}

# We try to use the AprilTag matrix library (instead of tcllib linalg)
# to do matrix/homography operations in the live calibration inner
# loop, to help with performance:
set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <common/matd.h>
$cc include <common/homography.h>

$cc code {
    extern Tcl_ObjType matd_ObjType;
    void matd_freeIntRepProc(Tcl_Obj *objPtr) {
        matd_destroy((matd_t*) objPtr->internalRep.otherValuePtr);
    }
    void matd_dupIntRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr) {
        dupPtr->internalRep.otherValuePtr = (void*) matd_copy((matd_t*) srcPtr->internalRep.otherValuePtr);
    }
    void matd_updateStringProc(Tcl_Obj *objPtr) {
        matd_t* mat = (matd_t*) objPtr->internalRep.otherValuePtr;

        Tcl_DString ds; Tcl_DStringInit(&ds);
        for (unsigned int row = 0; row < mat->nrows; row++) {
            Tcl_DStringStartSublist(&ds);
            for (unsigned int col = 0; col < mat->ncols; col++) {
                char el[16];
                FOLK_ENSURE(snprintf(el, sizeof(el), "%f", MATD_EL(mat, row, col)) < 16);
                Tcl_DStringAppendElement(&ds, el);
            }
            Tcl_DStringEndSublist(&ds);
        }

        objPtr->length = Tcl_DStringLength(&ds);
        objPtr->bytes = ckalloc(objPtr->length + 1);
        snprintf(objPtr->bytes, objPtr->length + 1, "%s", Tcl_DStringValue(&ds));
        Tcl_DStringFree(&ds);
    }
    int matd_setFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr) {
        // shimmer into a list, then iterate
        int nrows; Tcl_Obj** rowObjs;
        __ENSURE_OK(Tcl_ListObjGetElements(interp, objPtr, &nrows, &rowObjs));
        __ENSURE(nrows > 0);
        int ncols;
        __ENSURE_OK(Tcl_ListObjLength(interp, rowObjs[0], &ncols));
        __ENSURE(ncols > 0);

        matd_t* mat = matd_create(nrows, ncols);
        for (int row = 0; row < nrows; row++) {
            int rowCols; Tcl_Obj** elObjs;
            __ENSURE_OK(Tcl_ListObjGetElements(interp, rowObjs[row], &rowCols, &elObjs));
            __ENSURE(rowCols == ncols);
            for (int col = 0; col < ncols; col++) {
                __ENSURE_OK(Tcl_GetDoubleFromObj(interp, elObjs[col], &MATD_EL(mat, row, col)));
            }
        }
        objPtr->typePtr = &matd_ObjType;
        objPtr->internalRep.otherValuePtr = mat;
        return TCL_OK;
    }
    Tcl_ObjType matd_ObjType = (Tcl_ObjType) {
        .name = "matd_t*",
        .freeIntRepProc = matd_freeIntRepProc,
        .dupIntRepProc = matd_dupIntRepProc,
        .updateStringProc = matd_updateStringProc,
        .setFromAnyProc = matd_setFromAnyProc,
    };
}
$cc argtype matd_t* {
    __ENSURE_OK(Tcl_ConvertToType(interp, $obj, &matd_ObjType));
    matd_t* $argname;
    $argname = (matd_t*) $obj->internalRep.otherValuePtr;
}
$cc rtype matd_t* {
    $robj = Tcl_NewObj();
    $robj->bytes = NULL;
    $robj->typePtr = &matd_ObjType;
    $robj->internalRep.otherValuePtr = $rvalue;
}

# Takes a list of at least 4 point pairs (model -> image) like
#
# [list \
#   [list x0 y0 u0 v0]] \
#   [list x1 y1 u1 v1] \
#   [list x2 y2 u2 v2] \
#   [list x3 y3 u3 v3]]
#
# Returns a 3x3 homography that maps model (x, y) to image (u, v)
# (using homogeneous coordinates).
$cc proc estimateHomographyImpl {int nPointPairs float[][4] pointPairs} matd_t* {
    // HACK: (sort of) point to the existing data block.
    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]),
        .size = nPointPairs, .alloc = nPointPairs,
        .data = (char*) pointPairs
    };
    return homography_compute(&correspondencesArr,
                              HOMOGRAPHY_COMPUTE_FLAG_SVD);
}
# HACK: wrapper because we have to give the array length as a separate
# arg (at least for now).
proc estimateHomography {pointPairs} {
    estimateHomographyImpl [llength $pointPairs] $pointPairs
}
$cc proc applyHomography {matd_t* H double[2] xy} Tcl_Obj* {
    double out[2];
    homography_project(H, xy[0], xy[1], &out[0], &out[1]);

    Tcl_Obj* retObjs[2] = { Tcl_NewDoubleObj(out[0]), Tcl_NewDoubleObj(out[1]) };
    return Tcl_NewListObj(2, retObjs);
}
$cc proc matdMul {matd_t* a matd_t* b} matd_t* {
    return matd_multiply(a, b);
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

set ROWS 4
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `c` and `p` which are
# model points (x, y). The tags on the outer perimeter will get
# projected to PostScript points and printed; the tags in the
# interior will get projected to Vulkan points and rendered on
# projector.
set UNIT_MODEL [apply {{ROWS COLS} {
    set UNIT_MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              c [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              p [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set UNIT_MODEL $id $modelTag
        }
    }
    return $UNIT_MODEL
}} $ROWS $COLS]
Claim the calibration unit model is $UNIT_MODEL

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    # We print tags on the outer perimeter of the grid, and we project
    # tags in the interior.
    set idx [- $id 48600]
    set row [expr {$idx / $COLS}]
    set col [expr {$idx % $COLS}]
    return [expr {$row == 0 || $row == $ROWS - 1 ||
                  $col == 0 || $col == $COLS - 1}]
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    ! [isPrintedTag $id]
}

# Takes a dictionary of tag ID => {p, c} and rotates version tags
# according to version.
fn versionizeTags {tags version} {
    foreach id [dict keys $tags] {
        if {!([isProjectedTag $id] && $id % 2 == 1)} {
            continue
        }
        # This is a version tag. Rotate it.
        set p [dict get $tags $id p]
        set rotatedCorners [list]
        for {set i 0} {$i < 4} {incr i} {
            lappend rotatedCorners [lindex $p [expr {($i + $version) % 4}]]
        }
        dict set tags $id p $rotatedCorners
    }
    return $tags
}

package require math
namespace import ::math::mean
fn meanPoseDifference {pose1 pose2} {
    set tags1 [dict get $pose1 tags]
    set tags2 [dict get $pose2 tags]

    set diffsum 0.0
    set ndiffs 0
    dict for {id tag} $tags1 {
        # We cheat and only count printed tags so we don't have to
        # deal with versioning.
        if {![isPrintedTag $id]} { continue }
        if {![dict exists $tags2 $id]} { continue }

        lassign [dict get $tag c] x1 y1
        lassign [dict get $tags2 $id c] x2 y2
        set diffsum [expr {$diffsum + sqrt(($x1 - $x2)*($x1 - $x2) + ($y1 - $y2)*($y1 - $y2))}]
        incr ndiffs
    }
    if {$ndiffs == 0} { return Inf }
    return [expr {$diffsum / $ndiffs}]
}

fn makeCalibrationBoardPdf {model tagSideLengthPs tagIdPredicate} {
    set marginTop 72; set marginLeft 36
    set PageWidth 612; set PageHeight 792

    set innerToOuter 0.333333

    set tagOuterLengthPs [expr {$tagSideLengthPs * 10/6}]

    set H_modelToPs [estimateHomography [subst {
        {1 1 $tagSideLengthPs $tagSideLengthPs}
        {1 0 $tagSideLengthPs 0}
        {0 1 0 $tagSideLengthPs}
        {0 0 0 0}
    }]]

    set ps [subst {
        %!PS
        << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

        % (0, 0) is bottom-left of portrait page right now.
        90 rotate 1 -1 scale
        % Now (0, 0) is top-left of landscape page.

        gsave
        $marginLeft [- $marginTop 18] translate
        1 -1 scale
        0 setgray /Helvetica findfont 14 scalefont setfont
        newpath 0 0 moveto (Folk calibration board) show
        grestore

        $marginLeft $marginTop translate

        [set tagIdx -1]
        [join [dict values [dict map {id modelTag} $model {
            if {![apply $tagIdPredicate $id]} { continue }
            incr tagIdx

            set modelInnerTopLeft [lindex [dict get $modelTag p] 3]
            set modelOuterTopLeft [add $modelInnerTopLeft [list -$innerToOuter -$innerToOuter]]
            lassign [applyHomography $H_modelToPs $modelOuterTopLeft] psX psY
            subst {
                gsave
                $psX [+ $psY $tagOuterLengthPs] translate
                $tagOuterLengthPs -$tagOuterLengthPs scale
                [::tagPsForId $id]
                grestore

                % Label the inner side length:
                [if {$tagIdx == 3} { subst {
                    gsave
                    [expr {$psX + ($tagOuterLengthPs - $tagSideLengthPs)/2}]
                    [expr {$psY - 15}] translate
                    1 -1 scale
                    0.1 0.67 0.1 setrgbcolor
                    newpath 0 0 moveto $tagSideLengthPs 0 lineto stroke
                    newpath 0 0 moveto 0 -5 lineto stroke
                    newpath $tagSideLengthPs 0 moveto $tagSideLengthPs -5 lineto stroke
                    /Helvetica findfont 7 scalefont setfont
                    newpath 0 5 moveto (inner side length) show
                    grestore
                } }]
            }
        }]] "\n"]
    }]

    # apply {{ps} {
    #     set fp [open "/tmp/cali-[clock milliseconds].ps" w]
    #     puts $fp $ps
    #     close $fp
    # }} $ps

    set fp [open [list |ps2pdf - - <<$ps] rb]
    set pdf [read $fp]; close $fp
    return $pdf
}

Wish the web server handles route "/calibrate$" with handler [list apply {{UNIT_MODEL ^makeCalibrationBoardPdf} {
    set calibrationBoardPdf [makeCalibrationBoardPdf $UNIT_MODEL 50 \
                                 {{id} {upvar ^isPrintedTag ^isPrintedTag; isPrintedTag $id}}]

    upvar ^html ^html
    html [csubst {
      <html>
        <head>
          <title>Folk: Calibrate</title>
          <style>body { max-width: 600px; }</style>
        </head>
      <body>

        <ol>
          <li>
            <p>Print this calibration board and glue/tape it to
            something solid and flat (hardcover book, solid cardboard,
            etc):</p>
            <iframe width="500px" height="300px" src="data:application/pdf;base64,$[binary encode base64 $calibrationBoardPdf]">
            </iframe>
        <p>Try to keep the board from bending or warping.
        (During calibration, Folk will want to project AprilTags in the
            central area of the board. Instead of printing, you can
            try just maximizing the board on your computer/tablet
            screen, but you'll need to cover the central
            area with a sticky note or something else that Folk can project
            tags on.)</p>
          </li>

          <li><p>On your calibration board, measure the <span style="color: rgb(10% 67% 10%)">inner side length</span> of a tag in millimeters and enter it here: <input id="tag-side-length-mm" type="text">mm</p> Try to be as accurate as possible, like to within half a millimeter or better -- the more accurate, the better your calibration will be.</li>

          <li><p>Once you start calibration, you'll need to <strong>move the board so
          that the projected AprilTags are in the center of the board</strong>,
          then <strong>hold the board still for a few seconds until
          the pose is recorded.</strong></p>
          <p>You'll need to record 10 different poses; try to slant the
          board and move it up and around the projector/camera area as much
            as possible.</p>
            <p>Start calibration: <button id="tag-side-length-submit">Start Calibration</button></p>
            <p>(If calibration gets into a bad state, feel free to click Start Calibration again.)</p>
        </li>

        <li><p>Finally, we'll correct any measurement offset between the camera and projector.</p>
        <p><button id="correct-extrinsics-submit">Start Offset Correction</button></p>
        <p>Leave your calibration board flat in the center of the table and don't move it.</p>
        </li>
        </ol>

      <script>
        function uuidv4() {
          return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
        }
        const self = uuidv4();

        document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
          const mm = document.getElementById("tag-side-length-mm").value;

          window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
          ws.onopen = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
              Assert \${self} claims the printed tag side length is \${mm} mm
              Assert \${self} wishes to calibrate
           `);
          };
          window.onbeforeunload = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
              Retract \${self} wishes to calibrate
            `);
          }
        });

        document.getElementById('correct-extrinsics-submit').addEventListener('click', (e) => {
          const mm = document.getElementById("tag-side-length-mm").value;

          window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
          ws.onopen = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
              Assert \${self} claims the printed tag side length is \${mm} mm
              Assert \${self} wishes to correct extrinsics
            `);
          };
          window.onbeforeunload = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
              Retract \${self} wishes to correct extrinsics
            `);
          }
        });
      </script>

      </body>
    </html>
  }]
}} $UNIT_MODEL ${^makeCalibrationBoardPdf}]

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     the printed tag side length is /printedSideLengthMm/ mm &\
     /someone/ wishes to calibrate {
    # Project projected tags once the printed side length has been
    # dialed in.

    # VERY IMPORTANT: disable autofocus forever.
    catch { exec v4l2-ctl --device=$camera --set-ctrl=focus_automatic_continuous=0 }

    if {$cameraWidth < 1920} {
        Retract /someone/ wishes $::thisNode uses camera $camera \
            with width $cameraWidth height $cameraHeight
        Assert $this wishes $::thisNode uses camera $camera with width 1920 height 1080
        # TODO: restore old camera resolution later
    }

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    # UNIT_MODEL's 2D coordinates have inner tag side length of 1.0:
    # scale it to real-world coordinates.
    set baseModel [dict map {id tag} $UNIT_MODEL {
        dict create c [scale $printedSideLengthM [dict get $tag c]] \
            p [scale $printedSideLengthM [dict get $tag p]]
    }]

    # A list of pose dictionaries. Each dictionary has entries `model`
    # and `H_modelToDisplay` ('prewarp' homography from model plane to
    # projector plane) and `tags` (tag ID => dictionary of tag
    # detection info from camera and AprilTag detector) and
    # `displayResolution` and `cameraResolution` and `tagSize`.
    set ::seenPoses [list]
    set SEEN_POSES_MAX 10

    # The poses to use for actual calibration at the end. We'll want
    # at least 10 poses to do ultimate calibration+refinement.
    set ::calibrationPoses [list]
    set CALIBRATION_POSES_MAX 10

    set ::cycleTime 0

    # Project calibration tags based on the current model-to-display
    # homography (which gets dynamically updated as you move the board
    # around):
    When the calibration model-to-display homography is /H_modelToDisplay/ with \
         model /model/ version /anything/ timestamp /anything/ {

        fn innerToOuter {center corner} {
            set r [sub $corner $center]
            return [add $center [scale [expr {sqrt(50)/sqrt(18)}] $r]]
        }

        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} { continue }

            set modelInnerCorners [lreverse [dict get $modelTag p]]
            set modelCenter [dict get $modelTag c]

            # {bottomleft bottomright topright topleft}
            set projectorOuterCorners [lmap modelInnerCorner $modelInnerCorners {
                applyHomography $H_modelToDisplay \
                    [innerToOuter $modelCenter $modelInnerCorner]
            }]
            Wish to draw an AprilTag with id $id corners $projectorOuterCorners layer 100
        }

        # White backdrop to hopefully make the projected tags pop out more:
        Wish to draw a quad with \
            p0 [list 0 0] p1 [list $displayWidth 0] \
            p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
            color white layer 99

        # Instructions for the user:
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        # FIXME: Last 2 points' angle is screwed up.
        set sides \
            [list \
                 [list $modelTopLeft $modelTopRight] \
                 [list $modelBottomRight $modelBottomLeft] \
                 [list $modelBottomLeft $modelTopLeft] \
                 [list $modelTopRight $modelBottomRight]]

        # HACK: imperatively checks ::calibrationPoses every
        # frame.
        set text "[llength $::calibrationPoses]/$CALIBRATION_POSES_MAX poses ([expr {round($::cycleTime*1000)}] ms)"
        foreach side $sides {
            lassign $side start end
            set segment [sub $end $start]
            set normal [unitLengthVector [list [- [lindex $segment 1]] [lindex $segment 0]]]
            set modelPosition [add [scale 0.5 [add $start $end]] \
                                   [scale [* -1.0 $printedSideLengthM] $normal]]

            set dispSeg [sub [applyHomography $H_modelToDisplay $end] \
                             [applyHomography $H_modelToDisplay $start]]
            set radians [- [atan2 [lindex $dispSeg 1] [lindex $dispSeg 0]]]

            Wish to draw text with text $text radians $radians \
                position [applyHomography $H_modelToDisplay $modelPosition] \
                anchor center color black layer 100 scale 2.0
        }
    }

    When /nobody/ claims the calibration model-to-display homography is /anything/ with \
                         model /anything/ version /anything/ timestamp /anything/ {
        # Default model: just makes the tags fill most of the middle
        # of the projector area.
        set tagSideLengthPixels [expr {int(min($displayWidth/($COLS * ($tagOuterLength + $pad)),
                                               $displayHeight/($ROWS * ($tagOuterLength + $pad))))}]

        set H_modelToDisplay [estimateHomography [subst {
            {$printedSideLengthM $printedSideLengthM $tagSideLengthPixels $tagSideLengthPixels}
            {$printedSideLengthM 0 $tagSideLengthPixels 0}
            {0 $printedSideLengthM 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Commit H_modelToDisplay {
            # Default model and version: nothing rotated.
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $baseModel version -1 timestamp [expr {[clock milliseconds] / 1000.0}]
        }
    }
    On unmatch { Commit H_modelToDisplay {} }

    When main-detector detects tags /tags/ on $camera at /timestamp/ in time /something/ & \
         the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /version/ timestamp /hTimestamp/ {

        # This runs every frame, looks at the detected tags (both
        # projected and printed), and updates the H_modelToDisplay
        # such that the projected tags should sit in the middle of the
        # calibration board.

        set startTime [clock microseconds]

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $printedTag p] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        set printedCalibrationBoard [list {*}[applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomLeft]]
        set boardMinX 100000; set boardMinY 100000
        set boardMaxX -100000; set boardMaxY -100000
        foreach {cornerX cornerY} $printedCalibrationBoard {
            if {$cornerX < $boardMinX} { set boardMinX $cornerX }
            if {$cornerY < $boardMinY} { set boardMinY $cornerY }
            if {$cornerX > $boardMaxX} { set boardMaxX $cornerX }
            if {$cornerY > $boardMaxY} { set boardMaxY $cornerY }
        }

        # We only count projected tags that are inside the board.
        set projectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }

            lassign [dict get $tag c] x y
            if {$x > $boardMinX && $x < $boardMaxX &&
                $y > $boardMinY && $y < $boardMaxY} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # Check the rotation of a version tag to figure out the
        # version of what the camera saw, unless it's version -1.
        if {$version != -1} {
            # Find any version tag. If none were detected, then abort
            # and wait until a later frame.
            dict for {id tag} $projectedTags {
                if {[isProjectedTag $id] && $id % 2 == 1} {
                    set versionTagId $id
                    break
                }
            }
            if {![info exists versionTagId]} { return }

            set getTagAngle {{tag} {
                set p [dict get $tag p]
                expr {atan2(-1 * ([lindex $p 1 1] - [lindex $p 0 1]),
                            [lindex $p 1 0] - [lindex $p 0 0])}
            }}
            set versionTagAngle [apply $getTagAngle [dict get $projectedTags $versionTagId]]
            # Compare angle to angle of any other projected tag.
            if {[dict size $projectedTags] < 2} { return }
            set otherTagAngle [apply $getTagAngle [lindex [dict values [dict remove $projectedTags $versionTagId]] 0]]
            set versionAngle [expr {$versionTagAngle - $otherTagAngle}]
            # Rotations corresponding to versions 0, 1, 2, 3:
            set possibleVersions \
                [list 1  0 \
                      0  1 \
                     -1  0 \
                      0 -1]
            # Which of the possibleVersions is versionAngle closest to?
            set detectedVersion [lindex [lsort -indices [lmap {x y} $possibleVersions {
                expr {sqrt(($x - cos($versionAngle))**2 + ($y - sin($versionAngle))**2)}
            }]] 0]

            # If the detected version does not correspond to version mod 4,
            # then we should abort and wait until a later frame.
            if {$detectedVersion != [expr {$version % 4}]} { return }
        }

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $projectedTag p] {
                    set displayCorner [applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }

        # puts "point pairs (camera -> display): {$projectedPointPairs}"
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]
        if {[abs [det $H_cameraToDisplay]] < 0.001} {
            # Garbage homography that just shrinks the points way down
            # (https://stackoverflow.com/questions/10972438/detecting-garbage-homographies-from-findhomography-in-opencv).
            # It's sort of 'overfitted' and just has a big y-intercept
            # and will break everything if we let it through. Skip.
            return
        }

        # Update H_modelToDisplay to project the tags into the middle
        # of the board next frame.
        set nextH_modelToDisplay [matdMul $H_cameraToDisplay $H_modelToCameraViaPs]
        Commit H_modelToDisplay {
            set nextVersion [+ $version 1]
            set nextModel [versionizeTags $baseModel $nextVersion]
            set nextTimestamp [expr {[clock milliseconds] / 1000.0}]
            Claim the calibration model-to-display homography is $nextH_modelToDisplay with \
                model $nextModel version $nextVersion timestamp $nextTimestamp
            set ::cycleTime [- $nextTimestamp $hTimestamp]
        }

        # Should we record the points we just saw as a calibration
        # pose?

        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }

        # TODO: Compute a pose homography from current?????  Take into
        # account delta from last camera tags? Use that homography on
        # the projector????

        set pose [dict create \
                      model $model version $version \
                      camera $camera \
                      cameraWidth $cameraWidth cameraHeight $cameraHeight \
                      display $display \
                      displayWidth $displayWidth displayHeight $displayHeight \
                      tagSize $printedSideLengthM \
                      H_modelToDisplay $H_modelToDisplay \
                      tags [dict merge $printedTags $projectedTags]]

        lappend ::seenPoses $pose
        if {[llength $::seenPoses] > $SEEN_POSES_MAX} {
            set ::seenPoses [lreplace $::seenPoses 0 0]
        }

        # Next, we check if projected tag corners have been pretty
        # stable in the last few frames.

        if {[llength $::seenPoses] < 3} {
            return
        }

        # If the corners have moved a lot since last frame, we're not
        # stable enough and shouldn't record this as a calibration
        # pose.
        if {[meanPoseDifference $pose [lindex $::seenPoses end-1]] > 5 ||
            [meanPoseDifference $pose [lindex $::seenPoses end-2]] > 5} {
            return
        }
        # Decreasing this threshold to 1 helps with data
        # accuracy. TODO: Use an _older_ frame?
        puts "WOULD APPEND CALIBRATION ([- [clock microseconds] $startTime] us)..."

        # If the corners have _not_ moved a lot since last _saved_
        # calibration pose, this isn't different enough to be a good
        # calibration pose to save.
        if {[llength $::calibrationPoses] > 0} {
            set prevCalibrationPose [lindex $::calibrationPoses end]
            if {[meanPoseDifference $pose $prevCalibrationPose] < 50} {
                return
            }
        }

        # Save the pose / camera image to a jpeg (for debugging purposes)
        exec mkdir -p "$::env(HOME)/folk-calibration-poses"
        image saveAsJpeg [dict get [lindex [Statements::findMatches [list /someone/ claims camera /any/ has frame /frame/ at timestamp /any/]] 0] frame] \
            "$::env(HOME)/folk-calibration-poses/pose-[clock milliseconds]-[llength $::calibrationPoses].jpeg"
        # apply {{calibrationBoardPdf} {
        #     set fd [open "$::env(HOME)/folk-calibration-poses/pose-[clock milliseconds]-[llength $::calibrationPoses]-model.pdf" w]
        #     puts $fd $calibrationBoardPdf; close $fd
        # }} [makeCalibrationBoardPdf \
        #         [dict map {id tag} $model {
        #             dict create c [scale [/ 1.0 $printedSideLengthM] [dict get $tag c]] \
        #                 p [scale [/ 1.0 $printedSideLengthM] [dict get $tag p]]
        #         }] 50 {{id} {return true}}]

        # OK, let's save this calibration pose.
        lappend ::calibrationPoses $pose
        puts "APPENDED CALIBRATION TO POSES ([llength $::calibrationPoses] poses collected)"

        # If we have enough poses, then stop the calibration process
        # (retract the printed side length?) and do a calibration. :-)
        if {[llength $::calibrationPoses] >= $CALIBRATION_POSES_MAX} {
            puts "READY CALIBARTION POSES!"

            catch { exec mkdir "$::env(HOME)/folk-live" }
            catch {exec rm "$::env(HOME)/folk-live/folk-calibration-output.txt"}

            set fd [open "$::env(HOME)/folk-live/folk-calibration-poses.txt" w]
            puts $fd $::calibrationPoses; close $fd

            Commit calibration {
                Claim the calibration poses are $::calibrationPoses
            }
            Retract /someone/ wishes to calibrate
        }
    }
}

fn processHomography {H} {
    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}


# Uses Zhang's calibration technique
# (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)
# to calibrate a projector or camera given a known 2D planar pattern
# and multiple observed poses.
#
# Returns intrinsic matrix for the camera/projector, which explains
# how 3D real-world coordinates get projected to 2D coordinates by
# that device. (The intrinsic matrix can be used with an AprilTag
# detector to get real-world coordinates for each AprilTag.)
#
# Arguments:
#         width  width of camera or projector in pixels
#         height height of camera or projector in pixels
#         Hs     a list of N homographies from camera/projector image
#                plane -> model plane (for N different poses).
fn zhangUnrefinedCalibrate {name width height Hs} {
    # Try to solve for the camera intrinsics:

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[::math::linearalgebra::shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V
    set b [lindex [transpose $V] [lindex [lsort -real -indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }

    set fx $alpha; set fy $beta
    set cx $u0; set cy $v0
    set s $gamma
    puts "   Focal Length: \[ $fx $fy ]"
    puts "Principal Point: \[ $cx $cy ]"
    puts "           Skew: \[ $s ] "

    # Intrinsic matrix:
    set A [subst {
        {$fx  $s   $cx}
        {0    $fy  $cy}
        {0    0    1}
    }]
    set Ainv [solvePGauss $A [mkIdentity 3]]

    set extrinsics [lmap H $Hs {
        set h1 [getcol $H 0]
        set h2 [getcol $H 1]
        set h3 [getcol $H 2]
        set lambda [/ 1.0 [norm [matmul $Ainv $h1]]]

        set r1 [scale $lambda [matmul $Ainv $h1]]
        set r2 [scale $lambda [matmul $Ainv $h2]]
        set r3 [crossproduct $r1 $r2]
        set R [transpose [list $r1 $r2 $r3]]

        set t [scale $lambda [matmul $Ainv $h3]]

        # Refine R into a better rotation matrix (reorthogonalize)
        # using SVD.
        lassign [determineSVD $R] U S V
        set R [matmul $U [transpose $V]]

        dict create R $R t $t
    }]

    # Initialize distortion terms k1 and k2 to 0 -- they get figured
    # out during nonlinear refinement.
    set intrinsics [dict create \
                        width $width height $height \
                        fx $fx fy $fy cx $cx cy $cy s $s \
                        k1 0 k2 0]
    return [dict create \
                name $name \
                intrinsics $intrinsics \
                extrinsics $extrinsics]
}

proc setCameraToProjectorExtrinsics {calibrationVar calibrationPoses} {
    upvar ^isProjectedTag ^isProjectedTag

    # Use the "Kabsch algorithm" (https://nghiaho.com/?page_id=671;
    # https://zpl.fi/aligning-point-patterns-with-kabsch-umeyama-algorithm/)
    # to find the rotation and translation from 3D camera-space to 3D
    # projector-space.

    upvar $calibrationVar calibration

    # Let's take all the points for which we have a corresponding
    # camera frame point and projector frame point.
    set cameraFramePoints [list]
    set projectorFramePoints [list]

    for {set i 0} {$i < [llength $calibrationPoses]} {incr i} {
        set calibrationPose [lindex $calibrationPoses $i]
        
        set Rc [dict get [lindex [dict get $calibration camera extrinsics] $i] R]
        set tc [dict get [lindex [dict get $calibration camera extrinsics] $i] t]

        set Rp [dict get [lindex [dict get $calibration projector extrinsics] $i] R]
        set tp [dict get [lindex [dict get $calibration projector extrinsics] $i] t]

        # TODO: Try using pose estimation instead?
        dict for {id tag} [dict get $calibrationPose model] {
            if {![isProjectedTag $id]} { continue }
            set k 0
            foreach v [dict get $tag p] {
                incr k
                lappend v 0.0

                set vc [add [matmul $Rc $v] $tc]
                set vp [add [matmul $Rp $v] $tp]

                lappend cameraFramePoints $vc
                lappend projectorFramePoints $vp
            }
        }
    }

    # puts "cameraFramePoints = \[[join [lmap p $cameraFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"
    # puts "projectorFramePoints = \[[join [lmap p $projectorFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"
    set ::cfp $cameraFramePoints
    set ::pfp $projectorFramePoints

    set n [llength $cameraFramePoints]

    set vcsum {0 0 0}
    foreach vc $cameraFramePoints { set vcsum [add $vcsum $vc] }
    set cameraFramePointsCentroid [scale [/ 1.0 $n] $vcsum]

    set vpsum {0 0 0}
    foreach vp $projectorFramePoints { set vpsum [add $vpsum $vp] }
    set projectorFramePointsCentroid [scale [/ 1.0 $n] $vpsum]

    set H [matmul [transpose [sub $cameraFramePoints \
                                  [lrepeat $n $cameraFramePointsCentroid]]] \
               [sub $projectorFramePoints \
                    [lrepeat $n $projectorFramePointsCentroid]]]

    lassign [determineSVD $H] U S V
    set R [matmul $V [transpose $U]]
    set t [sub $projectorFramePointsCentroid \
               [matmul $R $cameraFramePointsCentroid]]

    dict set calibration R_cameraToProjector $R
    dict set calibration t_cameraToProjector $t
}

# End-to-end calibrates a camera-projector pair. calibrationPoses is
# a list of N pose dictionaries. Each pose dictionary includes `tags`
# from a camera detection, `model` with coordinates in meters,
# `H_modelToDisplay`.
fn unrefinedCalibrateCameraAndProjector {calibrationPoses} {
    # Just used to get metadata about cam/proj:
    set pose0 [lindex $calibrationPoses 0]

    # First, calibrate the camera. "Using only the corners from
    # printed markers xb and their detected corners xc, [...]
    # calibrate the camera with no difficulties using Zhang’s method."
    set i 0
    set Hs_modelToCamera [lmap pose $calibrationPoses {
        # Pairs of (camera coordinates, model coordinates).
        set model [dict get $pose model]
        set tags [dict get $pose tags]
        set pointPairs [list]
        dict for {id cameraTag} $tags {
            if {![isPrintedTag $id]} continue
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $cameraTag p] {
                    lappend pointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }

        set H [estimateHomography $pointPairs]
        if {[det $H] < 0} {
            set H [scale -1 $H]
        }
        set H
    }]
    puts "Zhang calibrate camera:"
    puts "========"
    set cameraName [dict get $pose0 camera]
    set cameraWidth [dict get $pose0 cameraWidth]
    set cameraHeight [dict get $pose0 cameraHeight]
    set cameraCalibration [zhangUnrefinedCalibrate \
                               $cameraName $cameraWidth $cameraHeight \
                               $Hs_modelToCamera]
    puts "\n======================\n"

    # Second, calibrate the projector.
    set modelToDisplayPointPairSets [list]
    set i 0
    set Hs_modelToDisplay [lmap pose $calibrationPoses {
        set H_modelToDisplay [dict get $pose H_modelToDisplay]

        set pointPairs [list]
        set model [dict get $pose model]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} continue
            foreach modelCorner [dict get $modelTag p] {
                set displayCorner [applyHomography $H_modelToDisplay $modelCorner]
                lappend pointPairs [list {*}$modelCorner {*}$displayCorner]
            }
        }

        if {[det $H_modelToDisplay] < 0} {
            set H_modelToDisplay [scale -1 $H_modelToDisplay]
        }
        set H_modelToDisplay
    }]
    puts "Zhang calibrate projector:"
    puts "========"
    set projectorName [dict get $pose0 display]
    set projectorWidth [dict get $pose0 displayWidth]
    set projectorHeight [dict get $pose0 displayHeight]
    set projectorCalibration [zhangUnrefinedCalibrate \
                                  $projectorName \
                                  $projectorWidth $projectorHeight \
                                  $Hs_modelToDisplay]
    puts "\n======================\n"

    set calibration [dict create \
                         camera $cameraCalibration \
                         projector $projectorCalibration]
    setCameraToProjectorExtrinsics calibration $calibrationPoses
    return $calibration
}
try {
    set fd [open "$::env(HOME)/folk-live/folk-calibration-poses.txt" r]
    set calibrationPoses [read $fd]; close $fd

    if {[file exists "$::env(HOME)/folk-live/folk-calibration-output.txt"]} {
        set fd [open "$::env(HOME)/folk-live/folk-calibration-output.txt" r]
        set calibration [read $fd]; close $fd
        puts "READING CALIB"
        Commit calibration {
            Claim the calibration poses are $calibrationPoses
            Claim the calibration is $calibration
        }
    } else {
        puts "NO CALIBRATION, JUST CALIB POSES"
        Commit calibration {
            Claim the calibration poses are $calibrationPoses
        }
    }

} on error e {
    puts stderr "Failed to load calibration poses: $e"
}

When the calibration poses are /calibrationPoses/ &\
     /nobody/ claims the calibration is /anything/ &\
     the calibration refiner is /refineCalibration/ {

    set calibration [unrefinedCalibrateCameraAndProjector $calibrationPoses]
    puts "======== Unrefined calibration ========="
    puts $calibration
    puts ""

    set calibration [apply $refineCalibration \
                         $calibrationPoses $calibration]
    puts "======== Refined calibration ========="
    puts $calibration
    puts ""

    Commit calibration { Claim the calibration is $calibration }

    set fd [open "$::env(HOME)/folk-live/folk-calibration-output.txt" w]
    puts $fd $calibration; close $fd
}

When the calibration is /calibration/ {
    puts "\n\n====NEW CALIBRATION=====\n\n"
    set camera [dict get $calibration camera name]
    set display [dict get $calibration projector name]
    Claim camera $camera has intrinsics \
        [dict get $calibration camera intrinsics]
    Claim display $display has intrinsics \
        [dict get $calibration projector intrinsics]

    set extrinsics [dict create \
                        R [dict get $calibration R_cameraToProjector] \
                        t [dict get $calibration t_cameraToProjector]]
    Claim camera $camera to display $display has extrinsics $extrinsics
}

# HACK: for fast testing
# Claim the printed tag side length is 17.5 mm
