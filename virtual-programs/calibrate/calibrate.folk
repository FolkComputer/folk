# calibrate.folk --
#
#     Implements camera-projector calibration: generate a calibration
#     pattern PDF, have the user measure its real-world dimension, run
#     iterative projector-camera process to get various poses of the
#     printed tags alongside projected tags, do linear fit and then
#     nonlinear refinement to find intrinsic and extrinsic parameters
#     for the camera and projector.
#

package require math::linearalgebra
# rename ::scale scaleTk
foreach p {add norm sub scale leastSquaresSVD matmul
    getelem transpose determineSVD shape mkIdentity
    solvePGauss crossproduct getcol setcol unitLengthVector
} {
    namespace import ::math::linearalgebra::$p
}

package require math::geometry
namespace import ::math::geometry::pointInsidePolygon

set ROWS 4
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `c` and `p` which are
# model points (x, y). The tags on the outer perimeter will get
# projected to PostScript points and printed; the tags in the
# interior will get projected to Vulkan points and rendered on
# projector.
set MODEL [apply {{ROWS COLS} {
    set MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              c [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              p [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set MODEL $id $modelTag
        }
    }
    return $MODEL
}} $ROWS $COLS]
Claim the calibration model is $MODEL

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    # We print tags on the outer perimeter of the grid, and we project
    # tags in the interior.
    set idx [- $id 48600]
    set row [expr {$idx / $COLS}]
    set col [expr {$idx % $COLS}]
    return [expr {$row == 0 || $row == $ROWS - 1 ||
                  $col == 0 || $col == $COLS - 1}]
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    ! [isPrintedTag $id]
}

# Takes a list of at least 4 point pairs (model -> image) like
#
# [list \
#   [list x0 y0 u0 v0]] \
#   [list x1 y1 u1 v1] \
#   [list x2 y2 u2 v2] \
#   [list x3 y3 u3 v3]]
#
# Returns a 3x3 homography that maps model (x, y) to image (u, v)
# (using homogeneous coordinates).
# HACK: to share with test
set ::estimateHomography {{pointPairs} {
    set A [list]
    set b [list]
    foreach pair $pointPairs {
        lassign $pair x y u v
        lappend A [list $x $y 1 0  0  0 [expr {-$x*$u}] [expr {-$y*$u}]]
        lappend A [list 0  0  0 $x $y 1 [expr {-$x*$v}] [expr {-$y*$v}]]
        lappend b $u $v
    }

    lassign [leastSquaresSVD $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]
    return $H
}}
fn estimateHomography {pointPairs} {
    apply $::estimateHomography $pointPairs
}
fn applyHomography {H xy} {
    lassign [matmul $H [list {*}$xy 1]] u v w
    return [list [/ $u $w] [/ $v $w]]
}

# Takes a dictionary of tag ID => {p, c} and rotates version tags
# according to version.
fn versionizeTags {tags version} {
    foreach id [dict keys $tags] {
        if {!([isProjectedTag $id] && $id % 2 == 1)} {
            continue
        }
        # This is a version tag. Rotate it.
        set p [dict get $tags $id p]
        set rotatedCorners [list]
        for {set i 0} {$i < 4} {incr i} {
            lappend rotatedCorners [lindex $p [expr {($i + $version) % 4}]]
        }
        dict set tags $id p $rotatedCorners
    }
    return $tags
}

package require math
namespace import ::math::mean
fn meanPoseDifference {pose1 pose2} {
    # First, remove the version rotations from tags1 and tags2.
    set tags1 [dict get $pose1 tags]
    set version1 [dict get $pose1 version]
    set tags1 [versionizeTags $tags1 [- $version1]]

    set tags2 [dict get $pose2 tags]
    set version2 [dict get $pose2 version]
    set tags2 [versionizeTags $tags2 [- $version2]]

    set differences [list]
    dict for {id tag} $tags1 {
        if {![dict exists $tags2 $id]} { continue }
        set corners1 [dict get $tag p]
        set corners2 [dict get $tags2 $id p]
        set cornerDifferences \
            [lmap corner1 $corners1 corner2 $corners2 {
                norm [sub $corner1 $corner2]
            }]
        lappend differences {*}$cornerDifferences
    }
    if {[llength $differences] == 0} { return Inf }
    return [mean {*}$differences]
}

Wish the web server handles route "/calibrate$" with handler [list apply {{MODEL ^isPrintedTag ^estimateHomography ^applyHomography} {
    set calibrationBoardPs [apply {{MODEL ^isPrintedTag ^estimateHomography ^applyHomography} {
        set marginTop 72; set marginLeft 36
        set PageWidth 612; set PageHeight 792

        set innerToOuter 0.333333

        set tagSideLengthPs 50
        set tagOuterLengthPs [expr {$tagSideLengthPs * 10/6}]

        set H_modelToPs [estimateHomography [subst {
            {1 1 $tagSideLengthPs $tagSideLengthPs}
            {1 0 $tagSideLengthPs 0}
            {0 1 0 $tagSideLengthPs}
            {0 0 0 0}
        }]]

        subst {
            %!PS
            << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

            % (0, 0) is bottom-left of portrait page right now.
            90 rotate 1 -1 scale
            % Now (0, 0) is top-left of landscape page.

            gsave
            $marginLeft [- $marginTop 18] translate
            1 -1 scale
            0 setgray /Helvetica findfont 14 scalefont setfont
            newpath 0 0 moveto (Folk calibration board) show
            grestore

            $marginLeft $marginTop translate

            [set tagIdx -1]
            [join [dict values [dict map {id modelTag} $MODEL {
                if {![isPrintedTag $id]} { continue }
                incr tagIdx

                set modelInnerTopLeft [lindex [dict get $modelTag p] 3]
                set modelOuterTopLeft [add $modelInnerTopLeft [list -$innerToOuter -$innerToOuter]]
                lassign [applyHomography $H_modelToPs $modelOuterTopLeft] psX psY
                subst {
                    gsave
                    $psX [+ $psY $tagOuterLengthPs] translate
                    $tagOuterLengthPs -$tagOuterLengthPs scale
                    [::tagPsForId $id]
                    grestore

                    % Label the inner side length:
                    [if {$tagIdx == 3} { subst {
                        gsave
                        [expr {$psX + ($tagOuterLengthPs - $tagSideLengthPs)/2}]
                        [expr {$psY - 15}] translate
                        1 -1 scale
                        0.1 0.67 0.1 setrgbcolor
                        newpath 0 0 moveto $tagSideLengthPs 0 lineto stroke
                        newpath 0 0 moveto 0 -5 lineto stroke
                        newpath $tagSideLengthPs 0 moveto $tagSideLengthPs -5 lineto stroke
                        /Helvetica findfont 7 scalefont setfont
                        newpath 0 5 moveto (inner side length) show
                        grestore
                    } }]
                }
            }]] "\n"]
        }
    }} $MODEL ${^isPrintedTag} ${^estimateHomography} ${^applyHomography}]

    set fp [open [list |ps2pdf - - <<$calibrationBoardPs] rb]
    set calibrationBoardPdf [read $fp]; close $fp

    upvar ^html ^html
    html [csubst {
      <html>
      <head><title>Folk: Calibrate</title></head>
      <body>

      <iframe width="500px" height="300px" src="data:application/pdf;base64,$[binary encode base64 $calibrationBoardPdf]">
      </iframe>

      <p>
        Print the above board, then measure the <span style="color: rgb(10% 67% 10%)">inner side length</span> of a tag in millimeters,
        <br>enter it here, and click Begin Calibration:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Begin Calibration</button>
      </p>

      <script>
        function uuidv4() {
          return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
        }
        const self = uuidv4();

        document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
          // Report the side length to a statement in Folk.

          const mm = document.getElementById("tag-side-length-mm").value;

          window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
          ws.onopen = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
              Assert \${self} claims the printed tag side length is \${mm} mm
           `);
          };
          window.onbeforeunload = () => {
            ws.send(`
              Retract \${self} claims the printed tag side length is /anything/ mm
            `);
          }
        });
      </script>

      </body>
    </html>
  }]
}} $MODEL ${^isPrintedTag} ${^estimateHomography} ${^applyHomography}]

Wish the GPU compiles pipeline "apriltag" {
    {uvec4 tagBitsVec vec2 a vec2 b vec2 c vec2 d} {
        vec2 vertices[4] = vec2[4](a, b, d, c);
        return vertices[gl_VertexIndex];
    } {fn ::invBilinear} {
        vec2 p = gl_FragCoord.xy;
        vec2 uv = invBilinear(p, a, b, c, d);

        int x = int(uv.x * 10); int y = int(uv.y * 10);
        int bitIdx = y * 10 + x;
        uint bit = (tagBitsVec[bitIdx / 32] >> (bitIdx % 32)) & 0x1;
        return bit == 1 ? vec4(1, 1, 1, 1) : vec4(0, 0, 0, 1);
    }
}
When the display Display has width /displayWidth/ height /displayHeight/ &\
     the printed tag side length is /printedSideLengthMm/ mm {
    # Project projected tags once the printed side length has been
    # dialed in.

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    # MODEL's 2D coordinates have inner tag side length of 1.0: scale
    # it to real-world coordinates.
    set baseModel [dict map {id tag} $MODEL {
        dict create c [scale $printedSideLengthM [dict get $tag c]] \
            p [scale $printedSideLengthM [dict get $tag p]]
    }]

    # A list of dictionaries. Each dictionary has entries `model` and
    # `H_modelToDisplay` ('prewarp' homography from model plane to
    # projector plane) and `tags` (tag ID => dictionary of tag
    # detection info from camera and AprilTag detector) and
    # `displayResolution` and `cameraResolution`.
    #
    # We'll want at least 10 poses to do ultimate
    # calibration+refinement.
    set ::calibrationPoses [list]
    set CALIBRATION_POSES_MAX 10

    # Project calibration tags based on the current model-to-display
    # homography (which gets dynamically updated as you move the board
    # around):
    When the calibration model-to-display homography is /H_modelToDisplay/ with \
         model /model/ version /anything/ timestamp /anything/ {

        fn innerToOuter {center corner} {
            set r [sub $corner $center]
            return [add $center [scale [expr {sqrt(50)/sqrt(18)}] $r]]
        }

        # These are computed so we can draw user instructions around
        # the outer perimeter of the projected tags.
        set minX 10000; set minY 10000; set maxX 0; set maxY 0

        set instances [list]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} { continue }

            set tagImage [::tagImageForId $id]
            set tagBits [list]
            # 10x10 AprilTag -> 100 bits
            for {set y 0} {$y < 10} {incr y} {
                for {set x 0} {$x < 10} {incr x} {
                    set j [expr {$y * [image_t bytesPerRow $tagImage] + $x}]
                    set bit [== [image_t data $tagImage $j] 255]
                    lappend tagBits $bit
                }
            }
            # -> 4 32-bit integers
            set tagBitsVec [list 0b[join [lreverse [lrange $tagBits 0 31]] ""] \
                                0b[join [lreverse [lrange $tagBits 32 63]] ""] \
                                0b[join [lreverse [lrange $tagBits 64 95]] ""] \
                                0b[join [lreverse [lrange $tagBits 96 127]] ""]]

            set modelInnerCorners [lreverse [dict get $modelTag p]]
            set modelCenter [dict get $modelTag c]

            # {bottomleft bottomright topright topleft}
            set projectorOuterCorners [lmap modelInnerCorner $modelInnerCorners {
                applyHomography $H_modelToDisplay \
                             [innerToOuter $modelCenter $modelInnerCorner]
            }]
            lappend instances [list $tagBitsVec {*}$projectorOuterCorners]
        }

        # White backdrop to hopefully make the projected tags pop out more:
        Wish to draw a quad with \
            p0 [list 0 0] p1 [list $displayWidth 0] \
            p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
            color white layer 99

        Wish the GPU draws pipeline "apriltag" with instances $instances layer 100

        # Instructions for the user:
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        # FIXME: Last 2 points' angle is screwed up.
        set sides \
            [list \
                 [list $modelTopLeft $modelTopRight] \
                 [list $modelBottomRight $modelBottomLeft] \
                 [list $modelBottomLeft $modelTopLeft] \
                 [list $modelTopRight $modelBottomRight]]
        When the clock time is /t/ {
            # HACK: imperatively checks ::calibrationPoses every
            # frame.
            set text "[llength $::calibrationPoses]/$CALIBRATION_POSES_MAX poses"
            foreach side $sides {
                lassign $side start end
                set segment [sub $end $start]
                set normal [unitLengthVector [list [- [lindex $segment 1]] [lindex $segment 0]]]
                set modelPosition [add [scale 0.5 [add $start $end]] \
                                       [scale [* -1.0 $printedSideLengthM] $normal]]

                set dispSeg [sub [applyHomography $H_modelToDisplay $end] \
                                 [applyHomography $H_modelToDisplay $start]]
                set radians [- [atan2 [lindex $dispSeg 1] [lindex $dispSeg 0]]]

                Wish to draw text with text $text radians $radians \
                    position [applyHomography $H_modelToDisplay $modelPosition] \
                    anchor center color black layer 100 scale 2.0
            }
        }
    }

    When /nobody/ claims the calibration model-to-display homography is /anything/ with \
                         model /anything/ version /anything/ timestamp /anything/ {
        # Default model: just makes the tags fill most of the middle
        # of the projector area.
        set tagSideLengthPixels [expr {int(min($displayWidth/($COLS * ($tagOuterLength + $pad)),
                                               $displayHeight/($ROWS * ($tagOuterLength + $pad))))}]

        set H_modelToDisplay [estimateHomography [subst {
            {$printedSideLengthM $printedSideLengthM $tagSideLengthPixels $tagSideLengthPixels}
            {$printedSideLengthM 0 $tagSideLengthPixels 0}
            {0 $printedSideLengthM 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Commit H_modelToDisplay {
            # Default model and version: nothing rotated.
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $baseModel version -1 timestamp [clock milliseconds]
        }
    }
    On unmatch { Commit H_modelToDisplay {} }

    When /someone/ detects tags /tags/ at /timestamp/ in time /something/ & \
         the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /version/ timestamp /hTimestamp/ {

        # This runs every frame, looks at the detected tags (both
        # projected and printed), and updates the H_modelToDisplay
        # such that the projected tags should sit in the middle of the
        # calibration board.

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $printedTag p] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        set printedCalibrationBoard [list {*}[applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[applyHomography $H_modelToCameraViaPs $modelBottomLeft]]

        # We only count projected tags that are inside the board.
        set projectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }
            if {[pointInsidePolygon [dict get $tag c] $printedCalibrationBoard]} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # Check the rotation of a version tag to figure out the
        # version of what the camera saw, unless it's version -1.
        if {$version != -1} {
            # Find any version tag. If none were detected, then abort
            # and wait until a later frame.
            dict for {id tag} $projectedTags {
                if {[isProjectedTag $id] && $id % 2 == 1} {
                    set versionTagId $id
                    break
                }
            }
            if {![info exists versionTagId]} { return }

            set getTagAngle {{tag} {
                set p [dict get $tag p]
                expr {atan2(-1 * ([lindex $p 1 1] - [lindex $p 0 1]),
                            [lindex $p 1 0] - [lindex $p 0 0])}
            }}
            set versionTagAngle [apply $getTagAngle [dict get $projectedTags $versionTagId]]
            # Compare angle to angle of any other projected tag.
            if {[dict size $projectedTags] < 2} { return }
            set otherTagAngle [apply $getTagAngle [lindex [dict values [dict remove $projectedTags $versionTagId]] 0]]
            set versionAngle [expr {$versionTagAngle - $otherTagAngle}]
            # Rotations corresponding to versions 0, 1, 2, 3:
            set possibleVersions \
                [list 1  0 \
                      0  1 \
                     -1  0 \
                      0 -1]
            # Which of the possibleVersions is versionAngle closest to?
            set detectedVersion [lindex [lsort -indices [lmap {x y} $possibleVersions {
                expr {sqrt(($x - cos($versionAngle))**2 + ($y - sin($versionAngle))**2)}
            }]] 0]

            # If the detected version does not correspond to version mod 4,
            # then we should abort and wait until a later frame.
            if {$detectedVersion != [expr {$version % 4}]} { return }
        }

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $projectedTag p] {
                    set displayCorner [applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }
        # puts "point pairs (camera -> display): {$projectedPointPairs}"
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]
        if {[abs [::math::linearalgebra::det $H_cameraToDisplay]] < 0.001} {
            # Garbage homography that just shrinks the points way down
            # (https://stackoverflow.com/questions/10972438/detecting-garbage-homographies-from-findhomography-in-opencv).
            # It's sort of 'overfitted' and just has a big y-intercept
            # and will break everything if we let it through. Skip.
            return
        }

        # Update H_modelToDisplay to project the tags into the middle
        # of the board next frame.
        set H_modelToDisplay [matmul $H_cameraToDisplay $H_modelToCameraViaPs]
        Commit H_modelToDisplay {
            set nextVersion [+ $version 1]
            set nextModel [versionizeTags $baseModel $nextVersion]
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $nextModel version $nextVersion timestamp [clock milliseconds]
        }

        # Should we record the points we just saw as a calibration
        # pose?

        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }

        set pose [dict create \
                      model $model \
                      version $version \
                      H_cameraToDisplay $H_cameraToDisplay \
                      H_modelToDisplay $H_modelToDisplay \
                      tags [dict merge $printedTags $projectedTags]]

        # Next, we check if projected tag corners have been pretty
        # stable since the previous frame.
        if {[info exists ::prevPose]} {
            set prevPose $::prevPose
            set ::prevPose $pose
        } else {
            # We haven't seen a previous frame yet. We'll try again
            # next frame.
            set ::prevPose $pose
            return
        }

        # If the corners have moved a lot since last frame, we're not
        # stable enough and shouldn't record this as a calibration
        # pose.
        if {[meanPoseDifference $pose $prevPose] > 5} { return }
        # Decreasing this threshold to 1 helps with data
        # accuracy. TODO: Use an _older_ frame?
        puts "WOULD APPEND CALIBRATION..."

        # If the corners have _not_ moved a lot since last _saved_
        # calibration pose, this isn't different enough to be a good
        # calibration pose to save.
        if {[llength $::calibrationPoses] > 0} {
            set prevCalibrationPose [lindex $::calibrationPoses end]
            if {[meanPoseDifference $pose $prevCalibrationPose] < 50} {
                return
            }
        }

        # Save the pose / camera image to a jpeg (for debugging purposes)
        catch { exec mkdir "$::env(HOME)/folk-calibration-poses" }
        image saveAsJpeg [dict get [lindex [Statements::findMatches [list /someone/ claims camera /any/ has frame /frame/ at /any/]] 0] frame] \
            "$::env(HOME)/folk-calibration-poses/pose-[clock milliseconds]-[llength $::calibrationPoses].jpeg"

        # OK, let's save this calibration pose.
        lappend ::calibrationPoses $pose
        puts "APPENDED CALIBRATION TO POSES ([llength $::calibrationPoses] poses collected)"

        # If we have enough poses, then stop the calibration process
        # (retract the printed side length?) and do a calibration. :-)
        if {[llength $::calibrationPoses] >= $CALIBRATION_POSES_MAX} {
            puts "READY CALIBARTION POSES!"

            catch {exec rm "$::env(HOME)/folk-calibration-output.txt"}

            set fd [open "$::env(HOME)/folk-calibration-poses.txt" w]
            puts $fd $::calibrationPoses; close $fd

            Commit calibration { Claim the calibration poses are $::calibrationPoses }
            Retract /someone/ claims the printed tag side length is /anything/ mm
        }
    }
}

fn processHomography {H} {
    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}


# Uses Zhang's calibration technique
# (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)
# to calibrate a projector or camera given a known 2D planar pattern
# and multiple observed poses.
#
# Returns intrinsic matrix for the camera/projector, which explains
# how 3D real-world coordinates get projected to 2D coordinates by
# that device. (The intrinsic matrix can be used with an AprilTag
# detector to get real-world coordinates for each AprilTag.)
#
# Arguments:
#         Hs   a list of N homographies from camera/projector image
#              plane -> model plane (for N different poses).
fn zhangUnrefinedCalibrate {Hs} {
    # Try to solve for the camera intrinsics:

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[::math::linearalgebra::shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V'
    set b [lindex [transpose ${V'}] [lindex [lsort -real -indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }

    set fx $alpha; set fy $beta
    set cx $u0; set cy $v0
    set s $gamma
    puts "   Focal Length: \[ $fx $fy ]"
    puts "Principal Point: \[ $cx $cy ]"
    puts "           Skew: \[ $s ] "

    # Intrinsic matrix:
    set A [subst {
        {$fx  $s   $cx}
        {0    $fy  $cy}
        {0    0    1}
    }]
    set Ainv [solvePGauss $A [mkIdentity 3]]

    set extrinsics [lmap H $Hs {
        set h1 [getcol $H 0]
        set h2 [getcol $H 1]
        set h3 [getcol $H 2]
        set lambda [/ 1.0 [norm [matmul $Ainv $h1]]]

        set r1 [scale $lambda [matmul $Ainv $h1]]
        set r2 [scale $lambda [matmul $Ainv $h2]]
        set r3 [crossproduct $r1 $r2]
        set R [transpose [list $r1 $r2 $r3]]

        set t [scale $lambda [matmul $Ainv $h3]]

        # Refine R into a better rotation matrix (reorthogonalize)
        # using SVD.
        lassign [determineSVD $R] U S V'
        set R [matmul $U [transpose ${V'}]]

        dict create R $R t $t
    }]

    # Initialize distortion terms k1 and k2 to 0 -- they get figured
    # out during nonlinear refinement.
    return [dict create intrinsics $A extrinsics $extrinsics \
                k1 0 k2 0]
}

fn centroid {points} {
    set sum {0 0 0}
    foreach point $points { set sum [add $sum $point] }
    return [scale [expr {1.0 / [llength $points]}] $sum]
}

# calibrationPoses is a list of N pose dictionaries. Each pose
# dictionary includes `tags` from a camera detection, `model` with
# coordinates in meters, `H_modelToDisplay`.
fn calibrate {calibrationPoses} {
    # First, calibrate the camera. "Using only the corners from
    # printed markers xb and their detected corners xc, [...]
    # calibrate the camera with no difficulties using Zhangâ€™s method."
    set Hs_modelToCamera [lmap pose $calibrationPoses {
        # Pairs of (camera coordinates, model coordinates).
        set model [dict get $pose model]
        set tags [dict get $pose tags]
        set pointPairs [list]
        dict for {id cameraTag} $tags {
            if {![isPrintedTag $id]} continue
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $cameraTag p] {
                    lappend pointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }

        estimateHomography $pointPairs
    }]
    puts "Zhang calibrate camera:"
    puts "========"
    set cameraCalibration [zhangUnrefinedCalibrate $Hs_modelToCamera]
    puts "\n======================\n"

    # Second, calibrate the projector.
    set modelToDisplayPointPairSets [list]
    set Hs_modelToDisplay [lmap pose $calibrationPoses {
        set H_modelToDisplay [dict get $pose H_modelToDisplay]

        set pointPairs [list]
        set model [dict get $pose model]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} continue
            foreach modelCorner [dict get $modelTag p] {
                set displayCorner [applyHomography $H_modelToDisplay $modelCorner]
                lappend pointPairs [list {*}$modelCorner {*}$displayCorner]
            }
        }

        set H_modelToDisplay
    }]
    puts "Zhang calibrate projector:"
    puts "========"
    set projectorCalibration [zhangUnrefinedCalibrate $Hs_modelToDisplay]
    puts "\n======================\n"

    set calibration [dict create camera $cameraCalibration \
                         projector $projectorCalibration]

    # What are R and t such that
    # R*cameraFramePoint + t = projectorFramePoint?
    set Rsum {{0 0 0} {0 0 0} {0 0 0}}
    set tsum {0 0 0}
    for {set i 0} {$i < [llength $calibrationPoses]} {incr i} {
        # For each checkerboard pose (model plane):
        # Rc*modelFramePoint + tc = cameraFramePoint
        # Rp*modelFramePoint + tp = projectorFramePoint

        set calibrationPose [lindex $calibrationPoses $i]

        set Rc [dict get [lindex [dict get $calibration camera extrinsics] $i] R]
        set tc [dict get [lindex [dict get $calibration camera extrinsics] $i] t]

        set Rp [dict get [lindex [dict get $calibration projector extrinsics] $i] R]
        set tp [dict get [lindex [dict get $calibration projector extrinsics] $i] t]

        set Rcinv [solvePGauss $Rc [mkIdentity 3]]
        set R [matmul $Rp $Rcinv]; set Rsum [add $Rsum $R]
        set t [sub $tp [matmul $R $tc]]; set tsum [add $tsum $t]
    }
    # Average R and t from all poses.
    set R [scale [/ 1.0 [llength $calibrationPoses]] $Rsum]
    set t [scale [/ 1.0 [llength $calibrationPoses]] $tsum]
    dict set calibration R_cameraToProjector $R
    dict set calibration t_cameraToProjector $t
    return $calibration
}
try {
    set fd [open "$::env(HOME)/folk-calibration-poses.txt" r]
    set calibrationPoses [read $fd]; close $fd

    if {[file exists "$::env(HOME)/folk-calibration-output.txt"]} {
        set fd [open "$::env(HOME)/folk-calibration-output.txt" r]
        set calibration [read $fd]; close $fd
        puts "READING CALIB"
        Commit calibration {
            Claim the calibration poses are $calibrationPoses
            Claim the calibration is $calibration
        }
    } else {
        Commit calibration {
            puts "NO CALIBRATION, JUST CALIB POSES"
            Claim the calibration poses are $calibrationPoses
        }
    }

} on error e {
    puts stderr "Failed to load calibration poses: $e"
}

When /nobody/ claims the calibration is /anything/ &\
     the calibration poses are /calibrationPoses/ &\
     the calibration refiner is /refineCalibration/ {
    if {[llength [Statements::findMatches [list /someone/ claims the calibration is /i/]]] >= 1} {
        return
    }

    # FIXME: don't hard-code side length mm
    set calibration [calibrate $calibrationPoses]
    set calibration [apply $refineCalibration \
                         [/ 17.5 1000] $calibrationPoses $calibration]
    Commit calibration {
        Claim the calibration poses are $calibrationPoses
        Claim the calibration is $calibration
    }
    set fd [open "$::env(HOME)/folk-calibration-output.txt" w]
    puts $fd $calibration; close $fd
}

# HACK: for fast testing
# Claim the printed tag side length is 17 mm
