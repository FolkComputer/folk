# calibrate.folk --
#
#     Implements camera-projector calibration: generate a calibration
#     pattern PDF, have the user measure its real-world dimension, run
#     iterative projector-camera process to get various poses of the
#     printed tags alongside projected tags, do linear fit and then
#     nonlinear refinement to find intrinsic and extrinsic parameters
#     for the camera and projector.
#
#     Closely based on the technique in Audet (2009):
#     http://www.ok.sc.e.titech.ac.jp/res/PCS/publications/procams2009.pdf
#

package require linalg

foreach p {add norm sub scale matmul
    getelem transpose determineSVD shape mkIdentity show
    solvePGauss crossproduct getcol setcol unitLengthVector det
} {
    namespace import ::math::linearalgebra::$p
}

# We try to use the AprilTag matrix library (instead of tcllib linalg)
# to do matrix/homography operations in the live calibration inner
# loop, to help with performance:
set cc [C]
$cc cflags -I./vendor/apriltag
$cc include <common/matd.h>
$cc include <common/homography.h>

$cc code {
    extern Jim_ObjType matd_ObjType;
    void matd_freeIntRepProc(Jim_Interp *interp, Jim_Obj *objPtr) {
        matd_destroy((matd_t*) objPtr->internalRep.ptr);
    }
    void matd_dupIntRepProc(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr) {
        dupPtr->internalRep.ptr = (void*) matd_copy((matd_t*) srcPtr->internalRep.ptr);
    }
    void matd_updateStringProc(Jim_Obj *objPtr) {
        matd_t *mat = (matd_t *)objPtr->internalRep.ptr;

        objPtr->bytes = calloc(mat->nrows, 1 + mat->ncols * 17 + 1);
        char *s = objPtr->bytes;
        int i = 0;
        
        for (unsigned int row = 0; row < mat->nrows; row++) {
            s[i++] = '{';
            for (unsigned int col = 0; col < mat->ncols; col++) {
                int n = snprintf(&s[i], 17,
                                 "%f ", MATD_EL(mat, row, col));
                FOLK_ENSURE(n <= 17); i += n;
            }
            s[i++] = '}';
        }
        objPtr->length = strlen(s);
    }
    int matd_setFromAnyProc(Jim_Interp *interp, Jim_Obj *objPtr) {
        // shimmer into a list, then iterate
        int nrows; Jim_Obj *rowObj0;
        nrows = Jim_ListLength(interp, objPtr);
        __ENSURE(nrows > 0);
        __ENSURE_OK(Jim_ListIndex(interp, objPtr, 0, &rowObj0, false));
        int ncols = Jim_ListLength(interp, rowObj0);
        __ENSURE(ncols > 0);

        matd_t *mat = matd_create(nrows, ncols);
        for (int row = 0; row < nrows; row++) {
            Jim_Obj *rowObj;
            __ENSURE_OK(Jim_ListIndex(interp, objPtr, row, &rowObj, false));
            int rowCols = Jim_ListLength(interp, rowObj);
            __ENSURE(rowCols == ncols);
            for (int col = 0; col < ncols; col++) {
                Jim_Obj *elObj;
                __ENSURE_OK(Jim_ListIndex(interp, rowObj, col, &elObj, false));
                __ENSURE_OK(Jim_GetDouble(interp, elObj, &MATD_EL(mat, row, col)));
            }
        }
        objPtr->typePtr = &matd_ObjType;
        objPtr->internalRep.ptr = mat;
        return JIM_OK;
    }
    Jim_ObjType matd_ObjType = (Jim_ObjType) {
        .name = "matd_t*",
        .freeIntRepProc = matd_freeIntRepProc,
        .dupIntRepProc = matd_dupIntRepProc,
        .updateStringProc = matd_updateStringProc,
        /* .setFromAnyProc = matd_setFromAnyProc, */
    };
}
$cc argtype matd_t* {
    __ENSURE_OK(matd_setFromAnyProc(interp, $obj));
    matd_t* $argname;
    $argname = (matd_t*) $obj->internalRep.ptr;
}
$cc rtype matd_t* {
    $robj = Jim_NewObj(interp);
    $robj->bytes = NULL;
    $robj->typePtr = &matd_ObjType;
    $robj->internalRep.ptr = $rvalue;
}


# Takes a list of at least 4 point pairs (model -> image) like
#
# [list \
#   [list x0 y0 u0 v0]] \
#   [list x1 y1 u1 v1] \
#   [list x2 y2 u2 v2] \
#   [list x3 y3 u3 v3]]
#
# Returns a 3x3 homography that maps model (x, y) to image (u, v)
# (using homogeneous coordinates).
$cc proc estimateHomographyImpl {int nPointPairs float[][4] pointPairs} matd_t* {
    // HACK: (sort of) point to the existing data block.
    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]),
        .size = nPointPairs, .alloc = nPointPairs,
        .data = (char*) pointPairs
    };
    return homography_compute(&correspondencesArr,
                              HOMOGRAPHY_COMPUTE_FLAG_SVD);
}
$cc proc applyHomography {matd_t* H double[2] xy} Jim_Obj* {
    double out[2];
    homography_project(H, xy[0], xy[1], &out[0], &out[1]);

    Jim_Obj* retObjs[2] = { Jim_NewDoubleObj(interp, out[0]), Jim_NewDoubleObj(interp, out[1]) };
    return Jim_NewListObj(interp, retObjs, 2);
}
$cc proc matdMul {matd_t* a matd_t* b} matd_t* {
    return matd_multiply(a, b);
}
$cc endcflags ./vendor/apriltag/libapriltag.so
set matLib [$cc compile]

# HACK: wrapper because we have to give the array length as a separate
# arg (at least for now).
fn estimateHomography {pointPairs} {
    $matLib estimateHomographyImpl [llength $pointPairs] $pointPairs
}


set ROWS 3
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `c` and `p` which are model points
# (x, y). Tags with isPrintedTag will get projected to PostScript
# points and printed; tags with isProjectedTag will get projected to
# Vulkan points and rendered on projector.
set UNIT_MODEL [apply {{ROWS COLS} {
    set UNIT_MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad [expr {$tagSideLength / 2}]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              c [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              p [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set UNIT_MODEL $id $modelTag
        }
    }
    return $UNIT_MODEL
}} $ROWS $COLS]
Claim the calibration unit model is $UNIT_MODEL

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 2 == 0}] ;# for checkerboard
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    return [expr {![isPrintedTag $id]}]
}
Claim the calibration isProjectedTag is ${^isProjectedTag}
Claim the calibration isPrintedTag is ${^isPrintedTag}

fn isVersionTag {id} {
    if {![isProjectedTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 4 == 1}] ;# for checkerboard
}
# Takes a dictionary of tag ID => {p, c} and rotates version tags
# according to version.
fn versionizeTags {tags version} {
    foreach id [dict keys $tags] {
        if {![isVersionTag $id]} {
            continue
        }
        # This is a version tag. Rotate it.
        set p [dict get $tags $id p]
        set rotatedCorners [list]
        for {set i 0} {$i < 4} {incr i} {
            lappend rotatedCorners [lindex $p [expr {($i + $version) % 4}]]
        }
        dict set tags $id p $rotatedCorners
    }
    return $tags
}

namespace import ::math::mean
fn meanPoseDifference {pose1 pose2} {
    set tags1 [dict get $pose1 tags]
    set tags2 [dict get $pose2 tags]

    set diffsum 0.0
    set ndiffs 0
    dict for {id tag} $tags1 {
        # We cheat and only count printed tags so we don't have to
        # deal with versioning.
        if {![isPrintedTag $id]} { continue }
        if {![dict exists $tags2 $id]} { continue }

        lassign [dict get $tag c] x1 y1
        lassign [dict get $tags2 $id c] x2 y2
        set diffsum [expr {$diffsum + sqrt(($x1 - $x2)*($x1 - $x2) + ($y1 - $y2)*($y1 - $y2))}]
        incr ndiffs
    }
    if {$ndiffs == 0} { return Inf }
    return [expr {$diffsum / $ndiffs}]
}
Claim the calibration meanPoseDifference is ${^meanPoseDifference}

fn makeCalibrationBoardPdf {model tagSideLengthPs} {
    package require linalg
    namespace import ::math::linearalgebra::add
    set printLib [dict get [lindex [Query! /someone/ claims the print library is /printLib/] 0] \
                      printLib]

    set marginTop 72; set marginLeft 36
    set PageWidth 612; set PageHeight 792

    set innerToOuter 0.333333

    set tagOuterLengthPs [expr {$tagSideLengthPs * 10/6}]

    set H_modelToPs [estimateHomography [subst {
        {1 1 $tagSideLengthPs $tagSideLengthPs}
        {1 0 $tagSideLengthPs 0}
        {0 1 0 $tagSideLengthPs}
        {0 0 0 0}
    }]]

    set ps [subst {
        %!PS
        << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

        % (0, 0) is bottom-left of portrait page right now.
        90 rotate 1 -1 scale
        % Now (0, 0) is top-left of landscape page.

        gsave
        $marginLeft [- $marginTop 18] translate
        1 -1 scale
        0 setgray /Helvetica findfont 14 scalefont setfont
        newpath 0 0 moveto (Folk calibration board) show
        grestore

        $marginLeft $marginTop translate

        [set tagIdx -1]
        [join [lmap {id modelTag} $model {
            if {![isPrintedTag $id]} { continue }
            incr tagIdx

            set modelInnerTopLeft [lindex [dict get $modelTag p] 3]
            set modelOuterTopLeft [add $modelInnerTopLeft [list -$innerToOuter -$innerToOuter]]
            lassign [$matLib applyHomography $H_modelToPs $modelOuterTopLeft] psX psY
            subst {
                gsave
                $psX [+ $psY $tagOuterLengthPs] translate
                $tagOuterLengthPs -$tagOuterLengthPs scale
                [$printLib tagPsForId $id]
                grestore

                % Label the inner side length:
                [if {$tagIdx == 1} { subst {
                    gsave
                    [expr {$psX + ($tagOuterLengthPs - $tagSideLengthPs)/2}]
                    [expr {$psY - 15}] translate
                    1 -1 scale
                    0.1 0.67 0.1 setrgbcolor
                    newpath 0 0 moveto $tagSideLengthPs 0 lineto stroke
                    newpath 0 0 moveto 0 -5 lineto stroke
                    newpath $tagSideLengthPs 0 moveto $tagSideLengthPs -5 lineto stroke
                    /Helvetica findfont 7 scalefont setfont
                    newpath 0 5 moveto (inner side length) show
                    grestore
                } }]
            }
        }] "\n"]
    }]

    set fp [open [list |ps2pdf - - <<$ps] rb]
    set pdf [read $fp]; close $fp
    return $pdf
}

fn makeExampleProgramPng {} {
    set programToPs [dict get [lindex [Query! /someone/ claims the programToPs is /programToPs/] 0] \
                         programToPs]

    # HACK: we hard-code letter, since this is just for documentation
    # purposes, and we want to cut the bottom half off so we need
    # known dimensions.
    set format letter
    set ps [{*}$programToPs 0 {# This image is for illustration purposes; don't
# print it. You should print a program normally
# through the Folk editor and measure that.} $format {{

        [set left [expr {$PageWidth-$tagwidth-$margin}]]
        [set bottom [expr {$PageHeight-$tagheight-$margin}]]
        [set outerToInner [expr {($tagwidth / 10.0) * 2}]]

        % These take in x1 y1 x2 y2 on stack.
        /markXDistance {
            newpath moveto
            0 -15 rlineto 0 30 rmoveto 0 -15 rlineto
            lineto
            0 -15 rlineto 0 30 rmoveto 0 -15 rlineto
            6 setlinewidth stroke
        } def
        /markYDistance {
            newpath moveto
            -15 0 rlineto 30 0 rmoveto -15 0 rlineto
            lineto
            -15 0 rlineto 30 0 rmoveto -15 0 rlineto
            6 setlinewidth stroke
        } def

        % Left
        [+ $left $outerToInner] [expr {$bottom + $tagheight/2.0}]
        0                       [expr {$bottom + $tagheight/2.0}]
        1 0 0 setrgbcolor markXDistance

        % Right
        [expr {$left + $tagwidth - $outerToInner}] [expr {$bottom + $tagheight/2.0}]
        $PageWidth                                 [expr {$bottom + $tagheight/2.0}]
        1 0 0 setrgbcolor markXDistance

        % Top
        [expr {$left + $tagwidth/2.0}] [expr {$bottom + $tagheight - $outerToInner}]
        [expr {$left + $tagwidth/2.0}] $PageHeight
        0 0.5 1 setrgbcolor markYDistance

        % Bottom
        [expr {$left + $tagwidth/2.0}] [expr {$bottom + $outerToInner}]
        [expr {$left + $tagwidth/2.0}] [expr {$PageHeight/2.0}]
        0 0.5 1 setrgbcolor markYDistance

        % Tag inner
        [+ $left $outerToInner]                    [+ $bottom $outerToInner 5]
        [expr {$left + $tagwidth - $outerToInner}] [+ $bottom $outerToInner 5]
        0 1 0 setrgbcolor markXDistance
    }}]

    set fp [open [list |gs -sDEVICE=png16m -q -dBATCH -r300 -sOutputFile=- - <<$ps] rb]
    set png [read $fp]; close $fp
    return $png
}

Wish the web server handles route "/calibrate$" with handler [list applyBlock {
    package require base64

    set calibrationBoardPdf [makeCalibrationBoardPdf $UNIT_MODEL 70]

    set exampleProgramPng [makeExampleProgramPng]

    set defaultGeom [dict get [lindex [Query! /someone/ claims the default program geometry is /defaultGeom/] 0] defaultGeom]
    fn defaultGeomGet {key} { return [string map {mm ""} [dict get $defaultGeom $key]] }

    upvar ^html ^html
    html [csubst {
      <html>
        <head>
          <title>Folk: Calibrate</title>
          <style>body { max-width: 600px; }</style>
        </head>
      <body>
        <span id="status">Status</span>
        <script src="/lib/folk.js"></script>
        <script>
         function uuidv4() {
           return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
             (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
           );
         }
         const self = uuidv4();

         const ws = new FolkWS(document.getElementById('status'));
        </script>

        <ol>
          <li>
            <h3>Print the calibration board.</h3>

            <p>Print this calibration board and glue/tape it to
            something solid and flat (hardcover book, solid cardboard,
            etc):</p>
            <iframe id="board-iframe" width="500px" height="300px" src="data:application/pdf;base64,$[::base64::encode $calibrationBoardPdf]">
            </iframe>
            <p>You can download the PDF and print it yourself, or print through Folk if your printer is set up: <button id="board-print-through-folk">Print Calibration Board through Folk</button></p>
            <script>
              document.getElementById('board-print-through-folk').addEventListener('click', (e) => {
                const boardSrc = document.getElementById('board-iframe').src.replace(/^data:application.pdf;base64,/, "");

                ws.evaluate(`
                  set boardPdf [::base64::decode {\${boardSrc}}]
                  set fd [open /tmp/folk-calibration-board.pdf w]
                  fconfigure \$fd -encoding binary -translation binary
                  puts \$fd \$boardPdf; close \$fd
                  exec lpr /tmp/folk-calibration-board.pdf
                `);
              });
            </script>
            <p>Try to keep the board from bending or warping. Printing on cardstock can help.</p>
            <p>(During calibration, Folk will want to project AprilTags in the gaps on the grid of tags on the board. Instead of printing, you can
            try just maximizing the board on your computer/tablet
            screen, but you'll need to cover each gap with sticky note or something else that Folk can project
            tags on.)</p>
          </li>

          <li>
            <h3>Measure your calibration board.</h3>

            <p>On your calibration board, measure the <span style="color: rgb(10% 67% 10%)">inner side length</span> (indicated on calibration PDF) of a tag in millimeters and enter it here: <input id="tag-side-length-mm" type="text">mm</p>

            <p>Try to be as accurate as possible, like to within half a millimeter or better -- the more accurate, the better your calibration will be.</p>
          </li>

          <li>
            <h3>Run the calibration process.</h3>

            <p>Start calibration: <button id="tag-side-length-submit">Start Calibration</button></p>
            <script>
              document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
                const mm = document.getElementById("tag-side-length-mm").value;
                if (mm === "" || isNaN(mm)) {
                  alert("Error: You need to type in a valid inner side length (mm) of your board tags before clicking Start Calibration.");
                  return;
                }

                // TODO: using Assert is a little ugly (it's so it can be
                // retracted when calibration is done)
                ws.send(tcl`
                  Claim the printed calibration tag size is \${mm} mm
                  Assert! \${self} wishes to calibrate
                `);
              });
            </script>

            <p>Once you start calibration, you'll see some AprilTags get automatically projected on your table. Move your board to the projected tags <strong>so that at least one projected tag sits inside the gap between printed AprilTags</strong>, wait a second for the projected tags to refit into the grid,
          then <strong>hold the board still for a few seconds until
              the pose is recorded.</strong></p>

            <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/l1liP4_yiVM?si=DqgfNKq05EPBT3hT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

            <p style="font-style: italic; width: 100%; text-align: center;">Example video of Andr&eacute;s calibration the Folk0 system (playing at 2x speed).</p>

            <p>Are the projected tags too big to fit in the gaps between printed tags? Adjust this slider to reset & adjust the default projected tag size:
              <input type="range" min="10" max="100" value="100" class="slider" id="projected-tag-slider">
            </p>
            <script>
              document.getElementById('projected-tag-slider').addEventListener('input', (e) => {
                const scale = e.target.value / 100.0;
                ws.evaluate(tcl`
                  set HoldDefaultModel! [dict get [lindex [Query! /someone/ claims the calibration HoldDefaultModel! is /hdm/] 0] hdm]
                  {*}[set HoldDefaultModel!] \${scale}
                `);
              });
            </script>

          <p>Use this camera preview to debug why printed and/or projected tags aren't being recognized (maybe overexposure, maybe your camera isn't in a good position): <button onclick="cameraFrame.src = cameraFrame.src + '0'">Refresh Preview</button></p><br> <img src="/camera-frame?0" id="cameraFrame" style="max-width: 100%"> 

          <p>Once you've recorded the first pose, <strong>slowly drag the board around your space</strong>, going slow enough for the projected AprilTags to catch up with the printed AprilTags and fit into the gaps on your board. When you've moved the board at least a full board-length away from the first pose, try to slant it 45 degrees or so off the table and hold it still again to capture another pose.</p>

          <p>Repeat this process of dragging the board around and
          capturing a new pose. You'll need to record 10 different
          poses; try to slant the board and move it up and around to
          cover the projector/camera area as much as possible. Once 10
          poses are recorded, you'll see the results below.</p>
        <p>(If calibration gets into a bad/stuck state, feel free to click Start Calibration again.)</p>

            <details>
              <summary>Troubleshooting</summary>
              <p>Look at ~/folk-calibration-poses to see images of the captured poses (maybe tags are distorted or washed out?).</p>
              <p>You can try manually adjusting webcam settings if your poses are bad. (They should be immediately reflected in the camera preview once you refresh.) Folk tries to turn off autofocus by default, but you might also want to turn off autoexposure and set a manual exposure time. For example:</p>
              <pre>
\$ v4l2-ctl --device=/dev/video0 --list-ctrls

User Controls

                     brightness 0x00980900 (int)    : min=0 max=255 step=1 default=128 value=128
                       contrast 0x00980901 (int)    : min=0 max=255 step=1 default=128 value=128
                     saturation 0x00980902 (int)    : min=0 max=255 step=1 default=128 value=128
        white_balance_automatic 0x0098090c (bool)   : default=1 value=1
                           gain 0x00980913 (int)    : min=0 max=255 step=1 default=0 value=109
           power_line_frequency 0x00980918 (menu)   : min=0 max=2 default=2 value=2 (60 Hz)
      white_balance_temperature 0x0098091a (int)    : min=2000 max=6500 step=1 default=4000 value=3453 flags=inactive
                      sharpness 0x0098091b (int)    : min=0 max=255 step=1 default=128 value=128
         backlight_compensation 0x0098091c (int)    : min=0 max=1 step=1 default=0 value=0

Camera Controls

                  auto_exposure 0x009a0901 (menu)   : min=0 max=3 default=3 value=3 (Aperture Priority Mode)
         exposure_time_absolute 0x009a0902 (int)    : min=3 max=2047 step=1 default=250 value=83 flags=inactive
     exposure_dynamic_framerate 0x009a0903 (bool)   : default=0 value=1
                   pan_absolute 0x009a0908 (int)    : min=-36000 max=36000 step=3600 default=0 value=0
                  tilt_absolute 0x009a0909 (int)    : min=-36000 max=36000 step=3600 default=0 value=0
                 focus_absolute 0x009a090a (int)    : min=0 max=250 step=5 default=0 value=30
     focus_automatic_continuous 0x009a090c (bool)   : default=1 value=0
                  zoom_absolute 0x009a090d (int)    : min=100 max=500 step=1 default=100 value=100
\$ v4l2-ctl --device=/dev/video0 --set-ctrl=auto_exposure=1
\$ v4l2-ctl --device=/dev/video0 --set-ctrl=exposure_time_absolute=25
              </pre>
            </details>
          </li>

          <li>
            <h3>Calibration results:</h3> <div id="calibration-report"></div>
            <script>
              const calibrationReportEl = document.getElementById('calibration-report');
              ws.watchCollected(`/someone/ claims the calibration report is /calibrationReport/`, reports => {
                if (reports.length === 0) {
                  calibrationReportEl.innerHTML = "<pre>Not calibrating yet.</pre>";
                  return;
                }
                calibrationReportEl.innerHTML = reports[0].calibrationReport;
              });
            </script>

            <p>(For a good calibration, camera RMSE and projector RMSE should ideally be less than 1 [1 to 2 is OK]. Stereo RMSE should ideally be less than 5 [less than 10 is OK].)</p>

            <p>Calibration should be in place once you have 10 poses!</p>

            <p>If you have a bad calibration, you can try just
            calibrating again.</p>
          </li>

          <li id="refineCalibrationLi" style="display: $[expr {$::thisNode in {"folk-convivial" "gadget-pink"} ? "''" : "none"}]">
            <h3>Refine calibration on the table.</h3>

            <p>Start table refinement: <button id="table-refinement-submit">Start Table Refinement</button></p>
            <script>
              document.getElementById('table-refinement-submit').addEventListener('click', (e) => {
                // HACK: duplicated code from above
                const mm = document.getElementById("tag-side-length-mm").value;
                if (mm === "" || isNaN(mm)) {
                  alert("Error: You need to type in a valid inner side length (mm) of your board tags before clicking Start Calibration.");
                  return;
                }
                // TODO: using Assert is a little ugly (it's so it can be
                // retracted when calibration is done)
                ws.send(tcl`
                  Claim the printed calibration tag size is \${mm} mm
                  Assert! \${self} wishes to do table refinement
                `);
              });
            </script>
          </li>

          <li>
            <h3>Measure program geometry.</h3>

            <p>Now we need to tell Folk the exact geometry of an
              average program page: what is the physical size of the
              AprilTag on the page? how far is the tag from the edges
              of the page?</p>

            <p><a href="/new">Print a program that outlines itself</a>,
              if you don't have one already.</p>

            <p>Fold the program in half if you want half-height programs. Measure the tag inner side length in millimeters, along with the distances in millimeters from the tag inner perimeter to each edge of the paper. Enter them below.</p>
            <img width="306" src="data:image/png;base64,$[::base64::encode $exampleProgramPng]"
              style="border: 2px solid black; height: 198px; object-fit: cover; object-position: 0 0;">

            <ul>
              <li style="color: green">Tag inner side length (try to be accurate to half a millimeter or better):
                <input id="geomTagSizeMm" type="text" placeholder="$[defaultGeomGet tagSize]">mm</li>

              <li style="color: red">Left: <input id="geomLeftMm" type="text" placeholder="$[defaultGeomGet left]">mm</li>
              <li style="color: red">Right: <input id="geomRightMm" type="text" placeholder="$[defaultGeomGet right]">mm</li>
              <li style="color: blue">Top: <input id="geomTopMm" type="text" placeholder="$[defaultGeomGet top]">mm</li>
              <li style="color: blue">Bottom: <input id="geomBottomMm" type="text" placeholder="$[defaultGeomGet bottom]">mm</li>
            </ul>

            <p><button id="geomSave">Save Program Geometry</button></p>
            <script>
             geomSave.addEventListener('click', () => {
               if (!([geomTagSizeMm.value, geomLeftMm.value, geomRightMm.value,
                      geomTopMm.value, geomBottomMm.value].every(x => x != "" && !isNaN(x)))) {
                 alert("Error: You haven't filled in all the geometry values.");
                 return;
               }
               const geom = {
                 tagSize: geomTagSizeMm.value + 'mm',
                 left: geomLeftMm.value + 'mm',
                 right: geomRightMm.value + 'mm',
                 top: geomTopMm.value + 'mm',
                 bottom: geomBottomMm.value + 'mm'
               };
               ws.hold('default program geometry',
                       tcl`
set fd [open "\$::env(HOME)/folk-printed-programs/default.folkgeom" w]
set geom \${geom}; puts \$fd \$geom; close \$fd
Claim the default program geometry is \$geom
`,
                       '<global>');
             });
            </script>

            <details>
              <summary>How to manually override the geometry of a specific program</summary>

              <p>If you've, for example, printed out program 30 at a
              different size, or you manually cut and pasted the tag
              30 somewhere and want to create a specially sized region
              around that, you can set tag 30's geometry manually by making a
              30.meta.folk text file in ~/folk-printed-programs, with content like this:</p>

              <pre>Claim tag \$this has geometry {tagSize 30mm top 28mm right 28mm left 157mm bottom 80mm}</pre>
            </details>
          </li>

          <li>
            <h3>Test calibration.</h3>

            <p>The best way to test calibration is to look at your
              printed program and see how well the projected outline
              lines up with the physical edge of your program.</p>

            <p>Again, if you have a bad calibration, you can try just
            calibrating again. (Just scroll back up and click Start
            Calibration. You don't need to redo any of the steps
            before or after.)</p>
          </li>
        </ol>
      </body>
    </html>
  }]
} [captureEnvStack]]

fn lsort-indices {itemL} {
    set pairL [list]
    foreach item $itemL {
      lappend pairL [list $item [llength $pairL]]
    }
    set indexL [list]
    foreach pair [lsort -index 0 -real $pairL] {
      lappend indexL [lindex $pair 1]
    }
    set indexL
}

set CALIBRATION_POSES_MAX 10

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     the image library is /imageLib/ &\
     the printed calibration tag size is /printedSideLengthMm/ mm &\
     /someone/ wishes to calibrate {
    # Project projected tags once the printed side length has been
    # dialed in.

    # VERY IMPORTANT: disable autofocus forever.
    catch { exec v4l2-ctl --device=$camera --set-ctrl=focus_automatic_continuous=0 }

    if {$cameraWidth < 1920} {
        Retract! /someone/ wishes $::thisNode uses camera $camera \
            with width $cameraWidth height $cameraHeight
        Assert! $this wishes $::thisNode uses camera $camera with width 1920 height 1080
        # TODO: restore old camera resolution later
    }

    package require linalg
    namespace import ::math::linearalgebra::scale

    # HACK: hard-coded for now; assumes dark room. Won't work on USB
    # webcams yet, either (just Pi).
    # Wish camera $camera uses exposure time 16000 us

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    # UNIT_MODEL's 2D coordinates have inner tag side length of 1.0:
    # scale it to real-world coordinates.
    set baseModel [dict create]
    dict for {id tag} $UNIT_MODEL {
        dict set baseModel $id c [scale $printedSideLengthM [dict get $tag c]]
        dict set baseModel $id p [scale $printedSideLengthM [dict get $tag p]]
    }

    # A list of pose dictionaries. Each dictionary has entries `model`
    # and `H_modelToDisplay` ('prewarp' homography from model plane to
    # projector plane) and `tags` (tag ID => dictionary of tag
    # detection info from camera and AprilTag detector) and
    # `displayResolution` and `cameraResolution` and `tagsSize`.
    Hold! (non-capturing) (on calibration) seenPoses \
        { Claim the calibration last-seen poses are [list] }
    set SEEN_POSES_MAX 3

    # The poses to use for actual calibration at the end. We'll want
    # at least 10 poses to do ultimate calibration+refinement.
    Hold! (non-capturing) (on calibration) poses \
        { Claim the calibration poses are [list] }


    HoldStatement! cycleTime [list $this claims the calibration cycle time is 0]

    # Project calibration tags based on the current model-to-display
    # homography (which gets dynamically updated as you move the board
    # around):
    When the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /anything/ timestamp /anything/ &\
         the calibration poses are /calibrationPoses/ &\
         the calibration cycle time is /cycleTime/ {

        package require linalg
        namespace import ::math::linearalgebra::scale \
            ::math::linearalgebra::add ::math::linearalgebra::sub

        fn innerToOuter {center corner} {
            set r [sub $corner $center]
            return [add $center [scale [expr {sqrt(50)/sqrt(18)}] $r]]
        }

        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} { continue }

            set modelInnerCorners [lreverse [dict get $modelTag p]]
            set modelCenter [dict get $modelTag c]

            set projectorOuterCorners [lmap modelInnerCorner $modelInnerCorners {
                $matLib applyHomography $H_modelToDisplay \
                    [innerToOuter $modelCenter $modelInnerCorner]
            }]
            Wish to draw an AprilTag with id $id corners $projectorOuterCorners layer 100
        }

        # White backdrop to hopefully make the projected tags pop out more:
        Wish to draw a quad with \
            p0 [list 0 0] p1 [list $displayWidth 0] \
            p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
            color white layer 99

        # Instructions for the user:
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        # FIXME: Last 2 points' angle is screwed up.
        set sides \
            [list \
                 [list $modelTopLeft $modelTopRight] \
                 [list $modelBottomRight $modelBottomLeft] \
                 [list $modelBottomLeft $modelTopLeft] \
                 [list $modelTopRight $modelBottomRight]]

        set text "[llength $calibrationPoses]/$CALIBRATION_POSES_MAX poses ([expr {round($cycleTime*1000)}] ms)"
        foreach p {add norm sub scale matmul
            getelem transpose determineSVD shape mkIdentity show
            solvePGauss crossproduct getcol setcol unitLengthVector det
        } {
            namespace import ::math::linearalgebra::$p
        }
        foreach side $sides {
            lassign $side start end
            set segment [sub $end $start]
            set normal [unitLengthVector [list [- [lindex $segment 1]] [lindex $segment 0]]]
            set modelPosition [add [scale 0.5 [add $start $end]] \
                                   [scale [* -1.0 $printedSideLengthM] $normal]]

            set dispSeg [sub [$matLib applyHomography $H_modelToDisplay $end] \
                             [$matLib applyHomography $H_modelToDisplay $start]]
            set radians $(-1 * atan2([lindex $dispSeg 1], [lindex $dispSeg 0]))

            Wish to draw text with text $text radians $radians \
                position [$matLib applyHomography $H_modelToDisplay $modelPosition] \
                anchor center color black layer 100 scale 2.0
        }
    }

    # This is made a function so it can also be called by the Web page
    # when the user drags the slider to adjust projected tag scale.
    fn HoldDefaultModel! {scale} {
        # Default model: just makes the tags fill most of the middle
        # of the projector area.
        set tagSideLengthPixels [::math::min $($displayWidth/($COLS * ($tagOuterLength + $pad))) \
                                     $($displayHeight/($ROWS * ($tagOuterLength + $pad)))]
        set tagSideLengthPixels [expr {$tagSideLengthPixels * $scale}]

        # TODO: Center this on the projector area.
        set H_modelToDisplay [estimateHomography [subst {
            {$printedSideLengthM $printedSideLengthM $tagSideLengthPixels $tagSideLengthPixels}
            {$printedSideLengthM 0 $tagSideLengthPixels 0}
            {0 $printedSideLengthM 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Hold! H_modelToDisplay {
            # Default model and version: nothing rotated.
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $baseModel version -1 timestamp [expr {[clock milliseconds] / 1000.0}]
        }
    }
    Claim the calibration HoldDefaultModel! is [fn HoldDefaultModel!]

    HoldDefaultModel! 1.0
    On unmatch { Hold! H_modelToDisplay {} }

    When /detector/ detects tags /tags/ on camera $camera \
             at timestamp /timestamp/ in time /something/ &\
         the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /version/ timestamp /hTimestamp/ {

        if {[lindex $detector 1] ne "entire-frame"} { return }

        # This runs every frame, looks at the detected tags (both
        # projected and printed), and updates the H_modelToDisplay
        # such that the projected tags should sit in the middle of the
        # calibration board.

        set startTime [clock microseconds]

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $printedTag p] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        set printedCalibrationBoard [list {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomLeft]]
        set boardMinX 100000; set boardMinY 100000
        set boardMaxX -100000; set boardMaxY -100000
        foreach {cornerX cornerY} $printedCalibrationBoard {
            if {$cornerX < $boardMinX} { set boardMinX $cornerX }
            if {$cornerY < $boardMinY} { set boardMinY $cornerY }
            if {$cornerX > $boardMaxX} { set boardMaxX $cornerX }
            if {$cornerY > $boardMaxY} { set boardMaxY $cornerY }
        }

        # We only count projected tags that are inside the board.
        set projectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }

            lassign [dict get $tag c] x y
            if {$x > $boardMinX && $x < $boardMaxX &&
                $y > $boardMinY && $y < $boardMaxY} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # Check the rotation of a version tag to figure out the
        # version of what the camera saw, unless it's version -1.
        if {$version != -1} {
            # Find any version tag. If none were detected, then abort
            # and wait until a later frame.
            dict for {id tag} $projectedTags {
                if {[isVersionTag $id]} {
                    set versionTagId $id
                    break
                }
            }
            if {![info exists versionTagId]} { return }

            set getTagAngle {{tag} {
                set p [dict get $tag p]
                expr {atan2(-1 * ([lindex $p 1 1] - [lindex $p 0 1]),
                            [lindex $p 1 0] - [lindex $p 0 0])}
            }}
            set versionTagAngle [apply $getTagAngle [dict get $projectedTags $versionTagId]]

            # Compare angle to angle of any other projected tag.
            if {[dict size $projectedTags] < 2} { return }
            dict for {id projectedTag} $projectedTags {
                if {![isVersionTag $id]} {
                    set otherTagAngle [apply $getTagAngle $projectedTag]
                    break
                }
            }
            if {![info exists otherTagAngle]} { return }

            set versionAngle [expr {$versionTagAngle - $otherTagAngle}]
            # Rotations corresponding to versions 0, 1, 2, 3:
            set possibleVersions \
                [list 1  0 \
                      0  1 \
                     -1  0 \
                      0 -1]
            # Which of the possibleVersions is versionAngle closest to?
            set detectedVersion [lindex [lsort-indices [lmap {x y} $possibleVersions {
                expr {sqrt(($x - cos($versionAngle))**2 + ($y - sin($versionAngle))**2)}
            }]] 0]

            # If the detected version does not correspond to version mod 4,
            # then we should abort and wait until a later frame.
            set expectedVersion [expr {$version % 4}]
            if {$detectedVersion != $expectedVersion} {
                return
            }
        }

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $projectedTag p] {
                    set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }

        # puts "point pairs (camera -> display): {$projectedPointPairs}"
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]
        if {abs([::math::linearalgebra::det $H_cameraToDisplay]) < 0.001} {
            # Garbage homography that just shrinks the points way down
            # (https://stackoverflow.com/questions/10972438/detecting-garbage-homographies-from-findhomography-in-opencv).
            # It's sort of 'overfitted' and just has a big y-intercept
            # and will break everything if we let it through. Skip.
            return
        }

        # Update H_modelToDisplay to project the tags into the middle
        # of the board next frame.
        set nextH_modelToDisplay [$matLib matdMul $H_cameraToDisplay $H_modelToCameraViaPs]
        set nextTimestamp [expr {[clock milliseconds] / 1000.0}]
        set nextVersion [+ $version 1]
        set nextModel [versionizeTags $baseModel $nextVersion]
        HoldStatement! H_modelToDisplay \
            [list $this claims the calibration model-to-display homography \
                 is $nextH_modelToDisplay with \
                 model $nextModel version $nextVersion timestamp $nextTimestamp]
        HoldStatement! cycleTime \
            [list $this claims the calibration cycle time is $($nextTimestamp - $hTimestamp)]

        # Should we record the points we just saw as a calibration
        # pose?

        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }

        # We can do an error check here. H_modelToCameraViaPs was
        # derived above from printed tags -- we should be able to run
        # _projected_ tags through it and compare the coordinates to
        # the actual detection coordinates. If there's too much error,
        # we won't record this as a calibration pose.
        set totalError 0.0
        dict for {id projectedTag} $projectedTags {
            foreach modelCorner [dict get $model $id p] \
                cameraCorner [dict get $projectedTag p] {
                    lassign $cameraCorner cx cy
                    # Predicted camera x and y.
                    lassign [$matLib applyHomography $H_modelToCameraViaPs $modelCorner] px py
                    set dx [- $cx $px]; set dy [- $cy $py]
                    set err [expr {$dx*$dx + $dy*$dy}]
                    set totalError [+ $totalError $err]
            }
        }
        set poseRmse [expr {sqrt($totalError / ([llength $projectedTags] * 4))}]
        if {$poseRmse > 5} {
            puts "Pose has too-high rmse ($poseRmse); skipping"
            return
        }

        set pose [dict create \
                      model $model version $version \
                      camera $camera \
                      cameraWidth $cameraWidth cameraHeight $cameraHeight \
                      display $display \
                      displayWidth $displayWidth displayHeight $displayHeight \
                      tagSize $printedSideLengthM \
                      H_modelToDisplay $H_modelToDisplay \
                      rmse $poseRmse \
                      tags [dict merge $printedTags $projectedTags]]

        set seenPoses [dict get [lindex [Query! /someone/ claims the calibration last-seen poses are /seenPoses/] 0] seenPoses]
        lappend seenPoses $pose
        if {[llength $seenPoses] > $SEEN_POSES_MAX} {
            set seenPoses [lreplace $seenPoses 0 0]
        }
        HoldStatement! (on calibration) seenPoses \
            [list $this claims the calibration last-seen poses are $seenPoses]

        # Next, we check if projected tag corners have been pretty
        # stable in the last few frames.

        if {[llength $seenPoses] < 3} {
            return
        }

        # If the corners have moved a lot since last frame, we're not
        # stable enough and shouldn't record this as a calibration
        # pose.
        foreach seenPose [lrange $seenPoses 0 end-1] {
            # Decreasing this threshold to 1 helps with data
            # accuracy. TODO: Use an _older_ frame?
            if {[meanPoseDifference $pose $seenPose] > 5} {
                return
            }
        }

        puts "WOULD APPEND CALIBRATION ([- [clock microseconds] $startTime] us)..."

        # If the corners have _not_ moved a lot since last _saved_
        # calibration pose, this isn't different enough to be a good
        # calibration pose to save.
        set calibrationPoses [dict get [lindex [Query! /someone/ claims the calibration poses are /calibrationPoses/] 0] calibrationPoses]
        if {[llength $calibrationPoses] > 0} {
            set prevCalibrationPose [lindex $calibrationPoses end]
            if {[meanPoseDifference $pose $prevCalibrationPose] < 50} {
                return
            }
        }

        # Save the pose / camera image to a jpeg (for debugging purposes)
        exec mkdir -p "$::env(HOME)/folk-calibration-poses"
        $imageLib saveAsJpeg [dict get [lindex [Query! /someone/ claims camera /any/ has frame /frame/ at timestamp /any/] 0] frame] \
            "$::env(HOME)/folk-calibration-poses/pose-[clock milliseconds]-[llength $calibrationPoses].jpeg"

        # OK, let's save this calibration pose.
        lappend calibrationPoses $pose
        puts "APPENDED CALIBRATION TO POSES ([llength $calibrationPoses] poses collected)"
        HoldStatement! (on calibration) poses \
            [list $this claims the calibration poses are $calibrationPoses]

        # Hold reporting info for the Web page.
        set calibrationReport "<p>Poses:</p><ol>
        [join [lmap pose $calibrationPoses {subst {
            <li>RMSE [dict getdef $pose rmse (unavailable)]</li>
        }}] \n]
        [string repeat {<li>Not detected yet</li>} [- 10 [llength $calibrationPoses]]]
        </ol>"
        Hold! (non-capturing) calibration report \
            [list Claim the calibration report is $calibrationReport]

        # If we have enough poses, then stop the calibration process
        # (retract the printed side length?) and do a calibration. :-)
        if {[llength $calibrationPoses] >= $CALIBRATION_POSES_MAX} {
            puts "READY CALIBRATION POSES!"

            catch { exec mkdir "$::env(HOME)/folk-live" }
            catch {exec rm "$::env(HOME)/folk-live/folk-calibration-output.txt"}

            set fd [open "$::env(HOME)/folk-live/folk-calibration-poses.txt" w]
            puts $fd $calibrationPoses; close $fd

            # Destroy the old calibration and trigger a new one.
            HoldStatement! (on calibration) calibration {}

            Retract! /someone/ wishes to calibrate
        }
    }
}

fn processHomography {H} {
    package require linalg
    namespace import ::math::linearalgebra::getelem
    namespace import ::math::linearalgebra::sub

    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}


# Uses Zhang's calibration technique
# (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)
# to calibrate a projector or camera given a known 2D planar pattern
# and multiple observed poses.
#
# Returns intrinsic matrix for the camera/projector, which explains
# how 3D real-world coordinates get projected to 2D coordinates by
# that device. (The intrinsic matrix can be used with an AprilTag
# detector to get real-world coordinates for each AprilTag.)
#
# Arguments:
#         width  width of camera or projector in pixels
#         height height of camera or projector in pixels
#         Hs     a list of N homographies from camera/projector image
#                plane -> model plane (for N different poses).
fn zhangUnrefinedCalibrate {name width height Hs} {
    package require linalg
    namespace import ::math::linearalgebra::shape \
        ::math::linearalgebra::transpose \
        ::math::linearalgebra::matmul \
        ::math::linearalgebra::determineSVD \
        ::math::linearalgebra::mkIdentity \
        ::math::linearalgebra::solvePGauss \
        ::math::linearalgebra::getcol \
        ::math::linearalgebra::norm \
        ::math::linearalgebra::scale \
        ::math::linearalgebra::crossproduct \
        ::math::linearalgebra::add \
        ::math::linearalgebra::sub

    # Try to solve for the camera intrinsics:

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V
    set b [lindex [transpose $V] [lindex [lsort-indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }

    set fx $alpha; set fy $beta
    set cx $u0; set cy $v0
    set s $gamma
    puts "   Focal Length: \[ $fx $fy ]"
    puts "Principal Point: \[ $cx $cy ]"
    puts "           Skew: \[ $s ] "

    # Intrinsic matrix:
    set A [subst {
        {$fx  $s   $cx}
        {0    $fy  $cy}
        {0    0    1}
    }]
    set Ainv [solvePGauss $A [mkIdentity 3]]

    set extrinsics [lmap H $Hs {
        set h1 [getcol $H 0]
        set h2 [getcol $H 1]
        set h3 [getcol $H 2]
        set lambda [/ 1.0 [norm [matmul $Ainv $h1]]]

        set r1 [scale $lambda [matmul $Ainv $h1]]
        set r2 [scale $lambda [matmul $Ainv $h2]]
        set r3 [crossproduct $r1 $r2]
        set R [transpose [list $r1 $r2 $r3]]

        set t [scale $lambda [matmul $Ainv $h3]]

        # Refine R into a better rotation matrix (reorthogonalize)
        # using SVD.
        lassign [determineSVD $R] U S V
        set R [matmul $U [transpose $V]]

        dict create R $R t $t
    }]

    # Initialize distortion terms k1 and k2 to 0 -- they get figured
    # out during nonlinear refinement.
    set intrinsics [dict create \
                        width $width height $height \
                        fx $fx fy $fy cx $cx cy $cy s $s \
                        k1 0 k2 0]
    return [dict create \
                name $name \
                intrinsics $intrinsics \
                extrinsics $extrinsics]
}

fn setCameraToProjectorExtrinsics {calibrationVar calibrationPoses} {
    # Use the "Kabsch algorithm" (https://nghiaho.com/?page_id=671;
    # https://zpl.fi/aligning-point-patterns-with-kabsch-umeyama-algorithm/)
    # to find the rotation and translation from 3D camera-space to 3D
    # projector-space.

    upvar $calibrationVar calibration

    # Let's take all the points for which we have a corresponding
    # camera frame point and projector frame point.
    set cameraFramePoints [list]
    set projectorFramePoints [list]

    for {set i 0} {$i < [llength $calibrationPoses]} {incr i} {
        set calibrationPose [lindex $calibrationPoses $i]
        
        set Rc [dict get [lindex [dict get $calibration camera extrinsics] $i] R]
        set tc [dict get [lindex [dict get $calibration camera extrinsics] $i] t]

        set Rp [dict get [lindex [dict get $calibration projector extrinsics] $i] R]
        set tp [dict get [lindex [dict get $calibration projector extrinsics] $i] t]

        # TODO: Try using pose estimation instead?
        dict for {id tag} [dict get $calibrationPose model] {
            if {![isProjectedTag $id]} { continue }
            set k 0
            foreach v [dict get $tag p] {
                incr k
                lappend v 0.0

                set vc [add [matmul $Rc $v] $tc]
                set vp [add [matmul $Rp $v] $tp]

                lappend cameraFramePoints $vc
                lappend projectorFramePoints $vp
            }
        }
    }

    # puts "cameraFramePoints = \[[join [lmap p $cameraFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"
    # puts "projectorFramePoints = \[[join [lmap p $projectorFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"

    set n [llength $cameraFramePoints]

    set vcsum {0 0 0}
    foreach vc $cameraFramePoints { set vcsum [add $vcsum $vc] }
    set cameraFramePointsCentroid [scale [/ 1.0 $n] $vcsum]

    set vpsum {0 0 0}
    foreach vp $projectorFramePoints { set vpsum [add $vpsum $vp] }
    set projectorFramePointsCentroid [scale [/ 1.0 $n] $vpsum]

    set H [matmul [transpose [sub $cameraFramePoints \
                                  [lrepeat $n $cameraFramePointsCentroid]]] \
               [sub $projectorFramePoints \
                    [lrepeat $n $projectorFramePointsCentroid]]]

    lassign [determineSVD $H] U S V
    set R [matmul $V [transpose $U]]
    set t [sub $projectorFramePointsCentroid \
               [matmul $R $cameraFramePointsCentroid]]

    dict set calibration R_cameraToProjector $R
    dict set calibration t_cameraToProjector $t
}

# End-to-end calibrates a camera-projector pair. calibrationPoses is
# a list of N pose dictionaries. Each pose dictionary includes `tags`
# from a camera detection, `model` with coordinates in meters,
# `H_modelToDisplay`.
fn unrefinedCalibrateCameraAndProjector {calibrationPoses} {
    package require linalg
    namespace import ::math::linearalgebra::det
    namespace import ::math::linearalgebra::scale

    # Just used to get metadata about cam/proj:
    set pose0 [lindex $calibrationPoses 0]

    # First, calibrate the camera. "Using only the corners from
    # printed markers xb and their detected corners xc, [...]
    # calibrate the camera with no difficulties using Zhangs method."
    set i 0
    set Hs_modelToCamera [lmap pose $calibrationPoses {
        # Pairs of (camera coordinates, model coordinates).
        set model [dict get $pose model]
        set tags [dict get $pose tags]
        set pointPairs [list]
        dict for {id cameraTag} $tags {
            if {![isPrintedTag $id]} continue
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $cameraTag p] {
                    lappend pointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }

        set H [estimateHomography $pointPairs]
        if {[det $H] < 0} {
            set H [scale -1 $H]
        }
        set H
    }]
    puts "Zhang calibrate camera:"
    puts "========"
    set cameraName [dict get $pose0 camera]
    set cameraWidth [dict get $pose0 cameraWidth]
    set cameraHeight [dict get $pose0 cameraHeight]
    set cameraCalibration [zhangUnrefinedCalibrate \
                               $cameraName $cameraWidth $cameraHeight \
                               $Hs_modelToCamera]
    puts "\n======================\n"

    # Second, calibrate the projector.
    set i 0
    set Hs_modelToDisplay [lmap pose $calibrationPoses {
        set H_modelToDisplay [dict get $pose H_modelToDisplay]

        set pointPairs [list]
        set model [dict get $pose model]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} continue
            foreach modelCorner [dict get $modelTag p] {
                set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                lappend pointPairs [list {*}$modelCorner {*}$displayCorner]
            }
        }

        if {[det $H_modelToDisplay] < 0} {
            set H_modelToDisplay [scale -1 $H_modelToDisplay]
        }
        set H_modelToDisplay
    }]
    puts "Zhang calibrate projector:"
    puts "========"
    set projectorName [dict get $pose0 display]
    set projectorWidth [dict get $pose0 displayWidth]
    set projectorHeight [dict get $pose0 displayHeight]
    set projectorCalibration [zhangUnrefinedCalibrate \
                                  $projectorName \
                                  $projectorWidth $projectorHeight \
                                  $Hs_modelToDisplay]
    puts "\n======================\n"

    set calibration [dict create \
                         camera $cameraCalibration \
                         projector $projectorCalibration]
    setCameraToProjectorExtrinsics calibration $calibrationPoses
    return $calibration
}

When the calibration poses are /calibrationPoses/ &\
     /nobody/ claims the calibration is /anything/ &\
     the calibration refiner is /refineCalibration/ {

    if {[llength $calibrationPoses] < $CALIBRATION_POSES_MAX} {
        return
    }

    set calibration [unrefinedCalibrateCameraAndProjector $calibrationPoses]
    puts "======== Unrefined calibration ========="
    puts $calibration
    puts ""

    set calibration [{*}$refineCalibration \
                         [fn isPrintedTag] [fn isProjectedTag] $matLib \
                         $calibrationPoses $calibration]
    puts "======== Refined calibration intrinsics ========="

    puts "."
    puts "======== Refined calibration ========="
    puts $calibration
    puts "."

    set calibrationReport "<p>Poses:</p><ol>
        [join [lmap pose $calibrationPoses {subst {
            <li>RMSE [dict getdef $pose rmse (unavailable)]</li>
        }}] \n]
        [string repeat {<li>Not detected yet</li>} [- 10 [llength $calibrationPoses]]]
        </ol>
        <p>Calibration:</p><pre>
Camera intrinsics --------
[join [lmap {k v} [dict get $calibration camera intrinsics] {list $k $v}] \n]

Camera RMSE [dict getdef $calibration camera rmse (unavailable)]

Projector intrinsics -----
[join [lmap {k v} [dict get $calibration projector intrinsics] {list $k $v}] \n]

Projector RMSE [dict getdef $calibration projector rmse (unavailable)]

----
Stereo RMSE [dict getdef $calibration rmse (unavailable)]
</pre>"
    Hold! (non-capturing) calibration report \
        [list Claim the calibration report is $calibrationReport]

    When the printed calibration tag size is /tagSizeMm/ mm {
        puts "======== Reproject pose 0 ========="
        set pose [lindex $calibrationPoses 0]
        set tagSize [expr {$tagSizeMm / 1000.0}]
        set cameraIntrinsics [dict get $calibration camera intrinsics]
        set cameraWidth [dict get $calibration camera intrinsics width]
        set cameraHeight [dict get $calibration camera intrinsics height]
        set projectorIntrinsics [dict get $calibration projector intrinsics]
        set projectorWidth [dict get $calibration projector intrinsics width]
        set projectorHeight [dict get $calibration projector intrinsics height]
        dict for {id det} [dict get $pose tags] {
            # Look through all the projected tags that we detected on
            # camera in this pose.
            if {![isProjectedTag $id]} { continue }

            puts "Tag $id:"

            set p [dict get $det p] ;# Camera detected corners.

            # Pose-estimate this tag.
            set tagPose [baseEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $p]
            set tagPose [servoingEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $tagPose $p]

            set r [expr {$tagSize / 2}]
            set tagVertices \
                [list [list [- $r]    $r  0] \
                     [list     $r     $r  0] \
                     [list     $r  [- $r] 0] \
                     [list  [- $r] [- $r] 0]]
            # Move the pose to camera-space.
            set cameraVertices [lmap v $tagVertices {
                set R [dict get $tagPose R]; set t [dict get $tagPose t]
                add [matmul $R $v] $t
            }]

            # Move the pose to projector-space.
            set projectorVertices [lmap v $cameraVertices {
                set R [dict get $calibration R_cameraToProjector]
                set t [dict get $calibration t_cameraToProjector]
                add [matmul $R $v] $t
            }]

            # Downproject to the projector pixel plane.
            set modelTag [dict get $pose model $id]
            for {set i 0} {$i < 4} {incr i} {
                set modelCorner [lindex [dict get $modelTag p] $i]
                lassign [$matLib applyHomography [dict get $pose H_modelToDisplay] $modelCorner] px py
                puts [format "Corner $i (real)  : (%.3f %.3f)" $px $py]

                set v [lindex $projectorVertices $i]
                lassign [intrinsics project $projectorIntrinsics \
                             $projectorWidth $projectorHeight \
                             $v] rpx rpy
                puts [format "Corner $i (reproj): (%.3f %.3f)" $rpx $rpy]
            }
        }
    }

    HoldStatement! (on calibration) calibration \
        [list $this claims the calibration is $calibration]

    set fd [open "$::env(HOME)/folk-live/folk-calibration-output.txt" w]
    puts $fd $calibration; close $fd
}
