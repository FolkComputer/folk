# calibrate.folk --
#
#     Implements camera-projector calibration: generate a calibration
#     pattern PDF, have the user measure its real-world dimension, run
#     iterative projector-camera process to get various poses of the
#     printed tags alongside projected tags, do linear fit and then
#     nonlinear refinement to find intrinsic and extrinsic parameters
#     for the camera and projector.
#
#     Closely based on the technique in Audet (2009):
#     http://www.ok.sc.e.titech.ac.jp/res/PCS/publications/procams2009.pdf
#

package require linalg

foreach p {add norm sub scale matmul
    getelem transpose determineSVD shape mkIdentity show
    solvePGauss crossproduct getcol setcol unitLengthVector det
} {
    namespace import ::math::linearalgebra::$p
}

# We try to use the AprilTag matrix library (instead of tcllib linalg)
# to do matrix/homography operations in the live calibration inner
# loop, to help with performance:
set cc [C]
$cc cflags -I./vendor/apriltag
$cc include <math.h>
$cc include <common/matd.h>
$cc include <common/homography.h>

$cc code {
    extern Jim_ObjType matd_ObjType;
    void matd_freeIntRepProc(Jim_Interp *interp, Jim_Obj *objPtr) {
        matd_destroy((matd_t*) objPtr->internalRep.ptr);
    }
    void matd_dupIntRepProc(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr) {
        dupPtr->internalRep.ptr = (void*) matd_copy((matd_t*) srcPtr->internalRep.ptr);
    }
    void matd_updateStringProc(Jim_Obj *objPtr) {
        matd_t *mat = (matd_t *)objPtr->internalRep.ptr;

        objPtr->bytes = Jim_Alloc(mat->nrows * (1 + mat->ncols * 17 + 1));
        char *s = objPtr->bytes;
        int i = 0;
        
        for (unsigned int row = 0; row < mat->nrows; row++) {
            s[i++] = '{';
            for (unsigned int col = 0; col < mat->ncols; col++) {
                int n = snprintf(&s[i], 17,
                                 "%f ", MATD_EL(mat, row, col));
                FOLK_ENSURE(n <= 17); i += n;
            }
            s[i++] = '}';
        }
        s[i] = 0;
        objPtr->length = strlen(s);
    }
    int matd_setFromAnyProc(Jim_Interp *interp, Jim_Obj *objPtr) {
        // shimmer into a list, then iterate
        int nrows; Jim_Obj *rowObj0;
        nrows = Jim_ListLength(interp, objPtr);
        __ENSURE(nrows > 0);
        __ENSURE_OK(Jim_ListIndex(interp, objPtr, 0, &rowObj0, false));
        int ncols = Jim_ListLength(interp, rowObj0);
        __ENSURE(ncols > 0);

        matd_t *mat = matd_create(nrows, ncols);
        for (int row = 0; row < nrows; row++) {
            Jim_Obj *rowObj;
            __ENSURE_OK(Jim_ListIndex(interp, objPtr, row, &rowObj, false));
            int rowCols = Jim_ListLength(interp, rowObj);
            __ENSURE(rowCols == ncols);
            for (int col = 0; col < ncols; col++) {
                Jim_Obj *elObj;
                __ENSURE_OK(Jim_ListIndex(interp, rowObj, col, &elObj, false));
                __ENSURE_OK(Jim_GetDouble(interp, elObj, &MATD_EL(mat, row, col)));
            }
        }
        objPtr->typePtr = &matd_ObjType;
        objPtr->internalRep.ptr = mat;
        return JIM_OK;
    }
    Jim_ObjType matd_ObjType = (Jim_ObjType) {
        .name = "matd_t*",
        .freeIntRepProc = matd_freeIntRepProc,
        .dupIntRepProc = matd_dupIntRepProc,
        .updateStringProc = matd_updateStringProc,
        /* .setFromAnyProc = matd_setFromAnyProc, */
    };
}
$cc argtype matd_t* {
    __ENSURE_OK(matd_setFromAnyProc(interp, $obj));
    matd_t* $argname;
    $argname = (matd_t*) $obj->internalRep.ptr;
}
$cc rtype matd_t* {
    $robj = Jim_NewObj(interp);
    $robj->bytes = NULL;
    $robj->typePtr = &matd_ObjType;
    $robj->internalRep.ptr = $rvalue;
}

$cc proc computeNormalizer {int nPoints float points[][2]} matd_t* {
    double cx = 0, cy = 0;
    for (int i = 0; i < nPoints; i++) {
        cx += points[i][0]; cy += points[i][1];
    }
    cx /= nPoints; cy /= nPoints;

    double avgDist = 0;
    for (int i = 0; i < nPoints; i++) {
        double dx = points[i][0] - cx;
        double dy = points[i][1] - cy;
        avgDist += sqrt(dx*dx + dy*dy);
    }
    avgDist /= nPoints;

    double scale = sqrt(2.0) / avgDist;

    matd_t *normalizer = matd_create(3, 3);
    MATD_EL(normalizer, 0, 0) = scale;
    MATD_EL(normalizer, 1, 1) = scale;
    MATD_EL(normalizer, 2, 2) = 1.0;
    MATD_EL(normalizer, 0, 2) = -scale * cx;
    MATD_EL(normalizer, 1, 2) = -scale * cy;

    return normalizer;
}

$cc code {
    static void homographyProject(const matd_t *H, double x, double y, double *ox, double *oy)
    {
        double xx = MATD_EL(H, 0, 0)*x + MATD_EL(H, 0, 1)*y + MATD_EL(H, 0, 2);
        double yy = MATD_EL(H, 1, 0)*x + MATD_EL(H, 1, 1)*y + MATD_EL(H, 1, 2);
        double zz = MATD_EL(H, 2, 0)*x + MATD_EL(H, 2, 1)*y + MATD_EL(H, 2, 2);

        *ox = xx / zz;
        *oy = yy / zz;
    }
}

# Takes a list of at least 4 point pairs (model -> image) like
#
# [list \
#   [list x0 y0 u0 v0]] \
#   [list x1 y1 u1 v1] \
#   [list x2 y2 u2 v2] \
#   [list x3 y3 u3 v3]]
#
# Returns a 3x3 homography that maps model (x, y) to image (u, v)
# (using homogeneous coordinates).
$cc proc estimateHomographyImpl {int nPointPairs float[][4] pointPairs} matd_t* {
    float xys[nPointPairs][2];
    float uvs[nPointPairs][2];
    for (int i = 0; i < nPointPairs; i++) {
        xys[i][0] = pointPairs[i][0]; xys[i][1] = pointPairs[i][1];
        uvs[i][0] = pointPairs[i][2]; uvs[i][1] = pointPairs[i][3];
    }

    // Compute a similarity transformation T that normalizes model
    // points.
    matd_t *T = computeNormalizer(nPointPairs, xys);

    // Compute a similarity transformation T' that normalizes image
    // points.
    matd_t *T_ = computeNormalizer(nPointPairs, uvs);

    // Apply DLT to obtain a homography H.

    matd_t *A = matd_create(2*nPointPairs, 9);
    for (int i = 0; i < nPointPairs; i++) {
        double x, y;
        homographyProject(T, xys[i][0], xys[i][1], &x, &y);
        double u, v;
        homographyProject(T_, uvs[i][0], uvs[i][1], &u, &v);

        double row0[9] = {x, y, 1, 0, 0, 0, -u*x, -u*y, -u};
        double row1[9] = {0, 0, 0, x, y, 1, -v*x, -v*y, -v};

        for (int j = 0; j < 9; j++) {
            MATD_EL(A, 2*i, j) = row0[j];
            MATD_EL(A, 2*i+1, j) = row1[j];
        }
    }

    matd_svd_t svd = matd_svd_flags(A, MATD_SVD_NO_WARNINGS);
    matd_destroy(A);

    // H' = V[-1].reshape(3, 3)
    // H' /= H'[2, 2]
    matd_t *H_ = matd_create(3, 3);
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            MATD_EL(H_, i, j) = MATD_EL(svd.V, 3*i+j, svd.V->ncols-1);
        }
    }
    matd_destroy(svd.U);
    matd_destroy(svd.S);
    matd_destroy(svd.V);

    matd_scale_inplace(H_, 1.0 / MATD_EL(H_, 2, 2));

    // Set H = inv(T_) * H' * T.
    matd_t *H = matd_op("M^-1 * M * M", T_, H_, T);
    matd_destroy(T);
    matd_destroy(T_);
    matd_destroy(H_);
    return H;
}
$cc proc applyHomography {matd_t* H double[2] xy} Jim_Obj* {
    double out[2];
    homography_project(H, xy[0], xy[1], &out[0], &out[1]);

    Jim_Obj* retObjs[2] = { Jim_NewDoubleObj(interp, out[0]), Jim_NewDoubleObj(interp, out[1]) };
    return Jim_NewListObj(interp, retObjs, 2);
}
$cc proc matdMul {matd_t* a matd_t* b} matd_t* {
    return matd_multiply(a, b);
}
$cc endcflags ./vendor/apriltag/libapriltag.so
set matLib [$cc compile]
Claim the calibration matLib is $matLib

# HACK: wrapper because we have to give the array length as a separate
# arg (at least for now).
fn estimateHomography {pointPairs} {
    $matLib estimateHomographyImpl [llength $pointPairs] $pointPairs
}
Claim the calibration estimateHomography is [fn estimateHomography]


set ROWS 3
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `c` and `p` which are model points
# (x, y). Tags with isPrintedTag will get projected to PostScript
# points and printed; tags with isProjectedTag will get projected to
# Vulkan points and rendered on projector.
set UNIT_MODEL [apply {{ROWS COLS} {
    set UNIT_MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad [expr {$tagSideLength / 2}]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              c [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              p [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set UNIT_MODEL $id $modelTag
        }
    }
    return $UNIT_MODEL
}} $ROWS $COLS]
Claim the calibration unit model is $UNIT_MODEL

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 2 == 0}] ;# for checkerboard
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    return [expr {![isPrintedTag $id]}]
}
Claim the calibration isProjectedTag is [fn isProjectedTag]
Claim the calibration isPrintedTag is [fn isPrintedTag]

fn isVersionTag {id} {
    if {![isProjectedTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 4 == 1}] ;# for checkerboard
}
# Takes a dictionary of tag ID => {p, c} and rotates version tags
# according to version.
fn versionizeTags {tags version} {
    foreach id [dict keys $tags] {
        if {![isVersionTag $id]} {
            continue
        }
        # This is a version tag. Rotate it.
        set p [dict get $tags $id p]
        set rotatedCorners [list]
        for {set i 0} {$i < 4} {incr i} {
            lappend rotatedCorners [lindex $p [expr {($i + $version) % 4}]]
        }
        dict set tags $id p $rotatedCorners
    }
    return $tags
}

namespace import ::math::mean
fn meanPoseDifference {pose1 pose2} {
    set tags1 [dict get $pose1 tags]
    set tags2 [dict get $pose2 tags]

    set diffsum 0.0
    set ndiffs 0
    dict for {id tag} $tags1 {
        # We cheat and only count printed tags so we don't have to
        # deal with versioning.
        if {![isPrintedTag $id]} { continue }
        if {![dict exists $tags2 $id]} { continue }

        lassign [dict get $tag c] x1 y1
        lassign [dict get $tags2 $id c] x2 y2
        set diffsum [expr {$diffsum + sqrt(($x1 - $x2)*($x1 - $x2) + ($y1 - $y2)*($y1 - $y2))}]
        incr ndiffs
    }
    if {$ndiffs == 0} { return Inf }
    return [expr {$diffsum / $ndiffs}]
}
Claim the calibration meanPoseDifference is [fn meanPoseDifference]

fn lsort-indices {itemL} {
    set pairL [list]
    foreach item $itemL {
      lappend pairL [list $item [llength $pairL]]
    }
    set indexL [list]
    foreach pair [lsort -index 0 -real $pairL] {
      lappend indexL [lindex $pair 1]
    }
    set indexL
}

set CALIBRATION_POSES_MAX 10

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     the image library is /imageLib/ &\
     the printed calibration tag size is /printedSideLengthMm/ mm &\
     /someone/ wishes to calibrate {

    set calibrationId [clock milliseconds]

    # VERY IMPORTANT: disable autofocus forever.
    catch { exec v4l2-ctl --device=$camera --set-ctrl=focus_automatic_continuous=0 }

    if {$cameraWidth < 1920} {
        Retract! /someone/ wishes $::thisNode uses camera $camera \
            with width $cameraWidth height $cameraHeight
        Assert! $this wishes $::thisNode uses camera $camera with width 1920 height 1080
        # TODO: restore old camera resolution later
    }

    package require linalg
    namespace import ::math::linearalgebra::scale

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    # UNIT_MODEL's 2D coordinates have inner tag side length of 1.0:
    # scale it to real-world coordinates.
    set baseModel [dict create]
    dict for {id tag} $UNIT_MODEL {
        dict set baseModel $id c [scale $printedSideLengthM [dict get $tag c]]
        dict set baseModel $id p [scale $printedSideLengthM [dict get $tag p]]
    }

    # A list of pose dictionaries. Each dictionary has entries `model`
    # and `H_modelToDisplay` ('prewarp' homography from model plane to
    # projector plane) and `tags` (tag ID => dictionary of tag
    # detection info from camera and AprilTag detector) and
    # `displayResolution` and `cameraResolution` and `tagsSize`.
    Hold! (non-capturing) (on calibration) seenPoses \
        { Claim the calibration last-seen poses are [list] }
    set SEEN_POSES_MAX 3

    # The poses to use for actual calibration at the end. We'll want
    # at least 10 poses to do ultimate calibration+refinement.
    Hold! (non-capturing) (on calibration) poses \
        { Claim the calibration poses are [list] }


    HoldStatement! cycleTime [list $this claims the calibration cycle time is 0]

    set board [list $this board]
    set boardWritableImage [list $board writable image]
    Wish the GPU creates writable image $boardWritableImage with width 1024 height 1024
    Claim $board has writable image $boardWritableImage

    package require linalg
    namespace import ::math::linearalgebra::scale \
        ::math::linearalgebra::add ::math::linearalgebra::sub

    fn innerToOuter {center corner {s 1.66666667}} {
        set r [sub $corner $center]
        return [add $center [scale $s $r]]
    }

    set topLeftTag [dict get $baseModel [expr {48600 + 0*$COLS + 0}]]
    set topRightTag [dict get $baseModel [expr {48600 + 0*$COLS + $COLS-1}]]
    set bottomRightTag [dict get $baseModel [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}]]
    set bottomLeftTag [dict get $baseModel [expr {48600 + ($ROWS-1)*$COLS + 0}]]

    set boardBorderScale [expr {1.66666667 * 2}] ;# 2x the inner->outer distance
    set boardTopLeft [innerToOuter [dict get $topLeftTag c] [lindex [dict get $topLeftTag p] 3] $boardBorderScale]
    set boardTopRight [innerToOuter [dict get $topRightTag c] [lindex [dict get $topRightTag p] 2] $boardBorderScale]
    set boardBottomRight [innerToOuter [dict get $bottomRightTag c] [lindex [dict get $bottomRightTag p] 1] $boardBorderScale]
    set boardBottomLeft [innerToOuter [dict get $bottomLeftTag c] [lindex [dict get $bottomLeftTag p] 0] $boardBorderScale]

    set boardCorners [list $boardTopLeft $boardTopRight $boardBottomRight $boardBottomLeft]
    set boardToClipSpaceCorners \
        [list [list {*}$boardTopLeft -1 -1] \
             [list {*}$boardTopRight 1 -1] \
             [list {*}$boardBottomRight 1 1] \
             [list {*}$boardBottomLeft -1 1]]
    set boardWritableImageToClipSpace [estimateHomography $boardToClipSpaceCorners]
    Claim $board has writable image projection $boardWritableImageToClipSpace

    # Project calibration tags based on the current model-to-display
    # homography (which gets dynamically updated as you move the board
    # around):
    When the GPU writable image library is /gpuWritableLib/ &\
         the GPU creates writable image $boardWritableImage as /wi/ &\
         the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /anything/ timestamp /anything/ &\
         the calibration poses are /calibrationPoses/ &\
         the calibration cycle time is /cycleTime/ {

        package require linalg
        namespace import ::math::linearalgebra::scale \
            ::math::linearalgebra::add ::math::linearalgebra::sub

        # White backdrop on board:
        Wish the GPU draws pipeline "fillTriangle" onto image $boardWritableImage \
            with arguments [list {{1 0 0} {0 1 0} {0 0 1}} \
                                [list -1 -1] [list 1 -1] [list 1 1] [list 1 1 1 1]] \
            layer 99
        Wish the GPU draws pipeline "fillTriangle" onto image $boardWritableImage \
            with arguments [list {{1 0 0} {0 1 0} {0 0 1}} \
                                [list -1 -1] [list 1 1] [list -1 1] [list 1 1 1 1]] \
            layer 99

        # Draw AprilTags on board:
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} { continue }

            set modelInnerCorners [lreverse [dict get $modelTag p]]
            set modelCenter [dict get $modelTag c]

            set modelOuterCorners [lmap modelInnerCorner $modelInnerCorners {
                innerToOuter $modelCenter $modelInnerCorner
            }]
            Wish to draw an AprilTag onto $board with \
                id $id corners $modelOuterCorners layer 100
        }

        # White backdrop across whole projector area to hopefully make
        # the projected tags pop out more:
        set surfaceToClip {{1 0 0} {0 1 0} {0 0 1}}
        set p0 [list -1 -1]
        set p1 [list 1 -1]
        set p2 [list 1 1]
        set p3 [list -1 1]
        set color {1 1 1 1}
        Wish the GPU draws pipeline "fillTriangle" with arguments \
            [list $surfaceToClip $p1 $p2 $p3 $color] layer 99
        Wish the GPU draws pipeline "fillTriangle" with arguments \
            [list $surfaceToClip $p0 $p1 $p3 $color] layer 99

        # Now draw the board image (which has the projected tags) onto
        # the display:

        # Transform corners from model-space into display-space:
        lassign [lmap p $boardCorners {
            $matLib applyHomography $H_modelToDisplay $p
        }] a b c d

        set displayToClip \
            [list [list [expr {2.0/$displayWidth}] 0 -1] \
                 [list 0 [expr {2.0/$displayHeight}] -1] \
                 [list 0 0 1]]

        set wim [$gpuWritableLib gpuImage $wi]
        Wish the GPU draws pipeline "image" with arguments \
            [list [list $displayWidth $displayHeight] \
                 $displayToClip \
                 $wim $a $b $c $d] \
            layer 100

        set sides \
            [list \
                 [list $boardTopLeft $boardTopRight top 0] \
                 [list $boardBottomRight $boardBottomLeft top 3.14159] \
                 [list $boardBottomLeft $boardTopLeft top [/ 3.14159 2]] \
                 [list $boardTopRight $boardBottomRight top [/ -3.14159 2]]]

        set text "[llength $calibrationPoses]/$CALIBRATION_POSES_MAX poses ([expr {round($cycleTime*1000)}] ms)"
        foreach p {add norm sub scale matmul
            getelem transpose determineSVD shape mkIdentity show
            solvePGauss crossproduct getcol setcol unitLengthVector det
        } {
            namespace import ::math::linearalgebra::$p
        }
        foreach side $sides {
            lassign $side start end anchor radians
            set modelPosition [scale 0.5 [add $start $end]]

            Wish to draw text onto $board with text $text radians $radians \
                position $modelPosition \
                anchor $anchor color black layer 100 scale 0.015
        }
    }

    # This is made a function so it can also be called by the Web page
    # when the user drags the slider to adjust projected tag scale.
    fn HoldDefaultModel! {scale} {
        # Default model: just makes the tags fill most of the middle
        # of the projector area.
        set tagSideLengthPixels [::math::min $($displayWidth/($COLS * ($tagOuterLength + $pad))) \
                                     $($displayHeight/($ROWS * ($tagOuterLength + $pad)))]
        set tagSideLengthPixels [expr {$tagSideLengthPixels * $scale}]

        # TODO: Center this on the projector area.
        set H_modelToDisplay [estimateHomography [subst {
            {$printedSideLengthM $printedSideLengthM $tagSideLengthPixels $tagSideLengthPixels}
            {$printedSideLengthM 0 $tagSideLengthPixels 0}
            {0 $printedSideLengthM 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Hold! H_modelToDisplay {
            # Default model and version: nothing rotated.
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $baseModel version -1 timestamp [expr {[clock milliseconds] / 1000.0}]
        }
    }
    Claim the calibration HoldDefaultModel! is [fn HoldDefaultModel!]
    HoldDefaultModel! 1.0

    On unmatch {
        Hold! H_modelToDisplay {}
        Hold! exposure {
            Wish camera $camera uses exposure time auto us
        }
    }

    # HACK: We match the camera frame image first so that we have a
    # handle on it (it's retained for 400ms but deindexed immediately,
    # so we can't query for it later) when the tag detection comes in
    # some tens of ms later, so we can save the frame image for
    # debugging.
    When camera $camera has frame /frame/ at timestamp /timestamp/ &\
         /detector/ detects tags /tags/ on camera $camera \
             at timestamp /timestamp/ in time /something/ &\
         the calibration model-to-display homography is /H_modelToDisplay/ with \
             model /model/ version /version/ timestamp /hTimestamp/ {

        if {[lindex $detector 1] ne "entire-frame"} { return }

        # This runs every frame, looks at the detected tags (both
        # projected and printed), and updates the H_modelToDisplay
        # such that the projected tags should sit in the middle of the
        # calibration board.

        set startTime [clock microseconds]

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $printedTag p] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        set printedCalibrationBoard [list {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomLeft]]
        set boardMinX 100000; set boardMinY 100000
        set boardMaxX -100000; set boardMaxY -100000
        foreach {cornerX cornerY} $printedCalibrationBoard {
            if {$cornerX < $boardMinX} { set boardMinX $cornerX }
            if {$cornerY < $boardMinY} { set boardMinY $cornerY }
            if {$cornerX > $boardMaxX} { set boardMaxX $cornerX }
            if {$cornerY > $boardMaxY} { set boardMaxY $cornerY }
        }

        # We only count projected tags that are inside the board.
        set projectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }

            lassign [dict get $tag c] x y
            if {$x > $boardMinX && $x < $boardMaxX &&
                $y > $boardMinY && $y < $boardMaxY} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # Check the rotation of a version tag to figure out the
        # version of what the camera saw, unless it's version -1.
        if {$version != -1} {
            # Find any version tag. If none were detected, then abort
            # and wait until a later frame.
            dict for {id tag} $projectedTags {
                if {[isVersionTag $id]} {
                    set versionTagId $id
                    break
                }
            }
            if {![info exists versionTagId]} { return }

            set getTagAngle {{tag} {
                set p [dict get $tag p]
                expr {atan2(-1 * ([lindex $p 1 1] - [lindex $p 0 1]),
                            [lindex $p 1 0] - [lindex $p 0 0])}
            }}
            set versionTagAngle [apply $getTagAngle [dict get $projectedTags $versionTagId]]

            # Compare angle to angle of any other projected tag.
            if {[dict size $projectedTags] < 2} { return }
            dict for {id projectedTag} $projectedTags {
                if {![isVersionTag $id]} {
                    set otherTagAngle [apply $getTagAngle $projectedTag]
                    break
                }
            }
            if {![info exists otherTagAngle]} { return }

            set versionAngle [expr {$versionTagAngle - $otherTagAngle}]
            # Rotations corresponding to versions 0, 1, 2, 3:
            set possibleVersions \
                [list 1  0 \
                      0  1 \
                     -1  0 \
                      0 -1]
            # Which of the possibleVersions is versionAngle closest to?
            set detectedVersion [lindex [lsort-indices [lmap {x y} $possibleVersions {
                expr {sqrt(($x - cos($versionAngle))**2 + ($y - sin($versionAngle))**2)}
            }]] 0]

            # If the detected version does not correspond to version mod 4,
            # then we should abort and wait until a later frame.
            set expectedVersion [expr {$version % 4}]
            if {$detectedVersion != $expectedVersion} {
                return
            }
        }

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $projectedTag p] {
                    set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }

        # puts "point pairs (camera -> display): {$projectedPointPairs}"
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]
        if {abs([::math::linearalgebra::det $H_cameraToDisplay]) < 0.001} {
            # Garbage homography that just shrinks the points way down
            # (https://stackoverflow.com/questions/10972438/detecting-garbage-homographies-from-findhomography-in-opencv).
            # It's sort of 'overfitted' and just has a big y-intercept
            # and will break everything if we let it through. Skip.
            return
        }

        # Update H_modelToDisplay to project the tags into the right
        # spots on the board next frame.
        set nextH_modelToDisplay [$matLib matdMul $H_cameraToDisplay $H_modelToCameraViaPs]
        set nextTimestamp [expr {[clock milliseconds] / 1000.0}]
        set nextVersion [+ $version 1]
        set nextModel [versionizeTags $baseModel $nextVersion]
        HoldStatement! H_modelToDisplay \
            [list $this claims the calibration model-to-display homography \
                 is $nextH_modelToDisplay with \
                 model $nextModel version $nextVersion timestamp $nextTimestamp]
        HoldStatement! cycleTime \
            [list $this claims the calibration cycle time is $($nextTimestamp - $hTimestamp)]

        # Should we record the points we just saw as a calibration
        # pose?

        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }

        # We can do an error check here. H_modelToCameraViaPs was
        # derived above from printed tags -- we should be able to run
        # _projected_ tags through it and compare the coordinates to
        # the actual detection coordinates. If there's too much error,
        # we won't record this as a calibration pose.
        set totalError 0.0
        dict for {id projectedTag} $projectedTags {
            foreach modelCorner [dict get $model $id p] \
                cameraCorner [dict get $projectedTag p] {
                    lassign $cameraCorner cx cy
                    # Predicted camera x and y.
                    lassign [$matLib applyHomography $H_modelToCameraViaPs $modelCorner] px py
                    set dx [- $cx $px]; set dy [- $cy $py]
                    set err [expr {$dx*$dx + $dy*$dy}]
                    set totalError [+ $totalError $err]
            }
        }
        set poseRmse [expr {sqrt($totalError / ([llength $projectedTags] * 4))}]
        if {$poseRmse > 5} {
            puts "Pose has too-high rmse ($poseRmse); skipping"
            return
        }

        set pose [dict create \
                      model $model version $version \
                      camera $camera \
                      cameraWidth $cameraWidth cameraHeight $cameraHeight \
                      display $display \
                      displayWidth $displayWidth displayHeight $displayHeight \
                      tagSize $printedSideLengthM \
                      H_modelToDisplay $H_modelToDisplay \
                      rmse $poseRmse \
                      tags [dict merge $printedTags $projectedTags]]

        set seenPoses [dict get [lindex [Query! /someone/ claims the calibration last-seen poses are /seenPoses/] 0] seenPoses]
        lappend seenPoses $pose
        if {[llength $seenPoses] > $SEEN_POSES_MAX} {
            set seenPoses [lreplace $seenPoses 0 0]
        }
        HoldStatement! (on calibration) seenPoses \
            [list $this claims the calibration last-seen poses are $seenPoses]

        # Next, we check if projected tag corners have been pretty
        # stable in the last few frames.

        if {[llength $seenPoses] < 3} {
            return
        }

        # If the corners have moved a lot since last frame, we're not
        # stable enough and shouldn't record this as a calibration
        # pose.
        foreach seenPose [lrange $seenPoses 0 end-1] {
            # Decreasing this threshold to 1 helps with data
            # accuracy. TODO: Use an _older_ frame?
            if {[meanPoseDifference $pose $seenPose] > 5} {
                return
            }
        }

        puts "WOULD APPEND CALIBRATION ([- [clock microseconds] $startTime] us)..."

        # If the corners have _not_ moved a lot since last _saved_
        # calibration pose, this isn't different enough to be a good
        # calibration pose to save.
        set calibrationPoses [dict get [lindex [Query! the calibration poses are /calibrationPoses/] 0] calibrationPoses]
        if {[llength $calibrationPoses] > 0} {
            set prevCalibrationPose [lindex $calibrationPoses end]
            if {[meanPoseDifference $pose $prevCalibrationPose] < 50} {
                return
            }
        }

        # Save the pose / camera image to a jpeg (for debugging purposes)
        exec mkdir -p "$::env(HOME)/folk-calibration-poses"
        set imageName "pose-$calibrationId-[llength $calibrationPoses].jpeg"
        $imageLib saveAsJpeg $frame "$::env(HOME)/folk-calibration-poses/$imageName"
        dict set pose imageName $imageName

        # OK, let's save this calibration pose.
        lappend calibrationPoses $pose
        puts "APPENDED CALIBRATION TO POSES ([llength $calibrationPoses] poses collected)"
        HoldStatement! (on calibration) poses \
            [list $this claims the calibration poses are $calibrationPoses]

        # If we have enough poses, then stop the calibration process
        # (retract the printed side length?) and do a calibration. :-)
        if {[llength $calibrationPoses] >= $CALIBRATION_POSES_MAX} {
            puts "READY CALIBRATION POSES!"

            catch { exec mkdir "$::env(HOME)/folk-live" }
            catch {exec rm "$::env(HOME)/folk-live/folk-calibration-output.txt"}

            set fd [open "$::env(HOME)/folk-live/folk-calibration-poses.txt" w]
            puts $fd $calibrationPoses; close $fd

            # Destroy the old calibration and trigger a new one.
            HoldStatement! (on calibration) calibration {}

            Retract! /someone/ wishes to calibrate
        }
    }
}

fn processHomography {H} {
    package require linalg
    namespace import ::math::linearalgebra::getelem
    namespace import ::math::linearalgebra::sub

    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}


# Uses Zhang's calibration technique
# (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)
# to calibrate a projector or camera given a known 2D planar pattern
# and multiple observed poses.
#
# Returns intrinsic matrix for the camera/projector, which explains
# how 3D real-world coordinates get projected to 2D coordinates by
# that device. (The intrinsic matrix can be used with an AprilTag
# detector to get real-world coordinates for each AprilTag.)
#
# Arguments:
#         width  width of camera or projector in pixels
#         height height of camera or projector in pixels
#         Hs     a list of N homographies from camera/projector image
#                plane -> model plane (for N different poses).
fn zhangUnrefinedCalibrate {name width height Hs} {
    package require linalg
    namespace import ::math::linearalgebra::shape \
        ::math::linearalgebra::transpose \
        ::math::linearalgebra::matmul \
        ::math::linearalgebra::determineSVD \
        ::math::linearalgebra::mkIdentity \
        ::math::linearalgebra::solvePGauss \
        ::math::linearalgebra::getcol \
        ::math::linearalgebra::norm \
        ::math::linearalgebra::scale \
        ::math::linearalgebra::crossproduct \
        ::math::linearalgebra::add \
        ::math::linearalgebra::sub

    # Try to solve for the camera intrinsics:

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V
    set b [lindex [transpose $V] [lindex [lsort-indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }

    set fx $alpha; set fy $beta
    set cx $u0; set cy $v0
    set s $gamma
    puts "   Focal Length: \[ $fx $fy ]"
    puts "Principal Point: \[ $cx $cy ]"
    puts "           Skew: \[ $s ] "

    # Intrinsic matrix:
    set A [subst {
        {$fx  $s   $cx}
        {0    $fy  $cy}
        {0    0    1}
    }]
    set Ainv [solvePGauss $A [mkIdentity 3]]

    set extrinsics [lmap H $Hs {
        set h1 [getcol $H 0]
        set h2 [getcol $H 1]
        set h3 [getcol $H 2]
        set lambda [/ 1.0 [norm [matmul $Ainv $h1]]]

        set r1 [scale $lambda [matmul $Ainv $h1]]
        set r2 [scale $lambda [matmul $Ainv $h2]]
        set r3 [crossproduct $r1 $r2]
        set R [transpose [list $r1 $r2 $r3]]

        set t [scale $lambda [matmul $Ainv $h3]]

        # Refine R into a better rotation matrix (reorthogonalize)
        # using SVD.
        lassign [determineSVD $R] U S V
        set R [matmul $U [transpose $V]]

        dict create R $R t $t
    }]

    # Initialize distortion terms k1 and k2 to 0 -- they get figured
    # out during nonlinear refinement.
    set intrinsics [dict create \
                        width $width height $height \
                        fx $fx fy $fy cx $cx cy $cy s $s \
                        k1 0 k2 0]
    return [dict create \
                name $name \
                intrinsics $intrinsics \
                extrinsics $extrinsics]
}

fn setCameraToProjectorExtrinsics {calibrationVar calibrationPoses} {
    # Use the "Kabsch algorithm" (https://nghiaho.com/?page_id=671;
    # https://zpl.fi/aligning-point-patterns-with-kabsch-umeyama-algorithm/)
    # to find the rotation and translation from 3D camera-space to 3D
    # projector-space.

    upvar $calibrationVar calibration

    # Let's take all the points for which we have a corresponding
    # camera frame point and projector frame point.
    set cameraFramePoints [list]
    set projectorFramePoints [list]

    for {set i 0} {$i < [llength $calibrationPoses]} {incr i} {
        set calibrationPose [lindex $calibrationPoses $i]
        
        set Rc [dict get [lindex [dict get $calibration camera extrinsics] $i] R]
        set tc [dict get [lindex [dict get $calibration camera extrinsics] $i] t]

        set Rp [dict get [lindex [dict get $calibration projector extrinsics] $i] R]
        set tp [dict get [lindex [dict get $calibration projector extrinsics] $i] t]

        # TODO: Try using pose estimation instead?
        dict for {id tag} [dict get $calibrationPose model] {
            if {![isProjectedTag $id]} { continue }
            set k 0
            foreach v [dict get $tag p] {
                incr k
                lappend v 0.0

                set vc [add [matmul $Rc $v] $tc]
                set vp [add [matmul $Rp $v] $tp]

                lappend cameraFramePoints $vc
                lappend projectorFramePoints $vp
            }
        }
    }

    # puts "cameraFramePoints = \[[join [lmap p $cameraFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"
    # puts "projectorFramePoints = \[[join [lmap p $projectorFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"

    set n [llength $cameraFramePoints]

    set vcsum {0 0 0}
    foreach vc $cameraFramePoints { set vcsum [add $vcsum $vc] }
    set cameraFramePointsCentroid [scale [/ 1.0 $n] $vcsum]

    set vpsum {0 0 0}
    foreach vp $projectorFramePoints { set vpsum [add $vpsum $vp] }
    set projectorFramePointsCentroid [scale [/ 1.0 $n] $vpsum]

    set H [matmul [transpose [sub $cameraFramePoints \
                                  [lrepeat $n $cameraFramePointsCentroid]]] \
               [sub $projectorFramePoints \
                    [lrepeat $n $projectorFramePointsCentroid]]]

    lassign [determineSVD $H] U S V
    set R [matmul $V [transpose $U]]
    set t [sub $projectorFramePointsCentroid \
               [matmul $R $cameraFramePointsCentroid]]

    dict set calibration R_cameraToProjector $R
    dict set calibration t_cameraToProjector $t
}

# End-to-end calibrates a camera-projector pair. calibrationPoses is
# a list of N pose dictionaries. Each pose dictionary includes `tags`
# from a camera detection, `model` with coordinates in meters,
# `H_modelToDisplay`.
fn unrefinedCalibrateCameraAndProjector {calibrationPoses} {
    package require linalg
    namespace import ::math::linearalgebra::det
    namespace import ::math::linearalgebra::scale

    # Just used to get metadata about cam/proj:
    set pose0 [lindex $calibrationPoses 0]

    # First, calibrate the camera. "Using only the corners from
    # printed markers xb and their detected corners xc, [...]
    # calibrate the camera with no difficulties using Zhang’s method."
    set i 0
    set Hs_modelToCamera [lmap pose $calibrationPoses {
        # Pairs of (camera coordinates, model coordinates).
        set model [dict get $pose model]
        set tags [dict get $pose tags]
        set pointPairs [list]
        dict for {id cameraTag} $tags {
            if {![isPrintedTag $id]} continue
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $cameraTag p] {
                    lappend pointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }

        set H [estimateHomography $pointPairs]
        if {[det $H] < 0} {
            set H [scale -1 $H]
        }
        set H
    }]
    puts "Zhang calibrate camera:"
    puts "========"
    set cameraName [dict get $pose0 camera]
    set cameraWidth [dict get $pose0 cameraWidth]
    set cameraHeight [dict get $pose0 cameraHeight]
    set cameraCalibration [zhangUnrefinedCalibrate \
                               $cameraName $cameraWidth $cameraHeight \
                               $Hs_modelToCamera]
    puts "\n======================\n"

    # Second, calibrate the projector.
    set i 0
    set Hs_modelToDisplay [lmap pose $calibrationPoses {
        set H_modelToDisplay [dict get $pose H_modelToDisplay]

        set pointPairs [list]
        set model [dict get $pose model]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} continue
            foreach modelCorner [dict get $modelTag p] {
                set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                lappend pointPairs [list {*}$modelCorner {*}$displayCorner]
            }
        }

        if {[det $H_modelToDisplay] < 0} {
            set H_modelToDisplay [scale -1 $H_modelToDisplay]
        }
        set H_modelToDisplay
    }]
    puts "Zhang calibrate projector:"
    puts "========"
    set projectorName [dict get $pose0 display]
    set projectorWidth [dict get $pose0 displayWidth]
    set projectorHeight [dict get $pose0 displayHeight]
    set projectorCalibration [zhangUnrefinedCalibrate \
                                  $projectorName \
                                  $projectorWidth $projectorHeight \
                                  $Hs_modelToDisplay]
    puts "\n======================\n"

    set calibration [dict create \
                         camera $cameraCalibration \
                         projector $projectorCalibration]
    setCameraToProjectorExtrinsics calibration $calibrationPoses
    return $calibration
}

When the calibration poses are /calibrationPoses/ &\
     /nobody/ claims the calibration is /anything/ &\
     the calibration refiner is /refineCalibration/ {

    if {[llength $calibrationPoses] < $CALIBRATION_POSES_MAX} {
        return
    }

    set calibration [unrefinedCalibrateCameraAndProjector $calibrationPoses]
    puts "======== Unrefined calibration ========="
    puts $calibration
    puts ""

    set calibration [{*}$refineCalibration \
                         [fn isPrintedTag] [fn isProjectedTag] $matLib \
                         $calibrationPoses $calibration]
    puts "======== Refined calibration intrinsics ========="

    puts "."
    puts "======== Refined calibration ========="
    puts $calibration
    puts "."

    When the printed calibration tag size is /tagSizeMm/ mm {
        puts "======== Reproject pose 0 ========="
        set pose [lindex $calibrationPoses 0]
        set tagSize [expr {$tagSizeMm / 1000.0}]
        set cameraIntrinsics [dict get $calibration camera intrinsics]
        set cameraWidth [dict get $calibration camera intrinsics width]
        set cameraHeight [dict get $calibration camera intrinsics height]
        set projectorIntrinsics [dict get $calibration projector intrinsics]
        set projectorWidth [dict get $calibration projector intrinsics width]
        set projectorHeight [dict get $calibration projector intrinsics height]
        dict for {id det} [dict get $pose tags] {
            # Look through all the projected tags that we detected on
            # camera in this pose.
            if {![isProjectedTag $id]} { continue }

            puts "Tag $id:"

            set p [dict get $det p] ;# Camera detected corners.

            # Pose-estimate this tag.
            set tagPose [baseEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $p]
            set tagPose [servoingEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $tagPose $p]

            set r [expr {$tagSize / 2}]
            set tagVertices \
                [list [list [- $r]    $r  0] \
                     [list     $r     $r  0] \
                     [list     $r  [- $r] 0] \
                     [list  [- $r] [- $r] 0]]
            # Move the pose to camera-space.
            set cameraVertices [lmap v $tagVertices {
                set R [dict get $tagPose R]; set t [dict get $tagPose t]
                add [matmul $R $v] $t
            }]

            # Move the pose to projector-space.
            set projectorVertices [lmap v $cameraVertices {
                set R [dict get $calibration R_cameraToProjector]
                set t [dict get $calibration t_cameraToProjector]
                add [matmul $R $v] $t
            }]

            # Downproject to the projector pixel plane.
            set modelTag [dict get $pose model $id]
            for {set i 0} {$i < 4} {incr i} {
                set modelCorner [lindex [dict get $modelTag p] $i]
                lassign [$matLib applyHomography [dict get $pose H_modelToDisplay] $modelCorner] px py
                puts [format "Corner $i (real)  : (%.3f %.3f)" $px $py]

                set v [lindex $projectorVertices $i]
                lassign [intrinsics project $projectorIntrinsics \
                             $projectorWidth $projectorHeight \
                             $v] rpx rpy
                puts [format "Corner $i (reproj): (%.3f %.3f)" $rpx $rpy]
            }
        }
    }

    HoldStatement! (on calibration) calibration \
        [list $this claims the calibration is $calibration]

    set fd [open "$::env(HOME)/folk-live/folk-calibration-output.txt" w]
    puts $fd $calibration; close $fd
}
