# calibrate.folk --
#
#     Implements camera-projector calibration: generate a calibration
#     pattern PDF, have the user measure its real-world dimension, run
#     iterative projector-camera process to get various poses of the
#     printed tags alongside projected tags, do linear fit and then
#     nonlinear refinement to find intrinsic and extrinsic parameters
#     for the camera and projector.
#
#     Closely based on the technique in Audet (2009):
#     http://www.ok.sc.e.titech.ac.jp/res/PCS/publications/procams2009.pdf
#

package require linalg

foreach p {add norm sub scale matmul
    getelem transpose determineSVD shape mkIdentity show
    solvePGauss crossproduct getcol setcol unitLengthVector det
} {
    namespace import ::math::linearalgebra::$p
}

set ROWS 3
set COLS 5
# The model is a dictionary whose keys are tag IDs and where each
# value is a dictionary with keys `c` and `p` which are model points
# (x, y). Tags with isPrintedTag will get projected to PostScript
# points and printed; tags with isProjectedTag will get projected to
# Vulkan points and rendered on projector.
set UNIT_MODEL [apply {{ROWS COLS} {
    set UNIT_MODEL [dict create]

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad [expr {$tagSideLength / 2}]
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            set id [expr {48600 + $row*$COLS + $col}]
            set modelX [expr {($tagOuterLength + $pad)*$col}]
            set modelY [expr {($tagOuterLength + $pad)*$row}]
            # Now modelX and modelY are the top-left outer corner of
            # the tag.
            set modelX [expr {$modelX + ($tagOuterLength - $tagSideLength)/2}]
            set modelY [expr {$modelY + ($tagOuterLength - $tagSideLength)/2}]
            # Now modelX and modelY are the top-left inner corner of
            # the tag.
            set modelTopLeft [list $modelX $modelY]
            set modelTopRight [list [+ $modelX $tagSideLength] $modelY]
            set modelBottomRight [list [+ $modelX $tagSideLength] [+ $modelY $tagSideLength]]
            set modelBottomLeft [list $modelX [+ $modelY $tagSideLength]]
            set modelTag [dict create \
                              c [scale 0.5 [add $modelTopLeft $modelBottomRight]] \
                              p [list $modelBottomLeft $modelBottomRight \
                                          $modelTopRight $modelTopLeft]]
            dict set UNIT_MODEL $id $modelTag
        }
    }
    return $UNIT_MODEL
}} $ROWS $COLS]
Claim the calibration unit model is $UNIT_MODEL

fn isCalibrationTag {id} { expr {$id >= 48600 && $id < 48600 + $ROWS*$COLS} }
fn isPrintedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 2 == 0}] ;# for checkerboard
}
fn isProjectedTag {id} {
    if {![isCalibrationTag $id]} { return false }
    return [expr {![isPrintedTag $id]}]
}
Claim the calibration isProjectedTag is [fn isProjectedTag]
Claim the calibration isPrintedTag is [fn isPrintedTag]

fn isVersionTag {id} {
    if {![isProjectedTag $id]} { return false }
    set idx [- $id 48600]
    return [expr {$idx % 4 == 1}] ;# for checkerboard
}
# Takes a dictionary of tag ID => {p, c} and rotates version tags
# according to version.
fn versionizeTags {tags version} {
    foreach id [dict keys $tags] {
        if {![isVersionTag $id]} {
            continue
        }
        # This is a version tag. Rotate it.
        set p [dict get $tags $id p]
        set rotatedCorners [list]
        for {set i 0} {$i < 4} {incr i} {
            lappend rotatedCorners [lindex $p [expr {($i + $version) % 4}]]
        }
        dict set tags $id p $rotatedCorners
    }
    return $tags
}

namespace import ::math::mean
fn meanPoseDifference {pose1 pose2} {
    set tags1 [dict get $pose1 tags]
    set tags2 [dict get $pose2 tags]

    set diffsum 0.0
    set ndiffs 0
    dict for {id tag} $tags1 {
        # We cheat and only count printed tags so we don't have to
        # deal with versioning.
        if {![isPrintedTag $id]} { continue }
        if {![dict exists $tags2 $id]} { continue }

        lassign [dict get $tag c] x1 y1
        lassign [dict get $tags2 $id c] x2 y2
        set diffsum [expr {$diffsum + sqrt(($x1 - $x2)*($x1 - $x2) + ($y1 - $y2)*($y1 - $y2))}]
        incr ndiffs
    }
    if {$ndiffs == 0} { return Inf }
    return [expr {$diffsum / $ndiffs}]
}
Claim the calibration meanPoseDifference is [fn meanPoseDifference]

fn lsort-indices {itemL} {
    set pairL [list]
    foreach item $itemL {
      lappend pairL [list $item [llength $pairL]]
    }
    set indexL [list]
    foreach pair [lsort -index 0 -real $pairL] {
      lappend indexL [lindex $pair 1]
    }
    set indexL
}

set CALIBRATION_POSES_MAX 10

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     the AprilTag detector maker is /makeAprilTagDetector/ &\
     the image library is /imageLib/ &\
     the calibration matLib is /matLib/ &\
     the calibration estimateHomography is /estimateHomography/ &\
     the printed calibration tag size is /printedSideLengthMm/ mm &\
     /someone/ wishes to calibrate {

    fn estimateHomography

    fn makeAprilTagDetector
    set calibrationTagDetector [makeAprilTagDetector "tagStandard52h13" 3]

    set calibrationId [clock milliseconds]

    # VERY IMPORTANT: disable autofocus forever.
    catch { exec v4l2-ctl --device=$camera --set-ctrl=focus_automatic_continuous=0 }

    if {$cameraWidth < 1920} {
        set camResults [Query! /someone/ wishes $::thisNode uses camera $camera with /...camOpts/]
        if {[llength $camResults] == 1} {
            set camOpts [dict get [lindex $camResults 0] camOpts]
            if {![dict exists $camOpts crop]} {
                Retract! /someone/ wishes $::thisNode uses camera $camera \
                    with width $cameraWidth height $cameraHeight
                Assert! $this wishes $::thisNode uses camera $camera \
                    with width 1920 height 1080
                # TODO: restore old camera resolution later
            }

        } else {
            puts stderr "calibrate: Warning: camera $camera has [llength $camResults] use wishes"
        }
    }

    package require linalg
    namespace import ::math::linearalgebra::scale

    set tagSideLength 1.0
    set tagOuterLength [expr {$tagSideLength * 10/6}]
    set pad $tagSideLength

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    # UNIT_MODEL's 2D coordinates have inner tag side length of 1.0:
    # scale it to real-world coordinates.
    set baseModel [dict create]
    dict for {id tag} $UNIT_MODEL {
        dict set baseModel $id c [scale $printedSideLengthM [dict get $tag c]]
        dict set baseModel $id p [scale $printedSideLengthM [dict get $tag p]]
    }

    # A list of pose dictionaries. Each dictionary has entries `model`
    # and `H_modelToDisplay` ('prewarp' homography from model plane to
    # projector plane) and `tags` (tag ID => dictionary of tag
    # detection info from camera and AprilTag detector) and
    # `displayResolution` and `cameraResolution` and `tagsSize`.
    Hold! -key last-seen-poses \
        Claim the calibration last-seen poses are [list]
    On unmatch { Hold! -key last-seen-poses {} }
    set SEEN_POSES_MAX 3

    # The poses to use for actual calibration at the end. We'll want
    # at least 10 poses to do ultimate calibration+refinement.
    Hold! -on calibration -key poses \
        Claim the calibration poses are [list]

    Hold! -key cycle-time \
        Claim the calibration cycle time is 0

    set board [list $this board]
    set boardCanvas [list $board canvas]
    Wish the GPU creates canvas $boardCanvas \
        with width $displayWidth height $displayHeight
    When the GPU has created canvas $boardCanvas with /...opts/ {
        Claim $board has canvas $boardCanvas with {*}$opts
    }

    package require linalg
    namespace import ::math::linearalgebra::scale \
        ::math::linearalgebra::add ::math::linearalgebra::sub

    fn innerToOuter {center corner {s 1.66666667}} {
        set r [sub $corner $center]
        return [add $center [scale $s $r]]
    }

    set topLeftTag [dict get $baseModel [expr {48600 + 0*$COLS + 0}]]
    set topRightTag [dict get $baseModel [expr {48600 + 0*$COLS + $COLS-1}]]
    set bottomRightTag [dict get $baseModel [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}]]
    set bottomLeftTag [dict get $baseModel [expr {48600 + ($ROWS-1)*$COLS + 0}]]

    set boardBorderScale [expr {1.66666667 * 2}] ;# 2x the inner->outer distance
    set boardTopLeft [innerToOuter [dict get $topLeftTag c] [lindex [dict get $topLeftTag p] 3] $boardBorderScale]
    set boardTopRight [innerToOuter [dict get $topRightTag c] [lindex [dict get $topRightTag p] 2] $boardBorderScale]
    set boardBottomRight [innerToOuter [dict get $bottomRightTag c] [lindex [dict get $bottomRightTag p] 1] $boardBorderScale]
    set boardBottomLeft [innerToOuter [dict get $bottomLeftTag c] [lindex [dict get $bottomLeftTag p] 0] $boardBorderScale]

    set boardCorners [list $boardTopLeft $boardTopRight $boardBottomRight $boardBottomLeft]
    set boardToClipSpaceCorners \
        [list [list 0 0 -1 -1] \
             [list $displayWidth 0 1 -1] \
             [list $displayWidth $displayHeight 1 1] \
             [list 0 $displayHeight -1 1]]
    set boardCanvasToClipSpace [estimateHomography $boardToClipSpaceCorners]
    Claim $board has canvas projection $boardCanvasToClipSpace

    # Project calibration tags based on the current model-to-display
    # homography (which gets dynamically updated as you move the board
    # around):
    When $board has canvas /any/ with /...wiOpts/ &\
         the calibration model-to-display homography is /H_modelToDisplay/ \
             with /...modelToDisplayOpts/ &\
         the calibration poses are /calibrationPoses/ &\
         the calibration cycle time is /cycleTime/ {

        package require linalg
        namespace import ::math::linearalgebra::scale \
            ::math::linearalgebra::add ::math::linearalgebra::sub \
            ::math::linearalgebra::norm

        set model [dict get $modelToDisplayOpts model]

        set bgColor [list 1 1 1 1]

        # White backdrop on board:
        Wish the GPU draws pipeline "fillTriangle" onto canvas $boardCanvas \
            with arguments [list {{1 0 0} {0 1 0} {0 0 1}} \
                                [list -1 -1] [list 1 -1] [list 1 1] $bgColor] \
            layer 99
        Wish the GPU draws pipeline "fillTriangle" onto canvas $boardCanvas \
            with arguments [list {{1 0 0} {0 1 0} {0 0 1}} \
                                [list -1 -1] [list 1 1] [list -1 1] $bgColor] \
            layer 99

        # Draw AprilTags on board:
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} { continue }

            set modelInnerCorners [lreverse [dict get $modelTag p]]
            set modelCenter [dict get $modelTag c]

            set displayOuterCorners [lmap modelInnerCorner $modelInnerCorners {
                set modelOuterCorner [innerToOuter $modelCenter $modelInnerCorner]
                $matLib applyHomography $H_modelToDisplay $modelOuterCorner
            }]
            Wish to draw an AprilTag onto $board with \
                id $id corners $displayOuterCorners background $bgColor \
                layer 100
        }

        # White backdrop across whole projector area to hopefully make
        # the projected tags pop out more:
        set surfaceToClip {{1 0 0} {0 1 0} {0 0 1}}
        set p0 [list -1 -1]
        set p1 [list 1 -1]
        set p2 [list 1 1]
        set p3 [list -1 1]
        Wish the GPU draws pipeline "fillTriangle" with arguments \
            [list $surfaceToClip $p1 $p2 $p3 $bgColor] layer 99
        Wish the GPU draws pipeline "fillTriangle" with arguments \
            [list $surfaceToClip $p0 $p1 $p3 $bgColor] layer 99

        set sides \
            [list \
                 [list $boardTopLeft $boardTopRight] \
                 [list $boardBottomRight $boardBottomLeft] \
                 [list $boardBottomLeft $boardTopLeft] \
                 [list $boardTopRight $boardBottomRight]]

        set text "[llength $calibrationPoses]/$CALIBRATION_POSES_MAX poses ([expr {round($cycleTime*1000)}] ms)"
        foreach p {add norm sub scale matmul
            getelem transpose determineSVD shape mkIdentity show
            solvePGauss crossproduct getcol setcol unitLengthVector det
        } {
            namespace import ::math::linearalgebra::$p
        }

        foreach side $sides {
            lassign $side start end anchor radians
            set displayStart [$matLib applyHomography $H_modelToDisplay $start]
            set displayEnd [$matLib applyHomography $H_modelToDisplay $end]

            set v [sub $displayEnd $displayStart]
            set displayRadians [expr {atan2(-1*[lindex $v 1], [lindex $v 0])}]
            set displayCenter [scale 0.5 [add $displayStart $displayEnd]]
            if {![info exists textScale]} {
                set textScale [/ [norm $v] 20]
            }

            Wish to draw text onto $board with text $text \
                radians $displayRadians position $displayCenter \
                anchor top color black layer 100 scale $textScale
        }

        # Now draw the board image (which has the projected tags) onto
        # the display:

        set displayToClip \
           [list [list 1 0 0] \
                 [list 0 1 0] \
                 [list 0 0 1]]

        Wish the GPU draws pipeline "image" with arguments \
            [list [list $displayWidth $displayHeight] \
                 $displayToClip \
                 [dict get $wiOpts texture] \
                 [list -1 -1] [list 1 -1] [list 1 1] [list -1 1]] \
            layer 100
    }

    # This is made a function so it can also be called by the Web page
    # when the user drags the slider to adjust projected tag scale.
    fn HoldDefaultModel! {scale} {
        # Default model: just makes the tags fill most of the middle
        # of the projector area.
        set tagSideLengthPixels [::math::min $($displayWidth/($COLS * ($tagOuterLength + $pad))) \
                                     $($displayHeight/($ROWS * ($tagOuterLength + $pad)))]
        set tagSideLengthPixels [expr {$tagSideLengthPixels * $scale}]

        # TODO: Center this on the projector area.
        set H_modelToDisplay [estimateHomography [subst {
            {$printedSideLengthM $printedSideLengthM $tagSideLengthPixels $tagSideLengthPixels}
            {$printedSideLengthM 0 $tagSideLengthPixels 0}
            {0 $printedSideLengthM 0 $tagSideLengthPixels}
            {0 0 0 0}
        }]]
        Hold! -key H_modelToDisplay {
            # Default model and version: nothing rotated.
            Claim the calibration model-to-display homography is $H_modelToDisplay with \
                model $baseModel version -1 \
                frameTimestamp [expr {[clock milliseconds] / 1000.0}] \
                modelTimestamp [expr {[clock milliseconds] / 1000.0}]
        }
    }
    Claim the calibration HoldDefaultModel! is [fn HoldDefaultModel!]
    HoldDefaultModel! 1.0

    On unmatch {
        Hold! -key H_modelToDisplay {}
        Hold! -key exposure {
            Wish camera $camera uses exposure time auto us
        }
    }

    When (serially) camera $camera has frame /frame/ at timestamp /frameTimestamp/ {
        # HACK: so we just lookup whatever is latest _right now_,
        # instead of subscribing.
        set calibrationStates \
            [Query! the calibration model-to-display homography is /H_modelToDisplay/ with \
                 /...modelToDisplayOpts/]
        if {[llength $calibrationStates] == 0} {
            return
        }
        # Sort in ascending order to find the newest (highest frameTimestamp) model.
        set calibrationState [lindex [lsort -command [list apply {{a b} {
            expr {[dict get $a modelToDisplayOpts frameTimestamp] <
                  [dict get $b modelToDisplayOpts frameTimestamp]}
        }}] $calibrationStates] end]
        dict with calibrationState {}

        set model [dict get $modelToDisplayOpts model]
        set version [dict get $modelToDisplayOpts version]
        set modelFrameTimestamp [dict get $modelToDisplayOpts frameTimestamp]
        set modelTimestamp [dict get $modelToDisplayOpts modelTimestamp]
        if {$modelFrameTimestamp >= $frameTimestamp} {
            # This is an old homography. This seems to only happen on
            # slider manual size adjust.
            return
        }

        set aprilTime [time {
            set tags [$calibrationTagDetector detect $frame]
        }]

        package require linalg

        # This runs every frame, looks at the detected tags (both
        # projected and printed), and updates the H_modelToDisplay
        # such that the projected tags should sit in the middle of the
        # calibration board.

        set printedTags [dict create] ;# dict keyed by tag id for easy lookup
        foreach tag $tags {
            set id [dict get $tag id]
            dict set allDetectedTags $id $tag
            if {[isPrintedTag $id]} { dict set printedTags $id $tag }
        }
        if {[dict size $printedTags] == 0} { return }

        set printedPointPairs [list]
        dict for {id printedTag} $printedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $printedTag p] {
                    lappend printedPointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }
        # Describes how tags from the model that were printed
        # ended up mapping to camera coordinates.
        set H_modelToCameraViaPs [estimateHomography $printedPointPairs]

        # Map the bounds of the board to camera coordinates, so we can
        # check if projected tags are inside the board.
        set modelTopLeft [lindex [dict get $model [expr {48600 + 0*$COLS + 0}] p] 3]
        set modelTopRight [lindex [dict get $model [expr {48600 + 0*$COLS + $COLS-1}] p] 2]
        set modelBottomRight [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + $COLS-1}] p] 1]
        set modelBottomLeft [lindex [dict get $model [expr {48600 + ($ROWS-1)*$COLS + 0}] p] 0]
        set printedCalibrationBoard [list {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopLeft] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelTopRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomRight] \
                                         {*}[$matLib applyHomography $H_modelToCameraViaPs $modelBottomLeft]]
        set boardMinX 100000; set boardMinY 100000
        set boardMaxX -100000; set boardMaxY -100000
        foreach {cornerX cornerY} $printedCalibrationBoard {
            if {$cornerX < $boardMinX} { set boardMinX $cornerX }
            if {$cornerY < $boardMinY} { set boardMinY $cornerY }
            if {$cornerX > $boardMaxX} { set boardMaxX $cornerX }
            if {$cornerY > $boardMaxY} { set boardMaxY $cornerY }
        }

        # We only count projected tags that are inside the board.
        set projectedTags [dict create]
        dict for {id tag} $allDetectedTags {
            if {![isProjectedTag $id]} { continue }

            lassign [dict get $tag c] x y
            if {$x > $boardMinX && $x < $boardMaxX &&
                $y > $boardMinY && $y < $boardMaxY} {
                # This is a projected tag that we detected.
                dict set projectedTags $id $tag
            }
        }
        if {[dict size $projectedTags] == 0} { return }

        # Check the rotation of a version tag to figure out the
        # version of what the camera saw, unless it's version -1.
        if {$version != -1} {
            # Find any version tag. If none were detected, then abort
            # and wait until a later frame.
            dict for {id tag} $projectedTags {
                if {[isVersionTag $id]} {
                    set versionTagId $id
                    break
                }
            }
            if {![info exists versionTagId]} { return }

            set getTagAngle {{tag} {
                set p [dict get $tag p]
                expr {atan2(-1 * ([lindex $p 1 1] - [lindex $p 0 1]),
                            [lindex $p 1 0] - [lindex $p 0 0])}
            }}
            set versionTagAngle [apply $getTagAngle [dict get $projectedTags $versionTagId]]

            # Compare angle to angle of any other projected tag.
            if {[dict size $projectedTags] < 2} { return }
            dict for {id projectedTag} $projectedTags {
                if {![isVersionTag $id]} {
                    set otherTagAngle [apply $getTagAngle $projectedTag]
                    break
                }
            }
            if {![info exists otherTagAngle]} { return }

            set versionAngle [expr {$versionTagAngle - $otherTagAngle}]
            # Rotations corresponding to versions 0, 1, 2, 3:
            set possibleVersions \
                [list 1  0 \
                      0  1 \
                     -1  0 \
                      0 -1]
            # Which of the possibleVersions is versionAngle closest to?
            set detectedVersion [lindex [lsort-indices [lmap {x y} $possibleVersions {
                expr {sqrt(($x - cos($versionAngle))**2 + ($y - sin($versionAngle))**2)}
            }]] 0]

            # If the detected version does not correspond to version mod 4,
            # then we should abort and wait until a later frame.
            set expectedVersion [expr {$version % 4}]
            if {$detectedVersion != $expectedVersion} {
                return
            }
        }

        set projectedPointPairs [list]
        dict for {id projectedTag} $projectedTags {
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $projectedTag p] {
                    set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                    lappend projectedPointPairs [list {*}$cameraCorner {*}$displayCorner]
                }
        }

        # puts "point pairs (camera -> display): {$projectedPointPairs}"
        set H_cameraToDisplay [estimateHomography $projectedPointPairs]
        if {abs([::math::linearalgebra::det $H_cameraToDisplay]) < 0.001} {
            # Garbage homography that just shrinks the points way down
            # (https://stackoverflow.com/questions/10972438/detecting-garbage-homographies-from-findhomography-in-opencv).
            # It's sort of 'overfitted' and just has a big y-intercept
            # and will break everything if we let it through. Skip.
            return
        }

        # Update H_modelToDisplay to project the tags into the right
        # spots on the board next frame.
        set nextH_modelToDisplay [$matLib matdMul $H_cameraToDisplay $H_modelToCameraViaPs]
        set nextModelFrameTimestamp $frameTimestamp
        set nextVersion [+ $version 1]
        set nextModel [versionizeTags $baseModel $nextVersion]
        set nextModelTimestamp [expr {[clock milliseconds] / 1000.0}]
        Hold! -key H_modelToDisplay \
            -version $nextModelFrameTimestamp \
            Claim the calibration model-to-display homography \
            is $nextH_modelToDisplay with \
            model $nextModel version $nextVersion \
            frameTimestamp $nextModelFrameTimestamp \
            modelTimestamp $nextModelTimestamp
        Hold! -key cycle-time \
            Claim the calibration cycle time is \
            $($nextModelTimestamp - $modelTimestamp)

        # Should we record the points we just saw as a calibration
        # pose?

        # We want to be seeing at least 50% of printed and projected tags.
        if {[dict size $printedTags] < $COLS + $ROWS ||
            [dict size $projectedTags] < $COLS - 2} {
            return
        }

        # We can do an error check here. H_modelToCameraViaPs was
        # derived above from printed tags -- we should be able to run
        # _projected_ tags through it and compare the coordinates to
        # the actual detection coordinates. If there's too much error,
        # we won't record this as a calibration pose.
        set totalError 0.0
        dict for {id projectedTag} $projectedTags {
            foreach modelCorner [dict get $model $id p] \
                cameraCorner [dict get $projectedTag p] {
                    lassign $cameraCorner cx cy
                    # Predicted camera x and y.
                    lassign [$matLib applyHomography $H_modelToCameraViaPs $modelCorner] px py
                    set dx [- $cx $px]; set dy [- $cy $py]
                    set err [expr {$dx*$dx + $dy*$dy}]
                    set totalError [+ $totalError $err]
            }
        }
        set poseRmse [expr {sqrt($totalError / ([llength $projectedTags] * 4))}]
        if {$poseRmse > 5} {
            puts "calibrate: Pose has too-high rmse ($poseRmse); skipping"
            return
        }

        set pose [dict create \
                      model $model version $version \
                      camera $camera \
                      cameraWidth $cameraWidth cameraHeight $cameraHeight \
                      display $display \
                      displayWidth $displayWidth displayHeight $displayHeight \
                      tagSize $printedSideLengthM \
                      H_modelToDisplay $H_modelToDisplay \
                      rmse $poseRmse \
                      tags [dict merge $printedTags $projectedTags]]

        set seenPoses [dict get [lindex [Query! the calibration last-seen poses are /seenPoses/] 0] seenPoses]
        lappend seenPoses $pose
        if {[llength $seenPoses] > $SEEN_POSES_MAX} {
            set seenPoses [lreplace $seenPoses 0 0]
        }
        Hold! -key last-seen-poses \
            -version $nextModelFrameTimestamp \
            Claim the calibration last-seen poses are $seenPoses

        # Next, we check if projected tag corners have been pretty
        # stable in the last few frames.

        if {[llength $seenPoses] < 3} {
            return
        }

        # If the corners have moved a lot since last frame, we're not
        # stable enough and shouldn't record this as a calibration
        # pose.
        foreach seenPose [lrange $seenPoses 0 end-1] {
            # Decreasing this threshold to 1 helps with data
            # accuracy. TODO: Use an _older_ frame?
            if {[meanPoseDifference $pose $seenPose] > 5} {
                return
            }
        }

        puts "WOULD APPEND CALIBRATION..."

        # If the corners have _not_ moved a lot since last _saved_
        # calibration pose, this isn't different enough to be a good
        # calibration pose to save.
        set calibrationPoses [dict get [lindex [Query! the calibration poses are /calibrationPoses/] 0] calibrationPoses]
        if {[llength $calibrationPoses] > 0} {
            set prevCalibrationPose [lindex $calibrationPoses end]
            if {[meanPoseDifference $pose $prevCalibrationPose] < 50} {
                return
            }
        }

        # Save the pose / camera image to a jpeg (for debugging purposes)
        exec mkdir -p "$::env(HOME)/folk-calibration-poses"
        set imageName "pose-$calibrationId-[llength $calibrationPoses].jpeg"
        $imageLib saveAsJpeg $frame "$::env(HOME)/folk-calibration-poses/$imageName"
        dict set pose imageName $imageName

        # OK, let's save this calibration pose.
        lappend calibrationPoses $pose
        puts "APPENDED CALIBRATION TO POSES ([llength $calibrationPoses] poses collected)"
        Hold! -on calibration -key poses \
            -version $nextModelFrameTimestamp \
            Claim the calibration poses are $calibrationPoses

        # If we have enough poses, then stop the calibration process
        # (retract the printed side length?) and do a calibration. :-)
        if {[llength $calibrationPoses] >= $CALIBRATION_POSES_MAX} {
            puts "READY CALIBRATION POSES!"

            catch { exec mkdir "$::env(HOME)/folk-live" }
            catch {exec rm "$::env(HOME)/folk-live/folk-calibration-output.txt"}

            set fd [open "$::env(HOME)/folk-live/folk-calibration-poses.txt" w]
            puts $fd $calibrationPoses; close $fd

            # Destroy the old calibration and trigger a new one.
            Hold! -on calibration -key calibration {}

            Retract! /someone/ wishes to calibrate
        }
    }
}

fn processHomography {H} {
    package require linalg
    namespace import ::math::linearalgebra::getelem
    namespace import ::math::linearalgebra::sub

    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}


# Uses Zhang's calibration technique
# (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)
# to calibrate a projector or camera given a known 2D planar pattern
# and multiple observed poses.
#
# Returns intrinsic matrix for the camera/projector, which explains
# how 3D real-world coordinates get projected to 2D coordinates by
# that device. (The intrinsic matrix can be used with an AprilTag
# detector to get real-world coordinates for each AprilTag.)
#
# Arguments:
#         width  width of camera or projector in pixels
#         height height of camera or projector in pixels
#         Hs     a list of N homographies from camera/projector image
#                plane -> model plane (for N different poses).
fn zhangUnrefinedCalibrate {name width height Hs} {
    package require linalg
    namespace import ::math::linearalgebra::shape \
        ::math::linearalgebra::transpose \
        ::math::linearalgebra::matmul \
        ::math::linearalgebra::determineSVD \
        ::math::linearalgebra::mkIdentity \
        ::math::linearalgebra::solvePGauss \
        ::math::linearalgebra::getcol \
        ::math::linearalgebra::norm \
        ::math::linearalgebra::scale \
        ::math::linearalgebra::crossproduct \
        ::math::linearalgebra::add \
        ::math::linearalgebra::sub

    # Try to solve for the camera intrinsics:

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V
    set b [lindex [transpose $V] [lindex [lsort-indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }

    set fx $alpha; set fy $beta
    set cx $u0; set cy $v0
    set s $gamma
    puts "   Focal Length: \[ $fx $fy ]"
    puts "Principal Point: \[ $cx $cy ]"
    puts "           Skew: \[ $s ] "

    # Intrinsic matrix:
    set A [subst {
        {$fx  $s   $cx}
        {0    $fy  $cy}
        {0    0    1}
    }]
    set Ainv [solvePGauss $A [mkIdentity 3]]

    set extrinsics [lmap H $Hs {
        set h1 [getcol $H 0]
        set h2 [getcol $H 1]
        set h3 [getcol $H 2]
        set lambda [/ 1.0 [norm [matmul $Ainv $h1]]]

        set r1 [scale $lambda [matmul $Ainv $h1]]
        set r2 [scale $lambda [matmul $Ainv $h2]]
        set r3 [crossproduct $r1 $r2]
        set R [transpose [list $r1 $r2 $r3]]

        set t [scale $lambda [matmul $Ainv $h3]]

        # Refine R into a better rotation matrix (reorthogonalize)
        # using SVD.
        lassign [determineSVD $R] U S V
        set R [matmul $U [transpose $V]]

        dict create R $R t $t
    }]

    # Initialize distortion terms k1 and k2 to 0 -- they get figured
    # out during nonlinear refinement.
    set intrinsics [dict create \
                        width $width height $height \
                        fx $fx fy $fy cx $cx cy $cy s $s \
                        k1 0 k2 0]
    return [dict create \
                name $name \
                intrinsics $intrinsics \
                extrinsics $extrinsics]
}

fn setCameraToProjectorExtrinsics {calibrationVar calibrationPoses} {
    # Use the "Kabsch algorithm" (https://nghiaho.com/?page_id=671;
    # https://zpl.fi/aligning-point-patterns-with-kabsch-umeyama-algorithm/)
    # to find the rotation and translation from 3D camera-space to 3D
    # projector-space.

    upvar $calibrationVar calibration

    # Let's take all the points for which we have a corresponding
    # camera frame point and projector frame point.
    set cameraFramePoints [list]
    set projectorFramePoints [list]

    for {set i 0} {$i < [llength $calibrationPoses]} {incr i} {
        set calibrationPose [lindex $calibrationPoses $i]
        
        set Rc [dict get [lindex [dict get $calibration camera extrinsics] $i] R]
        set tc [dict get [lindex [dict get $calibration camera extrinsics] $i] t]

        set Rp [dict get [lindex [dict get $calibration projector extrinsics] $i] R]
        set tp [dict get [lindex [dict get $calibration projector extrinsics] $i] t]

        # TODO: Try using pose estimation instead?
        dict for {id tag} [dict get $calibrationPose model] {
            if {![isProjectedTag $id]} { continue }
            set k 0
            foreach v [dict get $tag p] {
                incr k
                lappend v 0.0

                set vc [add [matmul $Rc $v] $tc]
                set vp [add [matmul $Rp $v] $tp]

                lappend cameraFramePoints $vc
                lappend projectorFramePoints $vp
            }
        }
    }

    # puts "cameraFramePoints = \[[join [lmap p $cameraFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"
    # puts "projectorFramePoints = \[[join [lmap p $projectorFramePoints {concat \[ [join $p ,] \]}] ,\n]\]"

    set n [llength $cameraFramePoints]

    set vcsum {0 0 0}
    foreach vc $cameraFramePoints { set vcsum [add $vcsum $vc] }
    set cameraFramePointsCentroid [scale [/ 1.0 $n] $vcsum]

    set vpsum {0 0 0}
    foreach vp $projectorFramePoints { set vpsum [add $vpsum $vp] }
    set projectorFramePointsCentroid [scale [/ 1.0 $n] $vpsum]

    set H [matmul [transpose [sub $cameraFramePoints \
                                  [lrepeat $n $cameraFramePointsCentroid]]] \
               [sub $projectorFramePoints \
                    [lrepeat $n $projectorFramePointsCentroid]]]

    lassign [determineSVD $H] U S V
    set R [matmul $V [transpose $U]]
    set t [sub $projectorFramePointsCentroid \
               [matmul $R $cameraFramePointsCentroid]]

    dict set calibration R_cameraToProjector $R
    dict set calibration t_cameraToProjector $t
}

# End-to-end calibrates a camera-projector pair. calibrationPoses is
# a list of N pose dictionaries. Each pose dictionary includes `tags`
# from a camera detection, `model` with coordinates in meters,
# `H_modelToDisplay`.
fn unrefinedCalibrateCameraAndProjector {matLib calibrationPoses} {
    package require linalg
    namespace import ::math::linearalgebra::det
    namespace import ::math::linearalgebra::scale

    # Just used to get metadata about cam/proj:
    set pose0 [lindex $calibrationPoses 0]

    # First, calibrate the camera. "Using only the corners from
    # printed markers xb and their detected corners xc, [...]
    # calibrate the camera with no difficulties using Zhangâ€™s method."
    set i 0
    set Hs_modelToCamera [lmap pose $calibrationPoses {
        # Pairs of (camera coordinates, model coordinates).
        set model [dict get $pose model]
        set tags [dict get $pose tags]
        set pointPairs [list]
        dict for {id cameraTag} $tags {
            if {![isPrintedTag $id]} continue
            set modelTag [dict get $model $id]
            foreach modelCorner [dict get $modelTag p] \
                cameraCorner [dict get $cameraTag p] {
                    lappend pointPairs [list {*}$modelCorner {*}$cameraCorner]
                }
        }

        set H [estimateHomography $pointPairs]
        if {[det $H] < 0} {
            set H [scale -1 $H]
        }
        set H
    }]
    puts "Zhang calibrate camera:"
    puts "========"
    set cameraName [dict get $pose0 camera]
    set cameraWidth [dict get $pose0 cameraWidth]
    set cameraHeight [dict get $pose0 cameraHeight]
    set cameraCalibration [zhangUnrefinedCalibrate \
                               $cameraName $cameraWidth $cameraHeight \
                               $Hs_modelToCamera]
    puts "\n======================\n"

    # Second, calibrate the projector.
    set i 0
    set Hs_modelToDisplay [lmap pose $calibrationPoses {
        set H_modelToDisplay [dict get $pose H_modelToDisplay]

        set pointPairs [list]
        set model [dict get $pose model]
        dict for {id modelTag} $model {
            if {![isProjectedTag $id]} continue
            foreach modelCorner [dict get $modelTag p] {
                set displayCorner [$matLib applyHomography $H_modelToDisplay $modelCorner]
                lappend pointPairs [list {*}$modelCorner {*}$displayCorner]
            }
        }

        if {[det $H_modelToDisplay] < 0} {
            set H_modelToDisplay [scale -1 $H_modelToDisplay]
        }
        set H_modelToDisplay
    }]
    puts "Zhang calibrate projector:"
    puts "========"
    set projectorName [dict get $pose0 display]
    set projectorWidth [dict get $pose0 displayWidth]
    set projectorHeight [dict get $pose0 displayHeight]
    set projectorCalibration [zhangUnrefinedCalibrate \
                                  $projectorName \
                                  $projectorWidth $projectorHeight \
                                  $Hs_modelToDisplay]
    puts "\n======================\n"

    set calibration [dict create \
                         camera $cameraCalibration \
                         projector $projectorCalibration]
    setCameraToProjectorExtrinsics calibration $calibrationPoses
    return $calibration
}

When the calibration matLib is /matLib/ &\
     the calibration poses are /calibrationPoses/ &\
     /nobody/ claims the calibration is /anything/ &\
     the calibration refiner is /refineCalibration/ {

    if {[llength $calibrationPoses] < $CALIBRATION_POSES_MAX} {
        return
    }

    set calibration [unrefinedCalibrateCameraAndProjector $matLib $calibrationPoses]
    puts "======== Unrefined calibration ========="
    puts $calibration
    puts ""

    set calibration [{*}$refineCalibration \
                         [fn isPrintedTag] [fn isProjectedTag] $matLib \
                         $calibrationPoses $calibration]
    puts "======== Refined calibration intrinsics ========="

    puts "."
    puts "======== Refined calibration ========="
    puts $calibration
    puts "."

    When the pose library is /poseLib/ &\
         the printed calibration tag size is /tagSizeMm/ mm {
        puts "======== Reproject pose 0 ========="
        set pose [lindex $calibrationPoses 0]
        set tagSize [expr {$tagSizeMm / 1000.0}]
        set cameraIntrinsics [dict get $calibration camera intrinsics]
        set cameraWidth [dict get $calibration camera intrinsics width]
        set cameraHeight [dict get $calibration camera intrinsics height]
        set projectorIntrinsics [dict get $calibration projector intrinsics]
        set projectorWidth [dict get $calibration projector intrinsics width]
        set projectorHeight [dict get $calibration projector intrinsics height]
        dict for {id det} [dict get $pose tags] {
            # Look through all the projected tags that we detected on
            # camera in this pose.
            if {![isProjectedTag $id]} { continue }

            puts "Tag $id:"

            set p [dict get $det p] ;# Camera detected corners.

            # Pose-estimate this tag.
            set tagPose [$poseLib baseEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $p]
            set tagPose [$poseLib servoingEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $tagSize \
                             $tagPose $p]

            set r [expr {$tagSize / 2}]
            set tagVertices \
                [list [list [- $r]    $r  0] \
                     [list     $r     $r  0] \
                     [list     $r  [- $r] 0] \
                     [list  [- $r] [- $r] 0]]
            # Move the pose to camera-space.
            set cameraVertices [lmap v $tagVertices {
                set R [dict get $tagPose R]; set t [dict get $tagPose t]
                add [matmul $R $v] $t
            }]

            # Move the pose to projector-space.
            set projectorVertices [lmap v $cameraVertices {
                set R [dict get $calibration R_cameraToProjector]
                set t [dict get $calibration t_cameraToProjector]
                add [matmul $R $v] $t
            }]

            # Downproject to the projector pixel plane.
            set modelTag [dict get $pose model $id]
            for {set i 0} {$i < 4} {incr i} {
                set modelCorner [lindex [dict get $modelTag p] $i]
                lassign [$matLib applyHomography [dict get $pose H_modelToDisplay] $modelCorner] px py
                puts [format "Corner $i (real)  : (%.3f %.3f)" $px $py]

                set v [lindex $projectorVertices $i]
                lassign [intrinsics project $projectorIntrinsics \
                             $projectorWidth $projectorHeight \
                             $v] rpx rpy
                puts [format "Corner $i (reproj): (%.3f %.3f)" $rpx $rpy]
            }
        }
    }

    Hold! -on calibration -key calibration \
        Claim the calibration is $calibration

    set fd [open "$::env(HOME)/folk-live/folk-calibration-output.txt" w]
    puts $fd $calibration; close $fd
}
