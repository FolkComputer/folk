set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>

# Returns a 4x4 affine transformation that transforms {x y z} from
# AprilTag frame to 3D camera optical frame.
$cc proc estimateTagPose {Tcl_Obj* detObj
                          double tagSize double fx double fy double cx double cy} Tcl_Obj* {
    // HACK: we just fill the fields that pose detection will use.
    apriltag_detection_t det; {
        Tcl_Obj* pObj; Tcl_DictObjGet(NULL, detObj, Tcl_ObjPrintf("p"), &pObj);
        for (int i = 0; i < 4; i++) {
            Tcl_Obj* cornerObj; Tcl_ListObjIndex(NULL, pObj, i, &cornerObj);
            Tcl_Obj* cornerXObj; Tcl_ListObjIndex(NULL, cornerObj, 0, &cornerXObj);
            Tcl_Obj* cornerYObj; Tcl_ListObjIndex(NULL, cornerObj, 1, &cornerYObj);
            Tcl_GetDoubleFromObj(NULL, cornerXObj, &det.p[i][0]);
            Tcl_GetDoubleFromObj(NULL, cornerYObj, &det.p[i][1]);
        }
        det.H = alloca(sizeof(matd_t) * 9*sizeof(double));
        det.H->nrows = 3; det.H->ncols = 3;
        Tcl_Obj* Hobj; Tcl_DictObjGet(NULL, detObj, Tcl_ObjPrintf("H"), &Hobj);
        for (int i = 0; i < 9; i++) {
            Tcl_Obj* entryObj; Tcl_ListObjIndex(NULL, Hobj, i, &entryObj);
            Tcl_GetDoubleFromObj(NULL, entryObj, &det.H->data[i]);
        }
    }
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = tagSize,
        .fx = fx, .fy = fy,
        .cx = cx, .cy = cy
    };
    apriltag_pose_t pose;
    double err = estimate_tag_pose(&info, &pose);
    (void) err;

    // printf("Tag %d: Pose (err %f) R %dx%d t %dx%d\n", det.id, err,
    //       pose.R->nrows, pose.R->ncols, pose.t->nrows, pose.t->ncols);

    // Return matd_t R
    // Return matd_t t
    return Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );

    // TODO: Free R
    // TODO: Free t
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul ::math::linearalgebra::getelem ::math::linearalgebra::getrow ::math::linearalgebra::sub ::math::linearalgebra::add

When (non-capturing) the calibration is /calibration/ & \
     tag /tag/ has detection info /det/ {
    # Setting aside this tag space (48600 to 48713) for calibration.
    # And they're different sizes, so we don't want to use them.
    if {$tag >= 48600} { return }

    # puts "\n"

    set tagSize [expr {31.5 / 1000}]; # 31.5 mm

    set cameraIntrinsics [dict get $calibration camera intrinsics]
    set cameraFx [getelem $cameraIntrinsics 0 0]
    set cameraFy [getelem $cameraIntrinsics 1 1]
    set cameraCx [getelem $cameraIntrinsics 0 2]
    set cameraCy [getelem $cameraIntrinsics 1 2]
    set projectorIntrinsics [dict get $calibration projector intrinsics]

    set R [dict get $calibration R_cameraToProjector]
    set t [dict get $calibration t_cameraToProjector]

    set tagPose [estimateTagPose $det $tagSize \
                     $cameraFx $cameraFy $cameraCx $cameraCy]

    set tagFrameCorners \
        [list [list [expr {-$tagSize/2}] [expr {$tagSize/2}]  0] \
              [list [expr {$tagSize/2}]  [expr {$tagSize/2}]  0] \
              [list [expr {$tagSize/2}]  [expr {-$tagSize/2}] 0] \
              [list [expr {-$tagSize/2}] [expr {-$tagSize/2}] 0]]
    set projectorCorners [list]
    for {set i 0} {$i < 4} {incr i} {
        # These are 3D coordinates in meters from the center of the
        # AprilTag.
        set tagFrameCorner [lindex $tagFrameCorners $i]
        # These are 3D coordinates in meters from the center of the
        # webcam.
        set cameraFrameCorner [lrange [matmul $tagPose [list {*}$tagFrameCorner 1]] 0 2]

        set projectorFrameCorner [add [matmul $R $cameraFrameCorner] $t]
        # Use projector intrinsics to project real-world coordinates
        # down to 2D projector plane.
        lassign [matmul $projectorIntrinsics $projectorFrameCorner] px py pz
        set projX [/ $px $pz]; set projY [/ $py $pz]
        lappend projectorCorners [list $projX $projY]
    }
    lappend projectorCorners [lindex $projectorCorners 0]
    Wish to draw a stroke with points $projectorCorners width 3 color white
}
