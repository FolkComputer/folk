set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>

# TODO: deduplicate w/ AprilTags.tcl
$cc struct apriltag_detection_ffi {
    apriltag_family_t* family;
    int id;
    int hamming;
    float decision_margin;
    matd_t* H;
    double c[2];
    double p[8]; // TODO: Make 2D array.
} ;# -nodefine -destructor
# Returns a 4x4 affine transformation that transforms {x y z} from
# AprilTag frame to 3D camera optical frame.
$cc proc estimateTagPose {apriltag_detection_ffi det
                          double tagSize double fx double fy double cx double cy} Tcl_Obj* {
    apriltag_detection_info_t info = {
        .det = (apriltag_detection_t*) &det,
        .tagsize = tagSize,
        .fx = fx, .fy = fy,
        .cx = cx, .cy = cy
    };
    apriltag_pose_t pose;
    double err = estimate_tag_pose(&info, &pose);
    (void) err;

    // printf("Tag %d: Pose (err %f) R %dx%d t %dx%d\n", det.id, err,
    //       pose.R->nrows, pose.R->ncols, pose.t->nrows, pose.t->ncols);

    // Return matd_t R
    // Return matd_t t
    return Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );

    // TODO: Free R
    // TODO: Free t
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul ::math::linearalgebra::getelem ::math::linearalgebra::getrow ::math::linearalgebra::sub ::math::linearalgebra::add

When (non-capturing) tag /tag/ has detection info /det/ {
    # Setting aside this tag space (48600 to 48713) for calibration.
    # And they're different sizes, so we don't want to use them.
    if {$tag >= 48600} { return }

    puts "==="

    set tagSize [expr {31.5 / 1000}]; # 31.5 mm
    # Zhang-calibrated camera intrinsics:
    set fx 1429.93
    set fy 1432.907
    set cx 949.85
    set cy 565.146
    set pose [estimateTagPose $det $tagSize $fx $fy $cx $cy]
    puts "$tag: [getelem $pose 0 3] [getelem $pose 1 3] [getelem $pose 2 3]"

    # set R [lmap row {0 1 2} {getrow $pose $row 0 2}]
    # set t [lmap row {0 1 2} {getelem $pose $row 3}]

    set aprilTagFrameCorners \
        [list [list [expr {-$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {-$tagSize/2}] 0] \
             [list [expr {-$tagSize/2}] [expr {-$tagSize/2}] 0]]
    for {set i 0} {$i < 4} {incr i} {
        set aprilTagFrameCorner [lindex $aprilTagFrameCorners $i]
        # Augment to be homogeneous.
        set cameraFrameCorner [lrange [matmul $pose [list {*}$aprilTagFrameCorner 1]] 0 2]
        puts "$tag: cameraFrameCorner $i: ($cameraFrameCorner)"

        # TODO: test reprojection to 2D camera plane, compare to x and y

        set x [apriltag_detection_ffi p $det [expr {$i * 2}]]
        set y [apriltag_detection_ffi p $det [expr {$i * 2 + 1}]]

        # x and y are in camera space.

        # FIXME: Use pose (R and t matrices) to unproject each corner into
        # real-world space (camera optical frame)
        
    }

    # Zhang-calibrated projector intrinsics:
    
    
    # TODO: Project pose back to projector coordinates
    # how does apriltag pose work?

    
}
