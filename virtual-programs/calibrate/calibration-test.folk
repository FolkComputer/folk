set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>

# TODO: deduplicate w/ AprilTags.tcl
$cc struct apriltag_detection_ffi {
    apriltag_family_t* family;
    int id;
    int hamming;
    float decision_margin;
    matd_t* H;
    double c[2];
    double p[8]; // TODO: Make 2D array.
} ;# -nodefine -destructor
# Returns a 4x4 affine transformation that transforms {x y z} from
# AprilTag frame to 3D camera optical frame.
$cc proc estimateTagPose {apriltag_detection_ffi det
                          double tagSize double fx double fy double cx double cy} Tcl_Obj* {
    apriltag_detection_info_t info = {
        .det = (apriltag_detection_t*) &det,
        .tagsize = tagSize,
        .fx = fx, .fy = fy,
        .cx = cx, .cy = cy
    };
    apriltag_pose_t pose;
    double err = estimate_tag_pose(&info, &pose);
    (void) err;

    // printf("Tag %d: Pose (err %f) R %dx%d t %dx%d\n", det.id, err,
    //       pose.R->nrows, pose.R->ncols, pose.t->nrows, pose.t->ncols);

    // Return matd_t R
    // Return matd_t t
    return Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );

    // TODO: Free R
    // TODO: Free t
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul ::math::linearalgebra::getelem ::math::linearalgebra::getrow ::math::linearalgebra::sub ::math::linearalgebra::add

When (non-capturing) tag /tag/ has detection info /det/ {
    # Setting aside this tag space (48600 to 48713) for calibration.
    # And they're different sizes, so we don't want to use them.
    if {$tag >= 48600} { return }

    # puts "\n"

    set tagSize [expr {31.5 / 1000}]; # 31.5 mm
    # Zhang-calibrated camera intrinsics:
    set fx 1429.9300452
    set fy 1432.906947
    set cx 949.85091
    set cy 565.14558
    set pose [estimateTagPose $det $tagSize $fx $fy $cx $cy]
    # puts "Tag $tag center (real-world x/y/z meters from cam center): [getelem $pose 0 3] [getelem $pose 1 3] [getelem $pose 2 3]"

    # set R [lmap row {0 1 2} {getrow $pose $row 0 2}]
    # set t [lmap row {0 1 2} {getelem $pose $row 3}]

    set cameraIntrinsics [subst {
        {$fx 0   $cx}
        {0   $fy $cy}
        {0   0   1}
    }]
    # Zhang-calibrated projector intrinsics:
    set projectorIntrinsics [subst {
        {2145.67291   -81.50309     722.2164738}
        {         0  2234.27633      915.952663}
        {         0           0               1}
    }]
    # From calibrating without premultiplying homographies. Broken:
    # set projectorIntrinsics2 [subst {
    #     {2198.284027   28.5968899   962.0741365}
    #     {          0  2186.364329  1099.4065579}
    #     {          0            0             1}
    # }]

    set aprilTagFrameCorners \
        [list [list [expr {-$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {-$tagSize/2}] 0] \
             [list [expr {-$tagSize/2}] [expr {-$tagSize/2}] 0]]
    set projectorCorners [list]
    for {set i 0} {$i < 4} {incr i} {
        set aprilTagFrameCorner [lindex $aprilTagFrameCorners $i]
        # Augment to be homogeneous.
        set cameraFrameCorner [lrange [matmul $pose [list {*}$aprilTagFrameCorner 1]] 0 2]
        # puts "Tag $tag: cameraFrameCorner $i (real-world x/y/z meters from cam center): ($cameraFrameCorner)"

        # TODO: use camera intrinsics to test reprojection to 2D camera
        # plane, compare to x and y
        # lassign [matmul $cameraIntrinsics $cameraFrameCorner] rpx rpy rpz
        # set reprojX [/ $rpx $rpz]
        # set reprojY [/ $rpy $rpz]

        # set x [apriltag_detection_ffi p $det [expr {$i * 2}]]
        # set y [apriltag_detection_ffi p $det [expr {$i * 2 + 1}]]
        # # x and y are in camera-plane space.
        # puts "$tag: original:               camera corner $i: ($x $y)"
        # puts "$tag: reproj from real-world: camera corner $i: ($reprojX $reprojY)"
        # puts "==="

        # Use projector intrinsics to project real-world coordinates
        # down to 2D projector plane
        lassign [matmul $projectorIntrinsics $cameraFrameCorner] px py pz
        set projX [/ $px $pz]; set projY [/ $py $pz]
        lappend projectorCorners [list $projX $projY]
    }
    lappend projectorCorners [lindex $projectorCorners 0]
    Wish to draw a stroke with points $projectorCorners width 3 color white
}
