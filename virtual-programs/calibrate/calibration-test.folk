set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>

# TODO: deduplicate w/ AprilTags.tcl
$cc struct apriltag_detection_ffi {
    apriltag_family_t* family;
    int id;
    int hamming;
    float decision_margin;
    matd_t* H;
    double c[2];
    double p[8]; // TODO: Make 2D array.
} ;# -nodefine -destructor
# Returns a 4x1 pose matrix that transforms {x y z} from 3D camera
# optical frame to AprilTag frame.
$cc proc estimateTagPose {apriltag_detection_ffi det
                          double tagSize double fx double fy double cx double cy} Tcl_Obj* {
    apriltag_detection_info_t info = {
        .det = (apriltag_detection_t*) &det,
        .tagsize = tagSize,
        .fx = fx, .fy = fy,
        .cx = cx, .cy = cy
    };
    apriltag_pose_t pose;
    double err = estimate_tag_pose(&info, &pose);
    (void) err;

    // printf("Tag %d: Pose (err %f) R %dx%d t %dx%d\n", det.id, err,
    //       pose.R->nrows, pose.R->ncols, pose.t->nrows, pose.t->ncols);

    // Return matd_t R
    // Return matd_t t
    return Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );

    // TODO: Free R
    // TODO: Free t
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul

When (non-capturing) tag /tag/ has detection info /det/ {
    set tagSize [expr {31.5 / 1000}]; # 31.5 mm
    # Zhang-calibrated camera intrinsics:
    set fx 1429.93
    set fy 1432.907
    set cx 949.85
    set cy 565.146
    set pose [estimateTagPose $det $tagSize $fx $fy $cx $cy]

    # Invert the pose?
    set poseInv [solvePGauss $pose [mkIdentity 4]]

    # poseInv now transforms from AprilTag frame (fixed-pos corners)
    # to 3D camera optical frame
    set aprilTagFrameCorners \
        [list [list [expr {-$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {$tagSize/2}] 0] \
             [list [expr {$tagSize/2}] [expr {-$tagSize/2}] 0] \
             [list [expr {-$tagSize/2}] [expr {-$tagSize/2}] 0]]
    for {set i 0} {$i < 4} {incr i} {
        # Augment to be homogenous.
        set aprilTagFrameCorner [list {*}[lindex $aprilTagFrameCorners $i] 1]

        set cameraFrameCorner [matmul $poseInv $aprilTagFrameCorner]
        # TODO: test reprojection to optical frame?
        puts "cameraFrameCorner: $cameraFrameCorner"

        set x [apriltag_detection_ffi p $det [expr {$i * 2}]]
        set y [apriltag_detection_ffi p $det [expr {$i * 2 + 1}]]

        # x and y are in camera space.

        # FIXME: Use pose (R and t matrices) to unproject each corner into
        # real-world space (camera optical frame)
        
    }

    # Zhang-calibrated projector intrinsics:
    
    
    # TODO: Project pose back to projector coordinates
    # how does apriltag pose work?

    
}
