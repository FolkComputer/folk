set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>

# Returns a 4x4 affine transformation that transforms {x y z} from
# AprilTag frame to 3D camera optical frame.
$cc proc estimateTagPose {Tcl_Obj* detObj
                          double tagSize double fx double fy double cx double cy} Tcl_Obj* {
    // HACK: we just fill the fields that pose detection will use.
    apriltag_detection_t det; {
        Tcl_Obj* pObj; Tcl_DictObjGet(NULL, detObj, Tcl_ObjPrintf("p"), &pObj);
        for (int i = 0; i < 4; i++) {
            Tcl_Obj* cornerObj; Tcl_ListObjIndex(NULL, pObj, i, &cornerObj);
            Tcl_Obj* cornerXObj; Tcl_ListObjIndex(NULL, cornerObj, 0, &cornerXObj);
            Tcl_Obj* cornerYObj; Tcl_ListObjIndex(NULL, cornerObj, 1, &cornerYObj);
            Tcl_GetDoubleFromObj(NULL, cornerXObj, &det.p[i][0]);
            Tcl_GetDoubleFromObj(NULL, cornerYObj, &det.p[i][1]);
        }
        det.H = alloca(sizeof(matd_t) * 9*sizeof(double));
        det.H->nrows = 3; det.H->ncols = 3;
        Tcl_Obj* Hobj; Tcl_DictObjGet(NULL, detObj, Tcl_ObjPrintf("H"), &Hobj);
        for (int i = 0; i < 9; i++) {
            Tcl_Obj* entryObj; Tcl_ListObjIndex(NULL, Hobj, i, &entryObj);
            Tcl_GetDoubleFromObj(NULL, entryObj, &det.H->data[i]);
        }
    }
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = tagSize,
        .fx = fx, .fy = fy,
        .cx = cx, .cy = cy
    };
    apriltag_pose_t pose;
    double err; err = estimate_tag_pose(&info, &pose);
    // estimate_pose_for_tag_homography(&info, &pose);
    (void) err;

    // printf("Tag %d: Pose (err %f) R %dx%d t %dx%d\n", det.id, err,
    //       pose.R->nrows, pose.R->ncols, pose.t->nrows, pose.t->ncols);

    // Return matd_t R
    // Return matd_t t
    return Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );

    // TODO: Free R
    // TODO: Free t
}
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc compile

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul ::math::linearalgebra::getelem ::math::linearalgebra::getrow ::math::linearalgebra::sub ::math::linearalgebra::add

set ::oldPointPairs [dict create]
When (non-capturing) the calibration is /calibration/ & \
     tag /tag/ has detection info /det/ {
    # Setting aside this tag space (48600 to 48713) for calibration.
    # And they're different sizes, so we don't want to use them.
    if {$tag >= 48600} { return }

    # puts "\n"
    
    # https://yangyushi.github.io/code/2020/03/04/opencv-undistort.html
    # https://stackoverflow.com/questions/61798590/understanding-legacy-code-algorithm-to-remove-radial-lens-distortion
    set undistort {{fx fy cx cy k1 k2 x y} {
        set x [expr {($x - $cx)/$fx}]
        set y [expr {($y - $cy)/$fy}]
        for {set i 0} {$i < 3} {incr i} {
            set r2 [expr {$x*$x + $y*$y}]
            set rad [expr {1.0 + $k1 * $r2 + $k2 * $r2*$r2}]
            set x [expr {$x / $rad}]
            set y [expr {$y / $rad}]
        }
        return [list [expr {$x*$fx + $cx}] [expr {$y*$fy + $cy}]]
    }}
    set distort {{fx fy cx cy k1 k2 x y} {
        set x [expr {($x - $cx)/$fx}]
        set y [expr {($y - $cy)/$fy}]
        set r2 [expr {$x*$x + $y*$y}]
        set D [expr {$k1 * $r2 + $k2 * $r2*$r2}]
        return [list [expr {($x * (1.0 + $D))*$fx + $cx}] \
                    [expr {($y * (1.0 + $D))*$fy + $cy}]]
    }}

    set tagSize [expr {31.5 / 1000}]; # 31.5 mm
    set tagOuterSize [expr {$tagSize * 10/6}]
    # set tagOuterSize $tagSize
    set tagFrameCorners \
        [list [list [expr {-$tagOuterSize/2}] [expr {$tagOuterSize/2}]  0] \
              [list [expr {$tagOuterSize/2}]  [expr {$tagOuterSize/2}]  0] \
              [list [expr {$tagOuterSize/2}]  [expr {-$tagOuterSize/2}] 0] \
              [list [expr {-$tagOuterSize/2}] [expr {-$tagOuterSize/2}] 0]]

    set cameraIntrinsics [dict get $calibration camera intrinsics]
    set cameraFx [getelem $cameraIntrinsics 0 0]
    set cameraFy [getelem $cameraIntrinsics 1 1]
    set cameraCx [getelem $cameraIntrinsics 0 2]
    set cameraCy [getelem $cameraIntrinsics 1 2]
    set cameraK1 [dict get $calibration camera k1]
    set cameraK2 [dict get $calibration camera k2]

    set projectorIntrinsics [dict get $calibration projector intrinsics]
    set projectorFx [getelem $projectorIntrinsics 0 0]
    set projectorFy [getelem $projectorIntrinsics 1 1]
    set projectorCx [getelem $projectorIntrinsics 0 2]
    set projectorCy [getelem $projectorIntrinsics 1 2]
    set projectorK1 [dict get $calibration projector k1]
    set projectorK2 [dict get $calibration projector k2]

    set R_cameraToProjector [dict get $calibration R_cameraToProjector]
    set t_cameraToProjector [dict get $calibration t_cameraToProjector]

    set p [dict get $det p]
    # for {set i 0} {$i < 4} {incr i} {
    #     puts "$tag-$i,[join [lindex $p $i] ,]"
    # }
    # set H [dict get $det H]
    # puts "$tag-H,[join [lmap row $H {join $row ,}] ,]"

    # Before estimating pose, undistort the corners of
    # cameraTag using the camera distortion coefficients.
    set p [lmap cameraCorner [dict get $det p] {
        apply $undistort $cameraFx $cameraFy $cameraCx $cameraCy \
            $cameraK1 $cameraK2 \
            {*}$cameraCorner
    }]
    dict set det p $p
    
    set pointPairs [list [list -1 1 {*}[lindex $p 0]] \
                        [list 1 1 {*}[lindex $p 1]] \
                        [list 1 -1 {*}[lindex $p 2]] \
                        [list -1 -1 {*}[lindex $p 3]]]
    # for {set i 0} {$i < 4} {incr i} {
    #     puts "$tag-$i,[lindex $p $i]"
    # }
    # if {[dict exists $::oldPointPairs $tag]} {
    #     set alpha 0.9
    #     set pointPairs [lmap oldPt [dict get $::oldPointPairs $tag] pt $pointPairs {
    #         lmap o $oldPt p $pt {
    #             expr {$alpha * $p + (1 - $alpha) * $o}
    #         }
    #     }]
    #     dict set det p [lmap pt $pointPairs {list [lindex $pt 2] [lindex $pt 3]}]
    # }
    # dict set ::oldPointPairs $tag $pointPairs

    set H [concat {*}[apply $::estimateSimpleHomography $pointPairs]]
    dict set det H $H
    
    set tagPose [estimateTagPose $det $tagSize \
                     $cameraFx $cameraFy $cameraCx $cameraCy]

    set projectorCorners [list]
    for {set i 0} {$i < 4} {incr i} {
        # These are 3D coordinates in meters from the center of the
        # AprilTag.
        set tagFrameCorner [lindex $tagFrameCorners $i]
        # These are 3D coordinates in meters from the center of the
        # webcam.
        lassign [matmul $tagPose [list {*}$tagFrameCorner 1]] cfx cfy cfz cfw
        set cameraFrameCorner [list [/ $cfx $cfw] [/ $cfy $cfw] [/ $cfz $cfw]]

        set projectorFrameCorner [add [matmul $R_cameraToProjector $cameraFrameCorner] $t_cameraToProjector]
        # Use projector intrinsics to project real-world coordinates
        # down to 2D projector plane.
        lassign [matmul $projectorIntrinsics $projectorFrameCorner] px py pz
        set projX [/ $px $pz]; set projY [/ $py $pz]

        lassign [apply $distort $projectorFx $projectorFy $projectorCx $projectorCy \
                     $projectorK1 $projectorK2 $projX $projY] \
            distortedProjX distortedProjY

        lappend projectorCorners [list $distortedProjX $distortedProjY]
    }
    lappend projectorCorners [lindex $projectorCorners 0]
    Wish to draw a stroke with points $projectorCorners width 3 color white
}
