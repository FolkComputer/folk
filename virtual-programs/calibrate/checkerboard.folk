set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc code {
    #include <apriltag.h>
    #include <tagStandard52h13.h>
    apriltag_family_t *tf = NULL;

    #define emit(...) i += sprintf(&ret[i], __VA_ARGS__)
}
$cc proc ::tagCanvasImageForId {int id} char* {
    if (tf == NULL) tf = tagStandard52h13_create();

    image_u8_t* image = apriltag_to_image(tf, id);

    char* ret = ckalloc(100000);
    int i = 0;
    emit("ctx.save()\n");
    emit("ctx.scale(%f, %f);\n", (float)image->width, (float)image->height);
    for (int row = 0; row < image->height; row++) {
        for (int col = 0; col < image->width; col++) {
            uint8_t pixel = image->buf[(row * image->stride) + col];
            emit("ctx.fillStyle = 'rgb(%d, %d, %d)';", pixel, pixel, pixel);
            emit("ctx.beginPath();");
            emit("ctx.moveTo(%d, %d);", col, row); // bottom-left
            emit("ctx.lineTo(%d, %d);", col + 1, row); // bottom-right
            emit("ctx.lineTo(%d, %d);", col + 1, row + 1); // top-right
            emit("ctx.lineTo(%d, %d);", col, row + 1); // top-left
            emit("ctx.closePath(); ctx.fill();");
        }
        emit("\n");
    }
    emit("ctx.restore();\n");
    ret[i++] = '\0';
    image_u8_destroy(image);
    return ret;
}
$cc compile

set ROWS 4
set COLS 6

Wish the web server handles route "/calibrate$" with handler [list apply {{ROWS COLS} {
  upvar ^html ^html
  html [csubst {
    <html>
    <body>

    <p>
      Enter the side-length of a tag in millimeters:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Submit</button>
    </p>
    <script>
      function uuidv4() {
	  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
	    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
	  );
      }
      const self = uuidv4();

    document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
        // Report the side length to a statement in Folk.

        const mm = document.getElementById("tag-side-length-mm").value;

        window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
        ws.onopen = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
            Assert \${self} claims the checkerboard tag side length is \${mm} mm
         `);
        };
        window.onbeforeunload = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
          `);
        }
      });
    </script>

    <canvas id="tags-canvas" width="1280" height="720"></canvas>

    <script>
    const ctx = document.getElementById('tags-canvas').getContext('2d');
    
    $[apply {{} {
        upvar ROWS ROWS; upvar COLS COLS
        set images [list]
        for {set row 0} {$row < $ROWS} {incr row} {
            for {set col 0} {$col < $COLS} {incr col} {
                lappend images "ctx.save(); ctx.translate($col * 160, $row * 160);
                                [::tagCanvasImageForId [+ 48600 [llength $images]]]
                                ctx.restore();"
            }
        }
        return [join $images "\n"]
    }}]
    </script>
    </body>
    </html>
  }]
}} $ROWS $COLS]

fn isValidCheckerboardDetection {detection} {
    # Does this detection contain many/all of the calibration tags?
    set expectedTagId 48600
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            if {![dict exists $detection $expectedTagId]} {
                return false
            }
            incr expectedTagId
        }
    }
    return true

    # TODO: Check that the checkerboard occupies a solid majority of
    # the camera space.
}

package require math::linearalgebra
namespace import ::math::linearalgebra::solvePGauss

fn findHomography {sideLength detection} {
    # x0 and y0 are camera points.
    fn detectionTagCorner {row col corner} {
        set id [expr {48600 + $row*$COLS + $col}]
        return [lindex [dict get [dict get $detection $id] corners] $corner]
    }

    lassign [detectionTagCorner 0 0 3] x3 y3 ;# top-left
    lassign [detectionTagCorner 0 [- $COLS 1] 2] x2 y2 ;# top-right
    lassign [detectionTagCorner [- $ROWS 1] [- $COLS 1] 1] x1 y1 ;# bottom-right
    lassign [detectionTagCorner [- $ROWS 1] 0 0] x0 y0 ;# bottom-left

    # u0 and v0 are object points (in meters, where top-left corner of
    # top-left AprilTag is 0, 0).
    set u0 0; set v0 0
    set u1 [* $COLS $sideLength 2]; set v1 0
    set u2 [* $COLS $sideLength 2]; set v2 [* $ROWS $sideLength 2]
    set u3 0; set v3 [* $ROWS $sideLength 2]

    set A [subst {
        {$x0 $y0 1 0   0   0 [expr -$x0*$u0] [expr -$y0*$u0]}
        {$x1 $y1 1 0   0   0 [expr -$x1*$u1] [expr -$y1*$u1]}
        {$x2 $y2 1 0   0   0 [expr -$x2*$u2] [expr -$y2*$u2]}
        {$x3 $y3 1 0   0   0 [expr -$x3*$u3] [expr -$y3*$u3]}
        {0   0   0 $x0 $y0 1 [expr -$x0*$v0] [expr -$y0*$v0]}
        {0   0   0 $x1 $y1 1 [expr -$x1*$v1] [expr -$y1*$v1]}
        {0   0   0 $x2 $y2 1 [expr -$x2*$v2] [expr -$y2*$v2]}
        {0   0   0 $x3 $y3 1 [expr -$x3*$v3] [expr -$y3*$v3]}
    }]
    
    set b [list $u0 $u1 $u2 $u3 $v0 $v1 $v2 $v3]

    lassign [solvePGauss $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set ::H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]
    return $::H
}

fn calibrate {sideLength detections} {
    # detections is a list of N lists of tags.
    # compute N homographies.
    set Hs [lmap detection $detections {findHomography $sideLength $detection}]
    puts "homographies ($Hs)"
    
    # Now use those to resolve the 3D projection.
    # find camera intrinsic estimates
    

    # then nlopt for better intrinsics + distortion parameters
    
}

set ::checkerboardDetections [list]
set ::checkerboardLastDetectionTimestamp 0
When the checkerboard tag side length is /sideLength/ mm & \
     /someone/ detects tags /tags/ at /timestamp/ in time /aprilTime/ {

    if {[llength $::checkerboardDetections] >= 4} { return }

    set detection [dict create] ;# dict keyed by tag id for easy lookup
    foreach tag $tags { dict set detection [dict get $tag id] $tag }

    # Does it contain all of the calibration tags?
    if {($timestamp - $::checkerboardLastDetectionTimestamp > 2000) &&
        [isValidCheckerboardDetection $detection]} {
        puts "Capturing calibration checkerboard"
        lappend ::checkerboardDetections $detection
        set ::checkerboardLastDetectionTimestamp $timestamp
    }

    if {[llength $::checkerboardDetections] == 4} {
        puts "Detected 4 checkerboards. Calibrating."
        calibrate $sideLength $::checkerboardDetections
    }
}
