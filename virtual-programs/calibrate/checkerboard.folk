set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc code {
    #include <apriltag.h>
    #include <tagStandard52h13.h>
    apriltag_family_t *tf = NULL;

    #define emit(...) i += sprintf(&ret[i], __VA_ARGS__)
}
$cc proc ::tagCanvasImageForId {int id} char* {
    if (tf == NULL) tf = tagStandard52h13_create();

    image_u8_t* image = apriltag_to_image(tf, id);

    char* ret = ckalloc(100000);
    int i = 0;
    emit("ctx.save()\n");
    emit("ctx.scale(%f, %f);\n", (float)image->width, (float)image->height);
    for (int row = 0; row < image->height; row++) {
        for (int col = 0; col < image->width; col++) {
            uint8_t pixel = image->buf[(row * image->stride) + col];
            emit("ctx.fillStyle = 'rgb(%d, %d, %d)';", pixel, pixel, pixel);
            emit("ctx.beginPath();");
            emit("ctx.moveTo(%d, %d);", col, row); // bottom-left
            emit("ctx.lineTo(%d, %d);", col + 1, row); // bottom-right
            emit("ctx.lineTo(%d, %d);", col + 1, row + 1); // top-right
            emit("ctx.lineTo(%d, %d);", col, row + 1); // top-left
            emit("ctx.closePath(); ctx.fill();");
        }
        emit("\n");
    }
    emit("ctx.restore();\n");
    ret[i++] = '\0';
    image_u8_destroy(image);
    return ret;
}
$cc compile

set ROWS 4
set COLS 6

Wish the web server handles route "/calibrate$" with handler [list apply {{ROWS COLS} {
  upvar ^html ^html
  html [csubst {
    <html>
    <body>

    <p>
      Enter the side-length of a tag in millimeters:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Submit</button>
    </p>
    <script>
      function uuidv4() {
	  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
	    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
	  );
      }
      const self = uuidv4();

    document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
        // Report the side length to a statement in Folk.

        const mm = document.getElementById("tag-side-length-mm").value;

        window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
        ws.onopen = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
            Assert \${self} claims the checkerboard tag side length is \${mm} mm
         `);
        };
        window.onbeforeunload = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
          `);
        }
      });
    </script>

    <canvas id="tags-canvas" width="1280" height="720"></canvas>

    <script>
    const ctx = document.getElementById('tags-canvas').getContext('2d');
    
    $[apply {{} {
        upvar ROWS ROWS; upvar COLS COLS
        set images [list]
        for {set row 0} {$row < $ROWS} {incr row} {
            for {set col 0} {$col < $COLS} {incr col} {
                lappend images "ctx.save(); ctx.translate($col * 160, $row * 160);
                                [::tagCanvasImageForId [+ 48600 [llength $images]]]
                                ctx.restore();"
            }
        }
        return [join $images "\n"]
    }}]
    </script>
    </body>
    </html>
  }]
}} $ROWS $COLS]

fn isValidCheckerboardDetection {detection} {
    # Does this detection contain many/all of the calibration tags?
    set expectedTagId 48600
    for {set row 0} {$row < $ROWS} {incr row} {
        for {set col 0} {$col < $COLS} {incr col} {
            if {![dict exists $detection $expectedTagId]} {
                return false
            }
            incr expectedTagId
        }
    }
    return true

    # TODO: Check that the checkerboard occupies a solid majority of
    # the camera space.
}

package require math::linearalgebra
namespace import ::math::linearalgebra::*

fn findHomography {sideLength detection} {
    # x0 and y0 are camera points, from the camera image.
    fn detectionTagCorner {row col corner} {
        set id [expr {48600 + $row*$COLS + $col}]
        return [lindex [dict get [dict get $detection $id] corners] $corner]
    }

    lassign [detectionTagCorner 0 0 3] x3 y3 ;# top-left
    lassign [detectionTagCorner 0 [- $COLS 1] 2] x2 y2 ;# top-right
    lassign [detectionTagCorner [- $ROWS 1] [- $COLS 1] 1] x1 y1 ;# bottom-right
    lassign [detectionTagCorner [- $ROWS 1] 0 0] x0 y0 ;# bottom-left

    # u0 and v0 are model points, from the known geometry of the
    # checkerboard (in meters, where top-left corner of top-left
    # AprilTag is 0, 0).
    set u0 0; set v0 0
    set u1 [* $COLS $sideLength 1.6]; set v1 0
    set u2 [* $COLS $sideLength 1.6]; set v2 [* $ROWS $sideLength 1.6]
    set u3 0; set v3 [* $ROWS $sideLength 1.6]

    set A [subst {
        {$x0 $y0 1 0   0   0 [expr -$x0*$u0] [expr -$y0*$u0]}
        {$x1 $y1 1 0   0   0 [expr -$x1*$u1] [expr -$y1*$u1]}
        {$x2 $y2 1 0   0   0 [expr -$x2*$u2] [expr -$y2*$u2]}
        {$x3 $y3 1 0   0   0 [expr -$x3*$u3] [expr -$y3*$u3]}
        {0   0   0 $x0 $y0 1 [expr -$x0*$v0] [expr -$y0*$v0]}
        {0   0   0 $x1 $y1 1 [expr -$x1*$v1] [expr -$y1*$v1]}
        {0   0   0 $x2 $y2 1 [expr -$x2*$v2] [expr -$y2*$v2]}
        {0   0   0 $x3 $y3 1 [expr -$x3*$v3] [expr -$y3*$v3]}
    }]
    
    set b [list $u0 $u1 $u2 $u3 $v0 $v1 $v2 $v3]

    lassign [solvePGauss $A $b] a0 a1 a2 b0 b1 b2 c0 c1
    set H [subst {
        {$a0 $a1 $a2}
        {$b0 $b1 $b2}
        {$c0 $c1 1}
    }]
    return $H
}

fn processHomography {H} {
    fn h {i j} { getelem $H [- $j 1] [- $i 1] }

    fn v {i j} {
        list \
            [* [h $i 1] [h $j 1]] \
            [+ [* [h $i 1] [h $j 2]] [* [h $i 2] [h $j 1]]] \
            [* [h $i 2] [h $j 2]] \
            [+ [* [h $i 3] [h $j 1]] [* [h $i 1] [h $j 3]]] \
            [+ [* [h $i 3] [h $j 2]] [* [h $i 2] [h $j 3]]] \
            [* [h $i 3] [h $j 3]]
    }

    set V [list \
               [v 1 2] \
               [sub [v 1 1] [v 2 2]]]
    return $V
}

fn calibrate {sideLength detections} {
    # sideLength is inner side length of a tag, in meters.
    # detections is a list of N dictionaries of detected tags.

    # The below calibration technique is from Zhang
    # (https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf):

    # Compute N homographies (one homography for each detection):
    set Hs [lmap detection $detections {
        findHomography $sideLength $detection
    }]

    puts "Detections {$detections}"
    puts "Hs {$Hs}"

    # Construct V:
    set Vtop [list]; set Vbottom [list]
    foreach H $Hs {
        lassign [processHomography $H] Vtop_ Vbottom_
        lappend Vtop $Vtop_
        lappend Vbottom $Vbottom_
    }
    set V [list {*}$Vtop {*}$Vbottom]
    assert {[::math::linearalgebra::shape $V] eq [list [* 2 [llength $Hs]] 6]}

    # Solve Vb = 0:
    lassign [determineSVD [matmul [transpose $V] $V]] U S V'
    set b [lindex [transpose ${V'}] [lindex [lsort -real -indices $S] 0]]

    # Compute camera intrinsic matrix A:
    lassign $b B11 B12 B22 B13 B23 B33
    set v0 [expr {($B12*$B13 - $B11*$B23) / ($B11*$B22 - $B12*$B12)}]
    set lambda [expr {$B33 - ($B13*$B13 + $v0*($B12*$B13 - $B11*$B23))/$B11}]
    set alpha [expr {sqrt($lambda/$B11)}]
    set beta [expr {sqrt($lambda*$B11/($B11*$B22 - $B12*$B12))}]
    set gamma [expr {-$B12*$alpha*$alpha*$beta/$lambda}]
    set u0 [expr {$gamma*$v0/$beta - $B13*$alpha*$alpha/$lambda}]
    foreach var {v0 lambda alpha beta gamma u0} {
        puts "$var = [set $var]"
    }
    
    # then nlopt for better intrinsics + distortion parameters
}

set ::checkerboardDetections [list]
set ::checkerboardLastDetectionTimestamp 0
When the checkerboard tag side length is /sideLengthMm/ mm & \
     /someone/ detects tags /tags/ at /timestamp/ in time /aprilTime/ {

    if {[llength $::checkerboardDetections] >= 4} { return }

    set detection [dict create] ;# dict keyed by tag id for easy lookup
    foreach tag $tags { dict set detection [dict get $tag id] $tag }

    # Does it contain all of the calibration tags?
    if {($timestamp - $::checkerboardLastDetectionTimestamp > 2000) &&
        [isValidCheckerboardDetection $detection]} {
        puts "Capturing calibration checkerboard"
        lappend ::checkerboardDetections $detection
        set ::checkerboardLastDetectionTimestamp $timestamp
    }

    if {[llength $::checkerboardDetections] == 4} {
        puts "Detected 4 checkerboards. Calibrating."
        set sideLength [/ $sideLengthMm 1000.0] ;# in meters
        calibrate $sideLength $::checkerboardDetections
    }
}
