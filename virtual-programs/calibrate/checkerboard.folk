set cc [c create]
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
c loadlib $::env(HOME)/apriltag/libapriltag.so
$cc code {
    #include <apriltag.h>
    #include <tagStandard52h13.h>
    apriltag_family_t *tf = NULL;

    #define emit(...) i += sprintf(&ret[i], __VA_ARGS__)
}
$cc proc ::tagCanvasImageForId {int id} char* {
    if (tf == NULL) tf = tagStandard52h13_create();

    image_u8_t* image = apriltag_to_image(tf, id);

    char* ret = ckalloc(100000);
    int i = 0;
    emit("ctx.save()\n");
    emit("ctx.scale(%f, %f);\n", (float)image->width, (float)image->height);
    for (int row = 0; row < image->height; row++) {
        for (int col = 0; col < image->width; col++) {
            uint8_t pixel = image->buf[(row * image->stride) + col];
            emit("ctx.fillStyle = 'rgb(%d, %d, %d)';", pixel, pixel, pixel);
            emit("ctx.beginPath();");
            emit("ctx.moveTo(%d, %d);", col, row); // bottom-left
            emit("ctx.lineTo(%d, %d);", col + 1, row); // bottom-right
            emit("ctx.lineTo(%d, %d);", col + 1, row + 1); // top-right
            emit("ctx.lineTo(%d, %d);", col, row + 1); // top-left
            emit("ctx.closePath(); ctx.fill();");
        }
        emit("\n");
    }
    emit("ctx.restore();\n");
    ret[i++] = '\0';
    image_u8_destroy(image);
    return ret;
}
$cc compile

Wish the web server handles route "/calibrate$" with handler [list apply {{this} {
  upvar ^html ^html
  html [csubst {
    <html>
    <body>

    <p>
      Enter the side-length of a tag in millimeters:
      <input id="tag-side-length-mm" type="text">mm <button id="tag-side-length-submit">Submit</button>
    </p>
    <script>
      function uuidv4() {
	  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
	    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
	  );
      }
      const self = uuidv4();

    document.getElementById('tag-side-length-submit').addEventListener('click', (e) => {
        // Report the side length to a statement in Folk.

        const mm = document.getElementById("tag-side-length-mm").value;

        window.ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
        ws.onopen = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
            Assert \${self} claims the checkerboard tag side length is \${mm} mm
         `);
        };
        window.onbeforeunload = () => {
          ws.send(`
            set ::checkerboardDetections [list]
            Retract \${self} claims the checkerboard tag side length is /anything/ mm
          `);
        }
      });
    </script>

    <canvas id="tags-canvas" width="1280" height="720"></canvas>

    <script>
    const ctx = document.getElementById('tags-canvas').getContext('2d');
    
    $[apply {{} {
        set images [list]
        for {set row 0} {$row < 5} {incr row} {
            for {set col 0} {$col < 5} {incr col} {
                lappend images "ctx.save(); ctx.translate($col * 200, $row * 200);
                                [::tagCanvasImageForId [+ 10000 [llength $images]]]
                                ctx.restore();"
            }
        }
        return [join $images "\n"]
    }}]
    </script>
    </body>
    </html>
  }]
}} $this]

set ::checkerboardDetections [list]
When the checkerboard tag side length is /sideLength/ mm & \
     /someone/ detects tags /tags/ at /timestamp/ in time /aprilTime/ {
    # Does it contain many/all of the calibration tags?
    lassign [lindex $::checkerboardDetections end] _ lastTimestamp
    if {$lastTimestamp eq "" || $timestamp - $lastTimestamp > 1000} {
        puts "Capturing calibration checkerboard: $tags"
    }

    lappend ::checkerboardDetections [list $tags $timestamp]

    if {[llength $::checkerboardDetections] == 4} {
        puts "Detected 4 checkerboards"
    }
}
