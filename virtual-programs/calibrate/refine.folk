# refine.folk --
#
#     Implements nonlinear refinement of camera calibration (or
#     projector calibration, equivalently) (see Zhengyou Zhang) using
#     cmpfit.
#

# From https://courses.cs.duke.edu/cps274/fall13/notes/rodrigues.pdf:
proc rotationMatrixToRotationVector {R} {
    set A [scale 0.5 [sub $R [transpose $R]]]
    set rho [list [getelem $A 2 1] \
                 [getelem $A 0 2] \
                 [getelem $A 1 0]]
    set s [norm $rho]
    set c [expr {([getelem $R 0 0] + [getelem $R 1 1] + [getelem $R 2 2] - 1) / 2}]

    # If s = 0 and c = 1:
    if {abs($s) < 0.0001 && abs($c - 1) < 0.0001} {
        return {0 0 0}
    }
    # If s = 0 and c = -1:
    if {abs($s) < 0.0001 && abs($c - (-1)) < 0.0001} {
        # let v = a nonzero column of R + I
        set v [getcol [add $R [mkIdentity 3]] 0]
        set u [scale [/ 1.0 [norm $v]] $v]
        set r [scale 3.14159 $u]
        if {abs([norm $r] - 3.14159) < 0.0001 &&
            ((abs([getelem $r 0]) < 0.0001 &&
              abs([getelem $r 1]) < 0.0001 &&
              [getelem $r 2] < 0) ||
             (abs([getelem $r 0]) < 0.0001 &&
              [getelem $r 1] < 0) ||
             ([getelem $r 0] < 0))} {
            return [scale -1 $r]
        } else {
            return $r
        }
    }

    set u [scale [/ 1.0 $s] $rho]
    set theta [atan2 $s $c]
    return [scale $theta $u]
}

proc rotationVectorToRotationMatrix {r} {
    set theta [norm $r]
    if {abs($theta) < 0.0001} {
        return [mkIdentity 3]
    }
    set u [scale [/ 1.0 $theta] $r]
    set ux [list [list 0                       [* -1.0 [getelem $u 2]] [getelem $u 1]] \
                 [list [getelem $u 2]          0                       [* -1.0 [getelem $u 0]]] \
                 [list [* -1.0 [getelem $u 1]] [getelem $u 0]          0]]
    return [add [scale [cos $theta] [mkIdentity 3]] \
                [add [scale [expr {1.0 - cos($theta)}] \
                          [matmul $u [transpose $u]]] \
                     [scale [sin $theta] $ux]]]
}

When the calibration model is /MODEL/ {
    set cc [c create]
    $cc include <math.h>
    $cc include <string.h>
    $cc include <assert.h>
    $cc include "cmpfit/mpfit.h"
    $cc cflags ./vendor/cmpfit/mpfit.c
    $cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
    c loadlib $::env(HOME)/apriltag/libapriltag.so
    $cc include <apriltag_pose.h>
    $cc include <common/matd.h>
    $cc code [csubst {
        #define MAX_POINTS_PER_POSE $[* [dict size $MODEL] 4]
        #define NUM_POSES 10

        // We need to store as example points for fit, for each tag:
        // 1. camera detection homography (9 entries)
        // 2. camera-plane corners (4 corners with x, y in each)
        // 3. projector-plane corners (4 corners with x, y in each)
        // They are grouped by tag so that you can do one pose estimate per tag.
        double CameraTagHs[NUM_POSES * $[dict size $MODEL]][9];
        double CameraTagCorners[NUM_POSES * $[dict size $MODEL]][4][2];
        double ProjectorTagCorners[NUM_POSES * $[dict size $MODEL]][4][2];
        int TagsCount;

        double TagSize;

static matd_t* homography_compute2(double c[4][4]) {
    double A[] =  {
            c[0][0], c[0][1], 1,       0,       0, 0, -c[0][0]*c[0][2], -c[0][1]*c[0][2], c[0][2],
                  0,       0, 0, c[0][0], c[0][1], 1, -c[0][0]*c[0][3], -c[0][1]*c[0][3], c[0][3],
            c[1][0], c[1][1], 1,       0,       0, 0, -c[1][0]*c[1][2], -c[1][1]*c[1][2], c[1][2],
                  0,       0, 0, c[1][0], c[1][1], 1, -c[1][0]*c[1][3], -c[1][1]*c[1][3], c[1][3],
            c[2][0], c[2][1], 1,       0,       0, 0, -c[2][0]*c[2][2], -c[2][1]*c[2][2], c[2][2],
                  0,       0, 0, c[2][0], c[2][1], 1, -c[2][0]*c[2][3], -c[2][1]*c[2][3], c[2][3],
            c[3][0], c[3][1], 1,       0,       0, 0, -c[3][0]*c[3][2], -c[3][1]*c[3][2], c[3][2],
                  0,       0, 0, c[3][0], c[3][1], 1, -c[3][0]*c[3][3], -c[3][1]*c[3][3], c[3][3],
    };

    double epsilon = 1e-10;

    // Eliminate.
    for (int col = 0; col < 8; col++) {
        // Find best row to swap with.
        double max_val = 0;
        int max_val_idx = -1;
        for (int row = col; row < 8; row++) {
            double val = fabs(A[row*9 + col]);
            if (val > max_val) {
                max_val = val;
                max_val_idx = row;
            }
        }

        if (max_val < epsilon) {
            /* debug_print("WRN: Matrix is singular.\n"); */
            return NULL;
        }

        // Swap to get best row.
        if (max_val_idx != col) {
            for (int i = col; i < 9; i++) {
                double tmp = A[col*9 + i];
                A[col*9 + i] = A[max_val_idx*9 + i];
                A[max_val_idx*9 + i] = tmp;
            }
        }

        // Do eliminate.
        for (int i = col + 1; i < 8; i++) {
            double f = A[i*9 + col]/A[col*9 + col];
            A[i*9 + col] = 0;
            for (int j = col + 1; j < 9; j++) {
                A[i*9 + j] -= f*A[col*9 + j];
            }
        }
    }

    // Back solve.
    for (int col = 7; col >=0; col--) {
        double sum = 0;
        for (int i = col + 1; i < 8; i++) {
            sum += A[col*9 + i]*A[i*9 + 8];
        }
        A[col*9 + 8] = (A[col*9 + 8] - sum)/A[col*9 + col];
    }
    return matd_create_data(3, 3, (double[]) { A[8], A[17], A[26], A[35], A[44], A[53], A[62], A[71], 1 });
}
    }]
    $cc proc setTags {double tagSize
                      double[] cameraTagHs double[] cameraTagCorners
                      double[] projectorTagCorners
                      int tagsCount} void {
        TagSize = tagSize;
        int chi = 0; int cci = 0; int pi = 0;
        // For each tag:
        for (int i = 0; i < tagsCount; i++) {
            for (int j = 0; j < 9; j++) {
                CameraTagHs[i][j] = cameraTagHs[chi++];
            }
            // For each corner:
            for (int j = 0; j < 4; j++) {
                CameraTagCorners[i][j][0] = cameraTagCorners[cci++];
                CameraTagCorners[i][j][1] = cameraTagCorners[cci++];
                ProjectorTagCorners[i][j][0] = projectorTagCorners[pi++];
                ProjectorTagCorners[i][j][1] = projectorTagCorners[pi++];
            }
        }
        TagsCount = tagsCount;
    }
    $cc code {
        void rotationVectorToRotationMatrix(double r[3], double out[3][3]) {
            double theta = sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
            if (fabs(theta) < 0.0001) {
                double ret[3][3] = {
                    {1, 0, 0},
                    {0, 1, 0},
                    {0, 0, 1}
                };
                memcpy(out, ret, sizeof(ret));
                return;
            }
            double u[3] = {r[0]/theta, r[1]/theta, r[2]/theta};
            double ret[3][3] = {
                {cos(theta) + u[0]*u[0]*(1 - cos(theta)),
                 u[0]*u[1]*(1 - cos(theta)) - u[2]*sin(theta),
                 u[0]*u[2]*(1 - cos(theta)) + u[1]*sin(theta)},
                {u[0]*u[1]*(1 - cos(theta)) + u[2]*sin(theta),
                 cos(theta) + u[1]*u[1]*(1 - cos(theta)),
                 u[1]*u[2]*(1 - cos(theta)) - u[0]*sin(theta)},
                {u[0]*u[2]*(1 - cos(theta)) - u[1]*sin(theta),
                 u[1]*u[2]*(1 - cos(theta)) + u[0]*sin(theta),
                 cos(theta) + u[2]*u[2]*(1 - cos(theta))}
            };
            memcpy(out, ret, sizeof(ret));
        }
        void mulMat3Mat3(double A[3][3], double B[3][3], double out[3][3]) {
            memset(out, 0, sizeof(double) * 9);
            for (int y = 0; y < 3; y++) {
                for (int x = 0; x < 3; x++) {
                    for (int k = 0; k < 3; k++) {
                        out[y][x] += A[y][k] * B[k][x];
                    }
                }
            }
        }
        void mulMat3Vec3(double A[3][3], double x[3], double out[3]) {
            memset(out, 0, sizeof(double) * 3);
            for (int y = 0; y < 3; y++) {
                out[y] = A[y][0]*x[0] + A[y][1]*x[1] + A[y][2]*x[2];
            }
        }
        void transformVec3(double R[3][3], double t[3], double x[3],
                           double out[3]) {
            mulMat3Vec3(R, x, out);
            for (int i = 0; i < 3; i++) { out[i] += t[i]; }
        }
        void undistort(double fx, double fy, double cx, double cy,
                       double k1, double k2,
                       double xy[2], double out[2]) {
            double x = (xy[0] - cx)/fx;
            double y = (xy[1] - cy)/fy;
            for (int i = 0; i < 3; i++) {
                double r2 = x*x + y*y;
                double rad = 1.0 + k1 * r2 + k2 * r2*r2;
                x /= rad; y /= rad;
            }
            out[0] = x*fx + cx; out[1] = y*fy + cy;
        }
        void distort(double fx, double fy, double cx, double cy,
                     double k1, double k2,
                     double xy[2], double out[2]) {
            double x = (xy[0] - cx)/fx;
            double y = (xy[1] - cy)/fy;
            double r2 = x*x + y*y;
            double D = k1 * r2 + k2 * r2*r2;
            out[0] = (x * (1.0 + D))*fx + cx;
            out[1] = (y * (1.0 + D))*fy + cy;
        }
    }
    $cc proc func {int m int n double* x
                   double* fvec double** dvec
                   void* _} int {
        // Unwrap the parameters x[]:
        int k = 0;

        // Camera intrinsics:
        double cfx = x[k++];
        double cs = x[k++]; (void)cs;
        double ccx = x[k++];
        double cfy = x[k++];
        double ccy = x[k++];
        double ck1 = x[k++];
        double ck2 = x[k++];

        // Projector intrinsics:
        double pfx = x[k++];
        double ps = x[k++];
        double pcx = x[k++];
        double pfy = x[k++];
        double pcy = x[k++];
        double projectorIntrinsics[3][3] = {
            {pfx,   ps,  pcx},
            {  0,  pfy,  pcy},
            {  0,    0,    1}
        };
        double pk1 = x[k++];
        double pk2 = x[k++];

        double r[3] = { x[k], x[k+1], x[k+2] }; k += 3;
        double R_cameraToProjector[3][3];
        rotationVectorToRotationMatrix(r, R_cameraToProjector);
        double t_cameraToProjector[3];
        for (int i = 0; i < 3; i++) { t_cameraToProjector[i] = x[k++]; }

        assert(k == n);
        int f = 0;
        // For each tag:
        for (int tagNum = 0; tagNum < TagsCount; tagNum++) {
            apriltag_detection_t det; {
                for (int i = 0; i < 4; i++) {
                    // Undistort the tag corners into ideal camera
                    // space.
                    undistort(cfx, cfy, ccx, ccy, ck1, ck2,
                              CameraTagCorners[tagNum][i],
                              det.p[i]);
                    /* det.p[i][0] = CameraTagCorners[tagNum][i][0]; */
                    /* det.p[i][1] = CameraTagCorners[tagNum][i][1]; */
                }

                // Construct a new, undistorted homography.
                double corners[4][4] = {
                    {-1, 1, det.p[0][0], det.p[0][1]},
                    {1, 1, det.p[1][0], det.p[1][1]},
                    {1, -1, det.p[2][0], det.p[2][1]},
                    {-1, -1, det.p[3][0], det.p[3][1]}
                };
                det.H = homography_compute2(corners);
            }

            apriltag_detection_info_t info = {
                .det = &det,
                .tagsize = TagSize,
                .fx = cfx, .fy = cfy,
                .cx = ccx, .cy = ccy
            };
            apriltag_pose_t pose;
            double err = estimate_tag_pose(&info, &pose);
            matd_destroy(det.H);
            (void) err;
            // Now we have pose.R and pose.t.

            // For each corner:
            for (int i = 0; i < 4; i++) {
                // Get this corner in tag-frame space.
                double tagFrameCorner[3] = {0};
                if (i == 0)      { tagFrameCorner[0] = -TagSize/2; tagFrameCorner[1] = TagSize/2; }
                else if (i == 1) { tagFrameCorner[0] = TagSize/2;  tagFrameCorner[1] = TagSize/2; }
                else if (i == 2) { tagFrameCorner[0] = TagSize/2;  tagFrameCorner[1] = -TagSize/2; }
                else if (i == 3) { tagFrameCorner[0] = -TagSize/2; tagFrameCorner[1] = -TagSize/2; }

                // Use pose.R and pose.t to transform it into camera-frame space.
                double cameraFrameCorner[3];
                transformVec3((double(*)[3])pose.R->data, pose.t->data,
                              tagFrameCorner, cameraFrameCorner);

                // Use R and t to transform it into projector-frame space.
                double projectorFrameCorner[3];
                transformVec3((double(*)[3])R_cameraToProjector, t_cameraToProjector,
                              cameraFrameCorner, projectorFrameCorner);

                // Use projector intrinsics to downproject it to 2D coordinates.
                double reprojCorner[3];
                mulMat3Vec3(projectorIntrinsics, projectorFrameCorner,
                            reprojCorner);
                reprojCorner[0] /= reprojCorner[2];
                reprojCorner[1] /= reprojCorner[2];
                reprojCorner[2] = 1;

                // Use projector distortion coefficients to distort
                // the 2D coordinates.
                /* (void)pk1; (void)pk2; */
                distort(pfx, pfy, pcx, pcy, pk1, pk2,
                        reprojCorner, reprojCorner);

                double dx = reprojCorner[0] - ProjectorTagCorners[tagNum][i][0];
                double dy = reprojCorner[1] - ProjectorTagCorners[tagNum][i][1];
                /* printf("%d (%d): Orig (%f %f) -> Reproj (%f %f)\n", */
                /*        tagNum, i, */
                /*        ProjectorTagCorners[tagNum][i][0], ProjectorTagCorners[tagNum][i][1], */
                /*        reprojCorner[0], reprojCorner[1]); */
                fvec[f++] = sqrt(dx*dx + dy*dy);
            }
            free(pose.R); free(pose.t);
        }

        return 0;
    }
    $cc proc computeError {double[] params int paramsCount} void {
        double fvec[TagsCount * 4];
        func(TagsCount * 4, paramsCount, params, fvec, NULL, NULL);
        double totalError = 0;
        for (int i = 0; i < TagsCount * 4; i++) {
            printf("  Error Tag %d (%d): %f\n", i/4, i%4, fvec[i]);
            totalError += fvec[i];
        }
        printf("Total Error: %f\n", totalError);
    }
    $cc proc refineCalibrationOptimize {double[] params int paramsCount} Tcl_Obj* {
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        
        mp_result result = {0};

        assert(paramsCount == 7 + 7 + 3 + 3);
        printf("Unrefined -----------------\n");
        computeError(params, paramsCount);

        mpfit(func,
              // Number of example point pairs:
              TagsCount * 4,
              // Number of parameters to optimize:
              paramsCount,
              params, NULL,
              NULL, NULL, &result);
        printf("Refined -------------------\n");
        computeError(params, paramsCount);

        Tcl_Obj* paramObjs[paramsCount];
        for (int i = 0; i < paramsCount; i++) {
            paramObjs[i] = Tcl_NewDoubleObj(params[i]);
        }
        return Tcl_NewListObj(paramsCount, paramObjs);
    }
    $cc compile ;# takes about a half-second

    # poses is a list of NUM_POSES pose-lists. Each pose-list is a
    # list of up to MAX_POINTS_PER_POSE lists of 4 doubles
    # (model-plane point pairs). These are used to measure error in
    # the refinement process.
    set refineCalibration {{tagSize calibrationPoses calibration} {
        upvar ^isProjectedTag ^isProjectedTag
        upvar ^applyHomography ^applyHomography

        # Load the example data for fitting.

        set cameraTagHs [list]
        set cameraTagCorners [list]
        set projectorTagCorners [list]
        set poseIdx 0
        foreach calibrationPose $calibrationPoses {
            puts -nonewline "pose $poseIdx: tags [llength $cameraTagHs] "
            incr poseIdx

            set H_modelToProjector [dict get $calibrationPose H_modelToDisplay]
            dict for {id cameraTag} [dict get $calibrationPose tags] {
                if {![isProjectedTag $id]} continue

                lappend cameraTagHs [concat {*}[dict get $cameraTag H]]
                foreach cameraCorner [dict get $cameraTag p] {
                    lappend cameraTagCorners $cameraCorner                    
                }

                set modelTag [dict get $calibrationPose model $id]
                foreach modelCorner [dict get $modelTag p] {
                    set projectorCorner [applyHomography $H_modelToProjector $modelCorner]
                    lappend projectorTagCorners $projectorCorner
                }
            }

            puts "to [- [llength $cameraTagHs] 1]"
        }
        setTags $tagSize \
            [concat {*}$cameraTagHs] [concat {*}$cameraTagCorners] \
            [concat {*}$projectorTagCorners] \
            [llength $cameraTagHs]

        # Load the initial guesses for all parameters for fitting.

        set cameraIntrinsics [dict get $calibration camera intrinsics]
        lassign [getrow $cameraIntrinsics 0] cameraFx cameraS cameraCx
        lassign [getrow $cameraIntrinsics 1] _ cameraFy cameraCy

        set projectorIntrinsics [dict get $calibration projector intrinsics]
        lassign [getrow $projectorIntrinsics 0] projectorFx projectorS projectorCx
        lassign [getrow $projectorIntrinsics 1] _ projectorFy projectorCy

        set params [list $cameraFx $cameraS $cameraCx $cameraFy $cameraCy \
                        [dict get $calibration camera k1] \
                        [dict get $calibration camera k2] \
                        $projectorFx $projectorS $projectorCx $projectorFy $projectorCy \
                        [dict get $calibration projector k1] \
                        [dict get $calibration projector k2]]

        set R_cameraToProjector [dict get $calibration R_cameraToProjector]
        lappend params {*}[rotationMatrixToRotationVector $R_cameraToProjector]
        set t_cameraToProjector [dict get $calibration t_cameraToProjector]
        lappend params {*}$t_cameraToProjector

        # Do the actual optimization:

        set refined [refineCalibrationOptimize $params [llength $params]]

        # Unspool the optimization result into the calibration data
        # structure and return that.

        set refined [lassign $refined cameraFx cameraS cameraCx cameraFy cameraCy \
                        cameraK1 cameraK2]
        dict set calibration camera intrinsics [subst {
            {$cameraFx  $cameraS   $cameraCx}
            {0          $cameraFy  $cameraCy}
            {0          0                  1}
        }]
        dict set calibration camera k1 $cameraK1
        dict set calibration camera k2 $cameraK2
        set refined [lassign $refined projectorFx projectorS projectorCx projectorFy projectorCy \
                        projectorK1 projectorK2]
        dict set calibration projector intrinsics [subst {
            {$projectorFx  $projectorS   $projectorCx}
            {0             $projectorFy  $projectorCy}
            {0             0                        1}
        }]
        dict set calibration projector k1 $projectorK1
        dict set calibration projector k2 $projectorK2

        puts "Remaining refined: ($refined)"
        dict set calibration R_cameraToProjector [rotationVectorToRotationMatrix [lrange $refined 0 2]]
        dict set calibration t_cameraToProjector [lrange $refined 3 5]

        return $calibration
    }}

    Claim the calibration refiner is $refineCalibration
}
