# refine.folk --
#
#     Implements nonlinear refinement of camera calibration (or
#     projector calibration, equivalently) (see Zhengyou Zhang) using
#     cmpfit.
#

# From https://courses.cs.duke.edu/cps274/fall13/notes/rodrigues.pdf:
proc rotationMatrixToRotationVector {R} {
    set A [scale 0.5 [sub $R [transpose $R]]]
    set rho [list [getelem $A 2 1] \
                 [getelem $A 0 2] \
                 [getelem $A 1 0]]
    set s [norm $rho]
    set c [expr {([getelem $R 0 0] + [getelem $R 1 1] + [getelem $R 2 2] - 1) / 2}]

    # If s = 0 and c = 1:
    if {abs($s) < 0.0001 && abs($c - 1) < 0.0001} {
        return {0 0 0}
    }
    # If s = 0 and c = -1:
    if {abs($s) < 0.0001 && abs($c - (-1)) < 0.0001} {
        # let v = a nonzero column of R + I
        set v [getcol [add $R [mkIdentity 3]] 0]
        set u [scale [/ 1.0 [norm $v]] $v]
        set r [scale 3.14159 $u]
        if {abs([norm $r] - 3.14159) < 0.0001 &&
            ((abs([getelem $r 0]) < 0.0001 &&
              abs([getelem $r 1]) < 0.0001 &&
              [getelem $r 2] < 0) ||
             (abs([getelem $r 0]) < 0.0001 &&
              [getelem $r 1] < 0) ||
             ([getelem $r 0] < 0))} {
            return [scale -1 $r]
        } else {
            return $r
        }
    }

    set u [scale [/ 1.0 $s] $rho]
    set theta [atan2 $s $c]
    return [scale $theta $u]
}

proc rotationVectorToRotationMatrix {r} {
    set theta [norm $r]
    if {abs($theta) < 0.0001} {
        return [mkIdentity 3]
    }
    set u [scale [/ 1.0 $theta] $r]
    set ux [list [list 0                       [* -1.0 [getelem $u 2]] [getelem $u 1]] \
                 [list [getelem $u 2]          0                       [* -1.0 [getelem $u 0]]] \
                 [list [* -1.0 [getelem $u 1]] [getelem $u 0]          0]]
    return [add [scale [cos $theta] [mkIdentity 3]] \
                [add [scale [expr {1.0 - cos($theta)}] \
                          [matmul $u [transpose $u]]] \
                     [scale [sin $theta] $ux]]]
}

When the calibration model is /MODEL/ {
    set cc [c create]
    $cc include <math.h>
    $cc include <string.h>
    $cc include <assert.h>
    $cc include "cmpfit/mpfit.h"
    $cc cflags ./vendor/cmpfit/mpfit.c
    $cc code [csubst {
        #define MAX_POINTS_PER_POSE $[* [dict size $MODEL] 4]
        #define NUM_POSES 10

        double Poses[NUM_POSES][MAX_POINTS_PER_POSE][4];
        int PoseCounts[NUM_POSES];
    }]
    $cc proc setPose {int poseNum double[] pointPairs int pointPairsCount} void {
        for (int i = 0; i < pointPairsCount; i++) {
            Poses[poseNum][i][0] = pointPairs[i * 4 + 0];
            Poses[poseNum][i][1] = pointPairs[i * 4 + 1];
            Poses[poseNum][i][2] = pointPairs[i * 4 + 2];
            Poses[poseNum][i][3] = pointPairs[i * 4 + 3];
        }
        PoseCounts[poseNum] = pointPairsCount;
    }
    $cc code {
        void rotationVectorToRotationMatrix(double r[3], double out[3][3]) {
            double theta = sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
            if (fabs(theta) < 0.0001) {
                double ret[3][3] = {
                    {1, 0, 0},
                    {0, 1, 0},
                    {0, 0, 1}
                };
                memcpy(out, ret, sizeof(ret));
                return;
            }
            double u[3] = {r[0]/theta, r[1]/theta, r[2]/theta};
            double ret[3][3] = {
                {cos(theta) + u[0]*u[0]*(1 - cos(theta)),
                 u[0]*u[1]*(1 - cos(theta)) - u[2]*sin(theta),
                 u[0]*u[2]*(1 - cos(theta)) + u[1]*sin(theta)},
                {u[0]*u[1]*(1 - cos(theta)) + u[2]*sin(theta),
                 cos(theta) + u[1]*u[1]*(1 - cos(theta)),
                 u[1]*u[2]*(1 - cos(theta)) - u[0]*sin(theta)},
                {u[0]*u[2]*(1 - cos(theta)) - u[1]*sin(theta),
                 u[1]*u[2]*(1 - cos(theta)) + u[0]*sin(theta),
                 cos(theta) + u[2]*u[2]*(1 - cos(theta))}
            };
            memcpy(out, ret, sizeof(ret));
        }
        void mulMat3Mat3(double A[3][3], double B[3][3], double out[3][3]) {
            memset(out, 0, sizeof(double) * 9);
            for (int y = 0; y < 3; y++) {
                for (int x = 0; x < 3; x++) {
                    for (int k = 0; k < 3; k++) {
                        out[y][x] += A[y][k] * B[k][x];
                    }
                }
            }
        }
        void mulMat3Vec3(double A[3][3], double x[3], double out[3]) {
            memset(out, 0, sizeof(double) * 3);
            for (int y = 0; y < 3; y++) {
                out[y] = A[y][0]*x[0] + A[y][1]*x[1] + A[y][2]*x[2];
            }
        }
    }
    $cc proc func {int m int n double* x
                   double* fvec double** dvec
                   void* _} int {
        assert(m <= MAX_POINTS_PER_POSE * NUM_POSES);

        // Unwrap the parameters x[]:
        int k = 0;

        double fx = x[k++];
        double s = x[k++];
        double cx = x[k++];
        double fy = x[k++];
        double cy = x[k++];
        double A[3][3] = {
            {fx,   s,  cx},
            { 0,  fy,  cy},
            { 0,   0,   1}
        };
        double k1 = x[k++];
        double k2 = x[k++];
        (void)k1; (void)k2;

        int f = 0;
        // For each pose:
        for (int poseNum = 0; poseNum < NUM_POSES; poseNum++) {
            double r[3] = { x[k], x[k+1], x[k+2] }; k += 3;
            double R[3][3]; rotationVectorToRotationMatrix(r, R);
            /* printf("pose %d: Rotation vector: {%f, %f, %f}\n", poseNum, r[0], r[1], r[2]); */
            /* printf("pose %d: Rotation matrix:\n" */
            /*        "{%f, %f, %f}\n" */
            /*        "{%f, %f, %f}\n" */
            /*        "{%f, %f, %f}\n", poseNum, */
            /*        R[0][0], R[0][1], R[0][2], */
            /*        R[1][0], R[1][1], R[1][2], */
            /*        R[2][0], R[2][1], R[2][2]); */

            double r0[3] = { R[0][0], R[1][0], R[2][0] };
            double r1[3] = { R[0][1], R[1][1], R[2][1] };

            double t[3] = { x[k], x[k+1], x[k+2] }; k += 3;
            double r0r1t[3][3] = {
                { r0[0], r1[0], t[0] },
                { r0[1], r1[1], t[1] },
                { r0[2], r1[2], t[2] }
            };
            // This homography takes model-plane points and
            // reprojects them onto the pose plane.
            double H[3][3]; mulMat3Mat3(A, r0r1t, H);

            // For each point in the pose:
            for (int i = 0; i < PoseCounts[poseNum]; i++) {
                double modelX = Poses[poseNum][i][0];
                double modelY = Poses[poseNum][i][1];
                double modelPointHom[3] = { modelX, modelY, 1 };

                double reprojectedPosePoint[3];
                mulMat3Vec3(H, modelPointHom, reprojectedPosePoint);
                double idealReprojX = reprojectedPosePoint[0] / reprojectedPosePoint[2];
                double idealReprojY = reprojectedPosePoint[1] / reprojectedPosePoint[2];

                // Distort idealReprojX and idealReprojY using the distortion
                // coefficients.
                double x = (idealReprojX - cx);
                double y = (idealReprojY - cy);
                double r = sqrt(x*x + y*y);
                double D = k1 * r*r + k2 * r*r*r*r;
                double distortedReprojX = idealReprojX * (1.0 + D);
                double distortedReprojY = idealReprojY * (1.0 + D);
 
                double posePoint[2] = { Poses[poseNum][i][2], Poses[poseNum][i][3] };

                double dx = distortedReprojX - posePoint[0];
                double dy = distortedReprojY - posePoint[1];
                fvec[f++] = sqrt(dx * dx + dy * dy);
            }
        }
        return 0;
    }
    $cc proc computeError {int totalPoseCount int paramCount double[] params} void {
        double fvec[totalPoseCount];
        func(totalPoseCount, paramCount, params, fvec, NULL, NULL);
        double totalError = 0;
        for (int i = 0; i < totalPoseCount; i++) { totalError += fvec[i]; }
        printf("Total Error: %f\n", totalError);
    }
    $cc proc refineCalibrationOptimize {double[] params} Tcl_Obj* {
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        
        mp_result result = {0};
        int totalPoseCount = 0;
        for (int i = 0; i < NUM_POSES; i++) {
            totalPoseCount += PoseCounts[i];
        }
        int paramCount = 7 + NUM_POSES*6;
        printf("Unrefined:");
        computeError(totalPoseCount, paramCount, params);
        
        mpfit(func,
              // Number of example point pairs:
              totalPoseCount,
              // Number of parameters to optimize:
              paramCount,
              params, NULL,
              NULL, NULL, &result);
        printf("Refined:");
        computeError(totalPoseCount, paramCount, params);

        Tcl_Obj* paramObjs[paramCount];
        for (int i = 0; i < paramCount; i++) {
            paramObjs[i] = Tcl_NewDoubleObj(params[i]);
        }
        return Tcl_NewListObj(paramCount, paramObjs);
    }
    $cc compile ;# takes about a half-second

    # poses is a list of NUM_POSES pose-lists. Each pose-list is a
    # list of up to MAX_POINTS_PER_POSE lists of 4 doubles
    # (model-plane point pairs). These are used to measure error in
    # the refinement process.
    set refineCalibration {{poses calibration} {
        set A [dict get $calibration intrinsics]
        lassign [getrow $A 0] fx s cx; lassign [getrow $A 1] _ fy cy
        set k1 [dict get $calibration k1]
        set k2 [dict get $calibration k2]

        set params [list $fx $s $cx $fy $cy $k1 $k2]

        set extrinsics [dict get $calibration extrinsics]
        # For each pose:
        for {set i 0} {$i < [llength $poses]} {incr i} {
            set pointPairs [lindex $poses $i]
            setPose $i [concat {*}$pointPairs] [llength $pointPairs]

            # Unravel extrinsics into params
            set R [dict get [lindex $extrinsics $i] R]
            lappend params {*}[rotationMatrixToRotationVector $R]
            lappend params {*}[dict get [lindex $extrinsics $i] t]
        }

        set refined [refineCalibrationOptimize $params]
        puts "++++++++++++++++++++++"
        puts "Refined:"
        # puts "refined ($refined)"

        set refined [lassign $refined fx s cx fy cy k1 k2]
        puts "   Focal Length: \[ $fx $fy ]"
        puts "Principal Point: \[ $cx $cy ]"
        puts "           Skew: \[ $s ] "
        puts "     Distortion: \[ $k1 $k2 ] "
        dict set calibration intrinsics [subst {
            {$fx  $s   $cx}
            {0    $fy  $cy}
            {0    0    1}
        }]
        dict set calibration k1 $k1
        dict set calibration k2 $k2
        for {set i 0} {$i < [llength $poses]} {incr i} {
            set r [lrange $refined [expr {$i*6}] [expr {$i*6 + 2}]]
            set R [rotationVectorToRotationMatrix $r]
            # puts "Old R:\n[math::linearalgebra::show [dict get [lindex $extrinsics $i] R]]"
            # puts "New R:\n[math::linearalgebra::show $R]"
            set t [lrange $refined [expr {$i*6 + 3}] [expr {$i*6 + 5}]]
            lset extrinsics $i [dict create R $R t $t]
        }
        dict set calibration extrinsics $extrinsics
        return $calibration
    }}
    Claim the calibration refiner is $refineCalibration
}
