# refine.folk --
#
#     Implements nonlinear refinement of camera calibration (or
#     projector calibration, equivalently) (see Zhengyou Zhang) using
#     cmpfit.
#

When the calibration model is /MODEL/ {
    set cc [c create]
    $cc include <math.h>
    $cc include <string.h>
    $cc include <assert.h>
    $cc include "cmpfit/mpfit.h"
    $cc cflags ./vendor/cmpfit/mpfit.c
    $cc code [csubst {
        #define MAX_POINTS_PER_POSE $[* [dict size $MODEL] 4]
        #define NUM_POSES 10

        double Poses[NUM_POSES][MAX_POINTS_PER_POSE][4];
        int PoseCounts[NUM_POSES];
    }]
    $cc proc setPose {int poseNum double[] pointPairs int pointPairsCount} void {
        for (int i = 0; i < pointPairsCount; i++) {
            Poses[poseNum][i][0] = pointPairs[i * 4 + 0];
            Poses[poseNum][i][1] = pointPairs[i * 4 + 1];
            Poses[poseNum][i][2] = pointPairs[i * 4 + 2];
            Poses[poseNum][i][3] = pointPairs[i * 4 + 3];
        }
        PoseCounts[poseNum] = pointPairsCount;
    }
    $cc code {
        void mulMat3Mat3(double A[3][3], double B[3][3], double out[3][3]) {
            memset(out, 0, sizeof(double) * 9);
            for (int y = 0; y < 3; y++) {
                for (int x = 0; x < 3; x++) {
                    for (int k = 0; k < 3; k++) {
                        out[y][x] += A[y][k] * B[k][x];
                    }
                }
            }
        }
        void mulMat3Vec3(double A[3][3], double x[3], double out[3]) {
            memset(out, 0, sizeof(double) * 3);
            for (int y = 0; y < 3; y++) {
                out[y] = A[y][0]*x[0] + A[y][1]*x[1] + A[y][2]*x[2];
            }
        }
    }
    $cc proc func {int m int n double* x
                   double* fvec double** dvec
                   void* _} int {
        assert(m <= MAX_POINTS_PER_POSE * NUM_POSES);

        // Unwrap the parameters x[]:
        int k = 0;

        double fx = x[k++];
        double s = x[k++];
        double cx = x[k++];
        double fy = x[k++];
        double cy = x[k++];
        double A[3][3] = {
            {fx,   s,  cx},
            { 0,  fy,  cy},
            { 0,   0,   1}
        };

        int f = 0;               
        for (int poseNum = 0; poseNum < NUM_POSES; poseNum++) {
            // For each pose:
            double r0[3] = { x[k++], x[k++], x[k++] };
            double r1[3] = { x[k++], x[k++], x[k++] };
            double t[3] = { x[k++], x[k++], x[k++] };
            double r0r1t[3][3] = {
                { r0[0], r1[0], t[0] },
                { r0[1], r1[1], t[1] },
                { r0[2], r1[2], t[2] }
            };
            // This homography takes model-plane points and
            // reprojects them onto the pose plane.
            double H[3][3]; mulMat3Mat3(A, r0r1t, H);

            // For each point in the pose:
            for (int i = 0; i < PoseCounts[poseNum]; i++) {
                double modelX = Poses[poseNum][i][0];
                double modelY = Poses[poseNum][i][1];
                double modelPointHom[3] = { modelX, modelY, 1 };

                double reprojectedPosePoint[3];
                mulMat3Vec3(H, modelPointHom, reprojectedPosePoint);
                reprojectedPosePoint[0] /= reprojectedPosePoint[2];
                reprojectedPosePoint[1] /= reprojectedPosePoint[2];
                reprojectedPosePoint[2] = 1;

                double posePoint[2] = { Poses[poseNum][i][2], Poses[poseNum][i][3] };

                double dx = reprojectedPosePoint[0] - posePoint[0];
                double dy = reprojectedPosePoint[1] - posePoint[1];
                fvec[f++] = sqrt(dx * dx + dy * dy);
            }
        }
        return 0;
    }
    $cc proc refineCalibrationOptimize {double[] params} Tcl_Obj* {
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        
        mp_result result = {0};
        int totalPoseCount = 0;
        for (int i = 0; i < NUM_POSES; i++) {
            totalPoseCount += PoseCounts[i];
        }
        int paramCount = 5 + NUM_POSES*9;
        mpfit(func,
              // Number of example point pairs:
              totalPoseCount,
              // Number of parameters to optimize:
              paramCount,
              params, NULL,
              NULL, NULL, &result);
        printf("Optimized\n");

        Tcl_Obj* paramObjs[paramCount];
        for (int i = 0; i < paramCount; i++) {
            paramObjs[i] = Tcl_NewDoubleObj(params[i]);
        }
        return Tcl_NewListObj(paramCount, paramObjs);
    }
    $cc compile ;# takes about a half-second

    # poses is a list of NUM_POSES pose-lists. Each pose-list is a
    # list of up to MAX_POINTS_PER_POSE lists of 4 doubles
    # (model-plane point pairs). These are used to measure error in
    # the refinement process.
    set refineCalibration {{poses calibration} {
        set A [dict get $calibration intrinsics]
        lassign [getrow $A 0] fx s cx; lassign [getrow $A 1] _ fy cy

        set params [list $fx $s $cx $fy $cy]

        set extrinsics [dict get $calibration extrinsics]
        # For each pose:
        for {set i 0} {$i < [llength $poses]} {incr i} {
            set pointPairs [lindex $poses $i]
            setPose $i [concat {*}$pointPairs] [llength $pointPairs]

            set R [dict get [lindex $extrinsics $i] R]
            # Unravel extrinsics into params
            lappend params {*}[getcol $R 0]
            lappend params {*}[getcol $R 1]
            lappend params {*}[dict get [lindex $extrinsics $i] t]
        }

        set refined [refineCalibrationOptimize $params]
        puts "++++++++++++++++++++++"
        puts "refined ($refined)"

        set refined [lassign $refined fx s cx fy cy]
        for {set i 0} {$i < [llength $poses]} {incr i} {
            # TODO: Mutate R (r0, r1)
            # TODO: Mutate t
        }
        # TODO: Re-ravel refined parameters
        # TODO: Write-back and return new intrinsics and extrinsics
    }}
    Claim the calibration refiner is $refineCalibration
}
