# refine.folk --
#
#     Implements nonlinear refinement of camera calibration (or
#     projector calibration, equivalently) (see Zhengyou Zhang) using
#     cmpfit.
#

# From https://courses.cs.duke.edu/cps274/fall13/notes/rodrigues.pdf:
proc rotationMatrixToRotationVector {R} {
    set A [scale 0.5 [sub $R [transpose $R]]]
    set rho [list [getelem $A 2 1] \
                 [getelem $A 0 2] \
                 [getelem $A 1 0]]
    set s [norm $rho]
    set c [expr {([getelem $R 0 0] + [getelem $R 1 1] + [getelem $R 2 2] - 1) / 2}]

    # If s = 0 and c = 1:
    if {abs($s) < 0.0001 && abs($c - 1) < 0.0001} {
        return {0 0 0}
    }
    # If s = 0 and c = -1:
    if {abs($s) < 0.0001 && abs($c - (-1)) < 0.0001} {
        # let v = a nonzero column of R + I
        set v [getcol [add $R [mkIdentity 3]] 0]
        set u [scale [/ 1.0 [norm $v]] $v]
        set r [scale 3.14159 $u]
        if {abs([norm $r] - 3.14159) < 0.0001 &&
            ((abs([getelem $r 0]) < 0.0001 &&
              abs([getelem $r 1]) < 0.0001 &&
              [getelem $r 2] < 0) ||
             (abs([getelem $r 0]) < 0.0001 &&
              [getelem $r 1] < 0) ||
             ([getelem $r 0] < 0))} {
            return [scale -1 $r]
        } else {
            return $r
        }
    }

    set u [scale [/ 1.0 $s] $rho]
    set theta [atan2 $s $c]
    return [scale $theta $u]
}

proc rotationVectorToRotationMatrix {r} {
    set theta [norm $r]
    if {abs($theta) < 0.0001} {
        return [mkIdentity 3]
    }
    set u [scale [/ 1.0 $theta] $r]
    set ux [list [list 0                       [* -1.0 [getelem $u 2]] [getelem $u 1]] \
                 [list [getelem $u 2]          0                       [* -1.0 [getelem $u 0]]] \
                 [list [* -1.0 [getelem $u 1]] [getelem $u 0]          0]]
    return [add [scale [cos $theta] [mkIdentity 3]] \
                [add [scale [expr {1.0 - cos($theta)}] \
                          [matmul $u [transpose $u]]] \
                     [scale [sin $theta] $ux]]]
}

When the calibration model is /MODEL/ {
    set cc [c create]
    $cc include <math.h>
    $cc include <string.h>
    $cc include <assert.h>
    $cc include "cmpfit/mpfit.h"
    $cc cflags ./vendor/cmpfit/mpfit.c
    $cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
    c loadlib $::env(HOME)/apriltag/libapriltag.so
    $cc include <apriltag_pose.h>
    $cc include <common/matd.h>
    $cc code [csubst {
        #define MAX_POINTS_PER_POSE $[* [dict size $MODEL] 4]
        #define NUM_POSES 10

        int PointsCount;
        int PosePointsCount[NUM_POSES];
        double PoseModelPoints[NUM_POSES][MAX_POINTS_PER_POSE][3];
        double PosePoints[NUM_POSES][MAX_POINTS_PER_POSE][2];
    }]
    $cc proc setPoints {int[] posePointsCount
                        double[] poseModelPoints
                        double[] posePoints} void {
        int mi = 0; int pi = 0;
        PointsCount = 0;
        for (int poseIdx = 0; poseIdx < NUM_POSES; poseIdx++) {
            PosePointsCount[poseIdx] = posePointsCount[poseIdx];
            PointsCount += PosePointsCount[poseIdx];
            for (int i = 0; i < PosePointsCount[poseIdx]; i++) {
                for (int j = 0; j < 3; j++) {
                    PoseModelPoints[poseIdx][i][j] = poseModelPoints[mi++];
                }
                for (int j = 0; j < 2; j++) {
                    PosePoints[poseIdx][i][j] = posePoints[pi++];
                }
            }
        }
    }

    $cc code {
        void rotationVectorToRotationMatrix(double r[3], double out[3][3]) {
            double theta = sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
            if (fabs(theta) < 0.0001) {
                double ret[3][3] = {
                    {1, 0, 0},
                    {0, 1, 0},
                    {0, 0, 1}
                };
                memcpy(out, ret, sizeof(ret));
                return;
            }
            double u[3] = {r[0]/theta, r[1]/theta, r[2]/theta};
            double ret[3][3] = {
                {cos(theta) + u[0]*u[0]*(1 - cos(theta)),
                 u[0]*u[1]*(1 - cos(theta)) - u[2]*sin(theta),
                 u[0]*u[2]*(1 - cos(theta)) + u[1]*sin(theta)},
                {u[0]*u[1]*(1 - cos(theta)) + u[2]*sin(theta),
                 cos(theta) + u[1]*u[1]*(1 - cos(theta)),
                 u[1]*u[2]*(1 - cos(theta)) - u[0]*sin(theta)},
                {u[0]*u[2]*(1 - cos(theta)) - u[1]*sin(theta),
                 u[1]*u[2]*(1 - cos(theta)) + u[0]*sin(theta),
                 cos(theta) + u[2]*u[2]*(1 - cos(theta))}
            };
            memcpy(out, ret, sizeof(ret));
        }
        void mulMat3Mat3(double A[3][3], double B[3][3], double out[3][3]) {
            memset(out, 0, sizeof(double) * 9);
            for (int y = 0; y < 3; y++) {
                for (int x = 0; x < 3; x++) {
                    for (int k = 0; k < 3; k++) {
                        out[y][x] += A[y][k] * B[k][x];
                    }
                }
            }
        }
        void mulMat3Vec3(double A[3][3], double x[3], double out[3]) {
            memset(out, 0, sizeof(double) * 3);
            for (int y = 0; y < 3; y++) {
                out[y] = A[y][0]*x[0] + A[y][1]*x[1] + A[y][2]*x[2];
            }
        }
        void transformVec3(double R[3][3], double t[3], double x[3],
                           double out[3]) {
            mulMat3Vec3(R, x, out);
            for (int i = 0; i < 3; i++) { out[i] += t[i]; }
        }
        void undistort(double fx, double fy, double cx, double cy,
                       double k1, double k2,
                       double xy[2], double out[2]) {
            double x = (xy[0] - cx)/fx;
            double y = (xy[1] - cy)/fy;
            for (int i = 0; i < 3; i++) {
                double r2 = x*x + y*y;
                double rad = 1.0 + k1 * r2 + k2 * r2*r2;
                x /= rad; y /= rad;
            }
            out[0] = x*fx + cx; out[1] = y*fy + cy;
        }
        void distort(double fx, double fy, double cx, double cy,
                     double k1, double k2,
                     double xy[2], double out[2]) {
            double x = (xy[0] - cx)/fx;
            double y = (xy[1] - cy)/fy;
            double r2 = x*x + y*y;
            double D = k1 * r2 + k2 * r2*r2;
            out[0] = (x * (1.0 + D))*fx + cx;
            out[1] = (y * (1.0 + D))*fy + cy;
        }
    }
    $cc proc func {int m int n double* x
                   double* fvec double** dvec
                   void* _} int {
        // Unwrap the parameters x[]:
        int k = 0;

        // Intrinsics:
        double fx = x[k++];
        double s = x[k++]; (void)s;
        double cx = x[k++];
        double fy = x[k++];
        double cy = x[k++];
        double intrinsics[3][3] = {
            {fx,    s,  cx},
            {  0,  fy,  cy},
            {  0,   0,   1}
        };
        double k1 = x[k++];
        double k2 = x[k++];

        // Extrinsics:
        double r_pose[NUM_POSES][3];
        double t_pose[NUM_POSES][3];
        for (int i = 0; i < NUM_POSES; i++) {
            r_pose[i][0] = x[k++]; r_pose[i][1] = x[k++]; r_pose[i][2] = x[k++];
            t_pose[i][0] = x[k++]; t_pose[i][1] = x[k++]; t_pose[i][2] = x[k++];
        }

        assert(k == n);

        int f = 0;
        for (int poseIdx = 0; poseIdx < NUM_POSES; poseIdx++) {
            // Pose extrinsics:
            double t[3]; memcpy(t, t_pose[poseIdx], sizeof(double[3]));
            double R[3][3]; rotationVectorToRotationMatrix(r_pose[poseIdx], R);

            // For each point in the pose:
            for (int pointIdx = 0; pointIdx < PosePointsCount[poseIdx]; pointIdx++) {
                // Get the 3D position of the point in ideal
                // camera-space using model & extrinsics.
                double* modelPoint = (double*) &PoseModelPoints[poseIdx][pointIdx];
                double idealPoint[3];
                transformVec3(R, t, modelPoint, idealPoint);

                // Use intrinsics to project down to ideal 2D
                // position.
                double idealPlanePoint[3];
                mulMat3Vec3(intrinsics, idealPoint, idealPlanePoint);
                idealPlanePoint[0] /= idealPlanePoint[2];
                idealPlanePoint[1] /= idealPlanePoint[2];
                idealPlanePoint[2] = 1.0;

                double planePoint[2];
                distort(fx, fy, cx, cy, k1, k2,
                        idealPlanePoint, planePoint);

                // Add an error term to fvec.
                double dx = planePoint[0] - PosePoints[poseIdx][pointIdx][0];
                double dy = planePoint[1] - PosePoints[poseIdx][pointIdx][1];
                fvec[f++] = sqrt(dx*dx + dy*dy);
            }
        }
        return 0;
    }
    $cc proc computeError {double[] params int paramsCount} void {
        double fvec[PointsCount];
        func(PointsCount, paramsCount, params, fvec, NULL, NULL);
        double totalError = 0;
        for (int i = 0; i < PointsCount; i++) {
            /* printf("  Error %d: %f\n", i, fvec[i]); */
            totalError += fvec[i];
        }
        printf("Total Error: %f\n", totalError);
    }
    $cc proc refineCalibrationOptimize {double[] params int paramsCount} Tcl_Obj* {
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        
        mp_result result = {0};

        assert(paramsCount == 7 + NUM_POSES*6);
        printf("Unrefined -----------------\n");
        computeError(params, paramsCount);

        mpfit(func,
              // Number of example point pairs:
              PointsCount,
              // Number of parameters to optimize:
              paramsCount,
              params, NULL,
              NULL, NULL, &result);
        printf("Refined -------------------\n");
        computeError(params, paramsCount);

        Tcl_Obj* paramObjs[paramsCount];
        for (int i = 0; i < paramsCount; i++) {
            paramObjs[i] = Tcl_NewDoubleObj(params[i]);
        }
        return Tcl_NewListObj(paramsCount, paramObjs);
    }
    $cc compile ;# takes about a half-second

    # Refines the calibration of an individual camera or
    # projector. Takes a dict with intrinsics (dict of fx, s, cx, etc)
    # and poses (list of pose dicts). Each pose dict should have
    # modelPoints (list of 3D points) and points (list of 2D points)
    # and R and t. Returns dict with updated intrinsics and poses.
    set refineCalibration {{calibration} {
        set paramNames {fx s cx fy cy k1 k2}

        # Load the initial guesses for all parameters for fitting.
        set params [lmap paramName $paramNames {
            dict get $calibration intrinsics $paramName
        }]
        foreach pose [dict get $calibration poses] {
            lappend params {*}[rotationMatrixToRotationVector [dict get $pose R]]
            lappend params {*}[dict get $pose t]
        }

        # Load the example data for fitting.
        set poseModelPoints [list]
        set posePoints [list]
        set posePointsCount [list]
        foreach pose [dict get $calibration poses] {
            set modelPoints [dict get $pose modelPoints]
            lappend poseModelPoints {*}[concat {*}$modelPoints]

            set points [dict get $pose points]
            lappend posePoints {*}[concat {*}$points]

            lappend posePointsCount [llength $points]
        }
        setPoints $posePointsCount $poseModelPoints $posePoints

        # Do the actual optimization:
        set refined [refineCalibrationOptimize $params [llength $params]]

        # Unspool the optimization result into the calibration data
        # structure and return that.

        set refined [lassign $refined {*}$paramNames]
        foreach paramName $paramNames {
            dict set calibration intrinsics $paramName [set $paramName]
        }

        set poses [dict get $calibration poses]
        for {set i 0} {$i < [llength $poses]} {incr i} {
            set pose [lindex $poses $i]
            dict set pose R [rotationVectorToRotationMatrix [lrange $refined 0 2]]
            dict set pose t [lrange $refined 3 5]
            lset poses $i $pose
            set refined [lrange $refined 6 end]
        }
        dict set calibration poses $poses

        return $calibration
    }}
    Claim the calibration refiner is $refineCalibration
}
