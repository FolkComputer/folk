# correct-extrinsics.folk --
#
#     Implements extrinsics correction process -- final step in
#     calibration which is used to correct any offset between the
#     camera and projector. Relies on the fact that we can just use
#     still poses on the table for this, and we know the
#     camera/projector intrinsics well from earlier calibration; we
#     don't need to wave board around in the air and capture 3D poses.
#

proc kabsch {xs ys} {
    set n [llength $xs]
    if {[llength $ys] != $n} { error "kabsch: xs and ys differ in length" }

    set xsum {0 0 0}
    foreach x $xs { set xsum [add $xsum $x] }
    set xc [scale [/ 1.0 $n] $xsum]

    set ysum {0 0 0}
    foreach y $ys { set ysum [add $ysum $y] }
    set yc [scale [/ 1.0 $n] $ysum]

    set H [matmul [transpose [sub $xs [lrepeat $n $xc]]] \
               [sub $ys [lrepeat $n $yc]]]

    lassign [determineSVD $H] U S V
    set R [matmul $V [transpose $U]]
    set t [sub $yc [matmul $R $xc]]
    return [list $R $t]
}

When the calibration unit model is /unitModel/ &\
     the calibration isProjectedTag is /^isProjectedTag/ &\
     the calibration isPrintedTag is /^isPrintedTag/ &\
     the calibration meanPoseDifference is /^meanPoseDifference/ &\
     camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     camera /camera/ to display /display/ has extrinsics /initialExtrinsics/ &\
     camera /camera/ has intrinsics /cameraIntrinsics/ &\
     display /display/ has intrinsics /projectorIntrinsics/ &\
     the printed tag side length is /printedSideLengthMm/ mm &\
     /someone/ wishes to correct extrinsics {

    puts "CORRECT EXTRINSICS"

    # VERY IMPORTANT: disable autofocus forever.
    catch { exec v4l2-ctl --device=$camera --set-ctrl=focus_automatic_continuous=0 }

    if {$cameraWidth < 1920} {
        Retract /someone/ wishes $::thisNode uses camera $camera \
            with width $cameraWidth height $cameraHeight
        Assert $this wishes $::thisNode uses camera $camera with width 1920 height 1080
        # TODO: restore old camera resolution later
    }

    set printedTagSize [/ $printedSideLengthMm 1000.0]

    set model [dict map {id tag} $unitModel {
        dict create c [scale $printedTagSize [dict get $tag c]] \
            p [scale $printedTagSize [dict get $tag p]]
    }]
    set modelCenter [apply {{model} {
        set tags [dict values $model]
        set topLeftTagCenter [dict get [lindex $tags 0] c]
        set bottomRightTagCenter [dict get [lindex $tags end] c]
        return [scale 0.5 [add $topLeftTagCenter $bottomRightTagCenter]]
    }} $model]

    # Don't want to project any tag IDs other than the tags already
    # marked out for the model.
    set projectableTagIds [lmap id [dict keys $model] {
        if {![isProjectedTag $id]} { continue }
        set id
    }]

    set ::pastPoses [list]

    When the extrinsic correction printed tags are /nothing/ &\
         main-detector detects tags /tagsList/ on $camera at /timestamp/ in time /something/ {

        # Look for the printed tags on the calibration board.

        set tags [dict create] ;# meanPoseDifference requires dict.
        foreach tag $tagsList { dict set tags [dict get $tag id] $tag }

        set pose [dict create tags $tags timestamp $timestamp]
        lappend ::pastPoses $pose

        if {[llength $::pastPoses] < 3} {
            return
        }
        if {[meanPoseDifference $pose [lindex $::pastPoses 0]] > 5 ||
            [meanPoseDifference $pose [lindex $::pastPoses end]] > 5} {
            # Too much deviation. Reset.
            set ::pastPoses [list]
            return
        }

        # Check for stability over multiple frames. Countdown.
        set stableTime [- $timestamp [dict get [lindex $::pastPoses 0] timestamp]]
        if {$stableTime > 2} {
            # Display a countdown to 0.
        }
        if {$stableTime < 5} {
            return
        }

        # Now we have a pose that has been stable for 5s.
        puts "ANALYZING POSE"

        # Do pose detection on printed tags. Project an inwardized
        # version of each tag, capture it on camera, pose-detect it,
        # then compute an extrinsic offset from that. Then RANSAC to
        # find consensus among the extrinsic offsets.
        set boardTagIds [dict keys $model]
        set capturedPrintedTags [list]
        foreach id $boardTagIds {
            if {![isPrintedTag $id]} { continue }

            set tagHistory [lmap pose [lrange $::pastPoses end-2 end] {
                if {![dict exists $pose tags $id]} { continue }
                dict get $pose tags $id
            }]
            # Discard tags that weren't captured every pose.
            if {[llength $tagHistory] != 3} { continue }

            lappend capturedPrintedTags $tagHistory
        }
        if {[llength $capturedPrintedTags] < 3} {
            puts stderr "calibrate extrinsics: Not enough captures: [llength $capturedPrintedTags]"
            return
        }

        Commit printed {
            Claim the extrinsic correction printed tags are $capturedPrintedTags
        }
        Commit projected {
            Claim the extrinsic correction projected tags are [list]
        }
    }

    When display $display has width /displayWidth/ height /displayHeight/ &\
         the extrinsic correction printed tags are /capturedPrintedTags/ &\
         the extrinsic correction projected tags are /capturedProjectedTags/ {

        # Each printed tag should get a corresponding projected tag.
        if {[llength $capturedPrintedTags] == [llength $capturedProjectedTags]} {
            # We're done! We've collected all the data.
            puts [list set capturedProjectedTags $capturedProjectedTags]

            # Do Kabsch algorithm with each subpair, print the R and t
            # results, compare by hand for now.
            foreach pair $capturedProjectedTags {
                lassign $pair xs ys
                # Both xs and ys are in camera-space: xs is predicted
                # vertices, ys is detected vertices.

                puts "pair=="
                puts "xs:"
                puts [show $xs]
                puts "ys:"
                puts [show $ys]
                puts "Kabsch: ([kabsch $xs $ys])"
            }

            Commit printed {}
            Commit projected {}
            Retract /any/ wishes to correct extrinsics

            # For each projected tag, need original coordinates in
            # camera-space (which are derived from the printed tag) +
            # detected coordinates in camera-space (which are derived
            # from the detection).
            
            # Build up a list of point pairs.

            # Do Kabsch-RANSAC.

            # Adjust the extrinsics.

            # Rcp*xc + tcp = xp
            #
            # seen as xc'
            # Roff*xc + toff = xc'
            # Rcp*xc + tcp = xp
            # Rcp*xc' + tcp = xp
            # Rcp*(Roff*xc + toff) + tcp = xp
            # Rcp*Roff*xc + (Rcp*toff + tcp) = xp

            # compute roff, toff which change xc to xc'
            # set Rcp to Rcp*Roff
            # set tcp to (Rcp*toff + tcp)

            return
        }

        # Find the next printed tag that we should project a tag based
        # on.
        set printedTagIdx [llength $capturedProjectedTags]
        set printedTagHistory [lindex $capturedPrintedTags $printedTagIdx]
        # Used later to get the tag's model-space coordinates.
        set printedTagId [dict get [lindex $printedTagHistory 0] id]

        # Do multi-frame-based tag pose estimation.
        set printedTagPose ""
        foreach det $printedTagHistory {
            set p [dict get $det p]
            if {$printedTagPose eq ""} {
                set printedTagPose \
                    [baseEstimateTagPose $cameraIntrinsics \
                         $cameraWidth $cameraHeight \
                         $printedTagSize $p]
            } else {
                set printedTagPose \
                    [servoingEstimateTagPose $cameraIntrinsics \
                         $cameraWidth $cameraHeight \
                         $printedTagSize \
                         $printedTagPose $p]
            }
        }

        # Now printedTagPose is {R, t} a rigid transform from
        # tag-space (with (0, 0, 0) being the tag center) to
        # camera-space.
        #
        # We want to make a tag that we can project -- we'll take the
        # printed tag and make new vertices to project a tag at the
        # center of the calibration board. This should be spaced
        # well-enough under most expected offsets to be detectable.

        # What's the vector from tag center -> board center in
        # model-space? (This should directly translate into
        # tag-space.)
        set printedTagCenterToBoardCenter \
            [sub $modelCenter [dict get $model $printedTagId c]]
        lappend printedTagCenterToBoardCenter 0.0

        # We need to go from inner corners (tag size) -> outer corners
        # (AprilTag shader), then turn it from diameter to radius.
        set rr [expr {(10.0/6.0 * $printedTagSize) / 2.0}]
        set projectTagVerticesInCameraSpace \
            [lmap v [list [list [- $rr]    $rr  0] \
                         [list     $rr     $rr  0] \
                         [list     $rr  [- $rr] 0] \
                         [list  [- $rr] [- $rr] 0]] \
                 {
                     # Translate from original printed tag to the
                     # center of the calibration board:
                     set v [add $v $printedTagCenterToBoardCenter]
                     # Move from printed-tag-space to camera-space:
                     dict with printedTagPose {
                         add [matmul $R $v] $t
                     }
                 }]

        set projectTagVertices \
            [lmap v $projectTagVerticesInCameraSpace {
                # Move from camera-space to projector-space:
                set vp [dict with initialExtrinsics {
                    add [matmul $R $v] $t
                }]
                # Move from projector-space to projector-pixel-space:
                intrinsics project $projectorIntrinsics $vp
            }]
        set projectTagId [lindex $projectableTagIds \
                              [% $printedTagIdx [llength $projectableTagIds]]]

        # White backdrop to hopefully make the projected tags pop out more:
        Wish to draw a quad with \
            p0 [list 0 0] p1 [list $displayWidth 0] \
            p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
            color white layer 99

        Wish to draw an AprilTag with id $projectTagId \
            corners [lreverse $projectTagVertices] layer 100

        # Note that these are inner corners, not the outer corners
        # above:
        set r [expr {$printedTagSize / 2.0}]
        set tagVerticesInCameraSpace \
            [lmap v [list [list [- $r]    $r  0] \
                         [list     $r     $r  0] \
                         [list     $r  [- $r] 0] \
                         [list  [- $r] [- $r] 0]] \
                 {
                     # Translate from original printed tag to the
                     # center of the calibration board:
                     set v [add $v $printedTagCenterToBoardCenter]
                     # Move from printed-tag-space to camera-space:
                     dict with printedTagPose {
                         add [matmul $R $v] $t
                     }
                 }]

        # FIXME: The name `dett` is a hack (as opposed to `det`)
        # because we have issues with same-name variables as in
        # capture scope.
        When tag $projectTagId has detection /dett/ on $camera at /timestamp/ {
            # We're not guaranteed that it was projected at the same
            # size. Let's estimate the projected size.
            # What was the pixel size of the printed tag?
            set printedTagCorners [dict get [lindex $printedTagHistory end] p]
            set printedTagPixelSize [norm [sub [lindex $printedTagCorners 1] \
                                               [lindex $printedTagCorners 0]]]
            # What is the pixel size of the projected tag?
            set p [dict get $dett p]
            set projectedTagPixelSize [norm [sub [lindex $p 1] \
                                                 [lindex $p 0]]]
            set expectedProjectedTagSize [* [/ $projectedTagPixelSize $printedTagPixelSize] $printedTagSize]
            puts "printedTagSize ($printedTagSize) -- expectedProjectedTagSize ($expectedProjectedTagSize)"

            # Do we need more than one detection? Probably not.
            set baseTagPose [baseEstimateTagPose $cameraIntrinsics \
                                 $cameraWidth $cameraHeight \
                                 $expectedProjectedTagSize $p]
            set tagPose [servoingEstimateTagPose $cameraIntrinsics \
                             $cameraWidth $cameraHeight \
                             $expectedProjectedTagSize $baseTagPose \
                             $p]

            set detectTagVerticesInTagSpace \
                [list [list [- $r]    $r  0] \
                     [list     $r     $r  0] \
                     [list     $r  [- $r] 0] \
                     [list  [- $r] [- $r] 0]]
            set detectTagVerticesInCameraSpace \
                [lmap v $detectTagVerticesInTagSpace {
                    dict with tagPose {
                        add [matmul $R $v] $t
                    }
                }]

            lappend capturedProjectedTags \
                [list $tagVerticesInCameraSpace \
                     $detectTagVerticesInCameraSpace]
            Commit projected {
                Claim the extrinsic correction projected tags are $capturedProjectedTags
            }
        }
    }
}
