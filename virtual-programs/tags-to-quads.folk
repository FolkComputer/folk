set cc [c create]

# Represents camera or projector intrinsics, including the classic
# intrinsic matrix but also dimensions at which the matrix was created
# + distortion coefficients.
#
# Intrinsic matrix:
#   fx  s   cx
#   0   fy  cy
#   0   0    1
$cc struct Intrinsics {
    double width;
    double height;

    double fx;
    double fy;
    double cx;
    double cy;
    double s;

    double k1;
    double k2;
}

namespace eval intrinsics {
    set cc [uplevel {set cc}]
    $cc proc distort {double fx double fy double cx double cy
                      double k1 double k2
                      double xy[2] double out[2]} void {
        double x = (xy[0] - cx)/fx;
        double y = (xy[1] - cy)/fy;
        double r2 = x*x + y*y;
        double D = k1 * r2 + k2 * r2*r2;
        out[0] = (x * (1.0 + D))*fx + cx;
        out[1] = (y * (1.0 + D))*fy + cy;
    }
    $cc proc project {Intrinsics intr double[3] v} Tcl_Obj* {
        double out[3] = {
            v[0]*intr.fx +  v[1]*intr.s + v[2]*intr.cx,
                       0 + v[1]*intr.fy + v[2]*intr.cy,
                       0 +            0 + v[2]
        };
        out[0] /= out[2]; out[1] /= out[2];
        distort(intr.fx, intr.fy, intr.cx, intr.cy,
                intr.k1, intr.k2,
                out, out);
        Tcl_Obj* retObjs[2] = { Tcl_NewDoubleObj(out[0]), Tcl_NewDoubleObj(out[1]) };
        return Tcl_NewListObj(2, retObjs);
    }
    namespace export *
    namespace ensemble create
}

$cc proc rescaleAndUndistort {Intrinsics intr
                              double cameraWidth double cameraHeight
                              double* in
                              double* out} void {
    double x = in[0] * intr.width / cameraWidth;
    double y = in[1] * intr.height / cameraHeight;

    x = (x - intr.cx) / intr.fx;
    y = (y - intr.cy) / intr.fy;
    for (int i = 0; i < 3; i++) {
        double r2 = x*x + y*y;
        double rad = 1.0 + intr.k1 * r2 + intr.k2 * r2*r2;
        x /= rad; y /= rad;
    }
    out[0] = x*intr.fx + intr.cx;
    out[1] = y*intr.fy + intr.cy;
}
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>
$cc include <common/homography.h>
$cc proc estimateTagPoses {Intrinsics cameraIntrinsics
                           double cameraWidth double cameraHeight
                           double tagSize
                           double[4][2] p0} Tcl_Obj* {
    // We'll fill this in with a new .p and .H with
    // undistorted/rescaled coordinates.
    apriltag_detection_t det;

    // We'll fill in the right side of each correspondence in the
    // loop.
    float correspondences[4][4] = {
        {-1.0f, 1.0f, 0, 0},
        {1.0f, 1.0f, 0, 0},
        {1.0f, -1.0f, 0, 0},
        {-1.0f, -1.0f, 0, 0}
    };
    for (int i = 0; i < 4; i++) {
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            p0[i], det.p[i]);
        correspondences[i][2] = det.p[i][0];
        correspondences[i][3] = det.p[i][1];
    }

    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]), .size = 4, .alloc = 4,
        .data = (char*) correspondences
    };
    det.H = homography_compute(&correspondencesArr,
                               HOMOGRAPHY_COMPUTE_FLAG_SVD);
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = tagSize,
        .fx = cameraIntrinsics.fx, .fy = cameraIntrinsics.fy,
        .cx = cameraIntrinsics.cx, .cy = cameraIntrinsics.cy
    };
    apriltag_pose_t poses[2]; double errs[2];
    estimate_tag_pose_orthogonal_iteration(&info, &errs[0], &poses[0],
                                           &errs[1], &poses[1], 4);

    matd_destroy(det.H);

    Tcl_Obj* ret = Tcl_NewListObj(0, NULL);
    for (int i = 0; i < 2; i++) {
        apriltag_pose_t* pose = &poses[i];
        if (pose->R == NULL) { continue; }

        Tcl_ListObjAppendElement(NULL, ret, Tcl_ObjPrintf(
            "{%f %f %f %f}\n"
            "{%f %f %f %f}\n"
            "{%f %f %f %f}\n"
            "{0   0  0  1}\n",
            MATD_EL(pose->R, 0, 0), MATD_EL(pose->R, 0, 1), MATD_EL(pose->R, 0, 2), MATD_EL(pose->t, 0, 0),
            MATD_EL(pose->R, 1, 0), MATD_EL(pose->R, 1, 1), MATD_EL(pose->R, 1, 2), MATD_EL(pose->t, 1, 0),
            MATD_EL(pose->R, 2, 0), MATD_EL(pose->R, 2, 1), MATD_EL(pose->R, 2, 2), MATD_EL(pose->t, 2, 0)
            ));
        Tcl_ListObjAppendElement(NULL, ret, Tcl_NewDoubleObj(errs[i]));

        matd_destroy(pose->R);
        matd_destroy(pose->t);
    }
    return ret;
}

namespace eval ::space {
    set changers [dict create]

    proc changeableTo {targetSpace changer} {
        list changeableTo $targetSpace $changer
    }
    proc change {sourceSpace targetSpace v} {
        # puts "change $sourceSpace -> $targetSpace ($v)"
        variable changers
        if {$sourceSpace eq $targetSpace} {
            return $v
        }
        if {[lindex $sourceSpace 0] eq "changeableTo"} {
            set changedSpace [lindex $sourceSpace 1]
            set changer [lindex $sourceSpace 2]
            set v [{*}$changer $v]
            return [change $changedSpace $targetSpace $v]
        }
        if {[dict exists $changers $sourceSpace $targetSpace]} {
            set changer [dict get $changers $sourceSpace $targetSpace]
            return [{*}$changer $v]
        }
        error "space change: Don't know how to change $sourceSpace to $targetSpace"
    }
    namespace export *
    namespace ensemble create
}
When camera /camera/ to display /display/ has extrinsics /extrinsics/ {
    # HACK: doesn't use db
    dict set space::changers $camera "display $display" [list apply {{R t v} {
        add [matmul $R $v] $t
    }} [dict get $extrinsics R] [dict get $extrinsics t]]
}
namespace eval ::quad {
    proc create {space vertices} { list $space $vertices }
    proc space {q} { lindex $q 0 }
    proc vertices {q} { lindex $q 1 }

    proc change {q targetSpace} {
        set sourceSpace [space $q]
        create $targetSpace [lmap v [vertices $q] {
            ::space change $sourceSpace $targetSpace $v
        }]
    }
    proc scale {q s} {
        create [space $q] [lmap v [vertices $q] {
            lmap x $v {* $x $s}
        }]
    }
    proc buffer {q args} {
        lassign [vertices $q] bottomLeft bottomRight topRight topLeft
        foreach {direction distance} $args {
            if {![regexp {([0-9\.]+)(mm|m)?} $distance -> distance unit]} {
                error "quad buffer: Invalid distance $distance"
            }

            if {$unit eq "mm"} {
                set distance [* $distance 0.001]
                set unit "m"
            }
            if {$unit eq "cm"} {
                set distance [* $distance 0.01]
                set unit "m"
            }
            if {$unit ne "m"} { error "quad buffer: Invalid unit $unit" }

            if {$direction eq "top"} {
                set disp [list 0 [- $distance] 0]
                set topLeft [add $topLeft $disp]
                set topRight [add $topRight $disp]
            } elseif {$direction eq "bottom"} {
                set disp [list 0 $distance 0]
                set bottomLeft [add $bottomLeft $disp]
                set bottomRight [add $bottomRight $disp]
            } elseif {$direction eq "left"} {
                set disp [list [- $distance] 0 0]
                set bottomLeft [add $bottomLeft $disp]
                set topLeft [add $topLeft $disp]
            } elseif {$direction eq "right"} {
                set disp [list $distance 0 0]
                set bottomRight [add $bottomRight $disp]
                set topRight [add $topRight $disp]
            } else {
                error "quad buffer: Invalid direction $direction"
            }
        }
        return [create [space $q] [list $bottomLeft $bottomRight $topRight $topLeft]]
    }

    namespace export *
    namespace ensemble create
}

$cc compile

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     camera /camera/ has intrinsics /cameraIntrinsics/ {
        
    set ::prevTagPoses [dict create]
    When tag /tag/ has detection /det/ on $camera at /timestamp/ {
        set tagSize [expr {31.5 / 1000}]; # 31.5 mm

        if {[dict exists $::prevTagPoses $tag]} {
            set prevTimestamp [dict get $::prevTagPoses $tag timestamp]
            # Consider previous tag pose if it's less than 50ms old:
            if {$timestamp - $prevTimestamp < 0.05} {
                set prevTagPose [dict get $::prevTagPoses $tag pose]
            }
        }

        set estimatedTagPoses [estimateTagPoses $cameraIntrinsics \
                                   $cameraWidth $cameraHeight \
                                   $tagSize [dict get $det p]]
        if {[info exists prevTagPose]} {
            # Replace error values in tagPoses using distance from
            # prev pose.
            set tagPoses [list]
            foreach {tagPose err} $estimatedTagPoses {
                set err [::math::linearalgebra::normMatrix [::math::linearalgebra::sub $tagPose $prevTagPose]]
                lappend tagPoses $tagPose $err
            }
        } else {
            set tagPoses $estimatedTagPoses
        }
        # Re-sort tagPoses so lowest err is first.
        set tagPoses [lsort -stride 2 -index 1 -real $tagPoses]
        set tagPose [lindex $tagPoses 0]

        dict set ::prevTagPoses $tag timestamp $timestamp
        dict set ::prevTagPoses $tag pose $tagPose

        set tagToCameraSpaceChanger [list apply {{tagPose v} {
            lassign [matmul $tagPose [list {*}$v 1]] x y z w
            list [/ $x $w] [/ $y $w] [/ $z $w]
        }} $tagPose]
        set tagSpace [space changeableTo $camera $tagToCameraSpaceChanger]

        set r [expr {$tagSize / 2}]
        # Vertex order is bottom-left, bottom-right, top-right,
        # top-left.
        set vertices \
            [list [list [- $r]    $r  0] \
                 [list     $r     $r  0] \
                 [list     $r  [- $r] 0] \
                 [list  [- $r] [- $r] 0]]

        set quad [quad create $tagSpace $vertices]
        Claim tag $tag has quad $quad
    }
}

When tag /tag/ has quad /q/ {
    # TODO: Store construction of program $tag so it can vary by
    # program, instead of hard-coding.
    Claim $tag has quad [quad buffer $q \
                             top 28mm \
                             right 28mm \
                             left 157mm \
                             bottom 80mm]
    
    # Just uses the outer edge of the tag:
    Claim $tag has quad $q ;# [quad scale $q [expr {10.0 / 6.0}]]
}
