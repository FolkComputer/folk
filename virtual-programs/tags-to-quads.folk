set cc [c create]

# Represents camera or projector intrinsics, including the classic
# intrinsic matrix but also dimensions at which the matrix was created
# + distortion coefficients.
#
# Intrinsic matrix:
#   fx  s   cx
#   0   fy  cy
#   0   0    1
$cc struct Intrinsics {
    double width;
    double height;

    double fx;
    double fy;
    double cx;
    double cy;
    double s;

    double k1;
    double k2;
}

namespace eval intrinsics {
    set cc [uplevel {set cc}]
    $cc proc distort {double fx double fy double cx double cy
                      double k1 double k2
                      double xy[2] double out[2]} void {
        double x = (xy[0] - cx)/fx;
        double y = (xy[1] - cy)/fy;
        double r2 = x*x + y*y;
        double D = k1 * r2 + k2 * r2*r2;
        out[0] = (x * (1.0 + D))*fx + cx;
        out[1] = (y * (1.0 + D))*fy + cy;
    }
    $cc proc project {Intrinsics intr double[3] v} Tcl_Obj* {
        double out[3] = {
            v[0]*intr.fx +  v[1]*intr.s + v[2]*intr.cx,
                       0 + v[1]*intr.fy + v[2]*intr.cy,
                       0 +            0 + v[2]
        };
        out[0] /= out[2]; out[1] /= out[2];
        distort(intr.fx, intr.fy, intr.cx, intr.cy,
                intr.k1, intr.k2,
                out, out);
        Tcl_Obj* retObjs[2] = { Tcl_NewDoubleObj(out[0]), Tcl_NewDoubleObj(out[1]) };
        return Tcl_NewListObj(2, retObjs);
    }
    namespace export *
    namespace ensemble create
}

$cc proc rescaleAndUndistort {Intrinsics intr
                              double cameraWidth double cameraHeight
                              double* in
                              double* out} void {
    double x = in[0] * intr.width / cameraWidth;
    double y = in[1] * intr.height / cameraHeight;

    x = (x - intr.cx) / intr.fx;
    y = (y - intr.cy) / intr.fy;
    for (int i = 0; i < 3; i++) {
        double r2 = x*x + y*y;
        double rad = 1.0 + intr.k1 * r2 + intr.k2 * r2*r2;
        x /= rad; y /= rad;
    }
    out[0] = x*intr.fx + intr.cx;
    out[1] = y*intr.fy + intr.cy;
}
$cc cflags -I$::env(HOME)/apriltag $::env(HOME)/apriltag/libapriltag.a
$cc include <apriltag_pose.h>
$cc include <common/homography.h>
$cc proc estimateTagPose {Intrinsics cameraIntrinsics
                          double cameraWidth double cameraHeight
                          double tagSize
                          double[4][2] p0} Tcl_Obj* {
    // We'll fill this in with a new .p and .H with
    // undistorted/rescaled coordinates.
    apriltag_detection_t det;

    // We'll fill in the right side of each correspondence in the
    // loop.
    float correspondences[4][4] = {
        {-1.0f, 1.0f, 0, 0},
        {1.0f, 1.0f, 0, 0},
        {1.0f, -1.0f, 0, 0},
        {-1.0f, -1.0f, 0, 0}
    };
    for (int i = 0; i < 4; i++) {
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            p0[i], det.p[i]);
        correspondences[i][2] = det.p[i][0];
        correspondences[i][3] = det.p[i][1];
    }

    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]), .size = 4, .alloc = 4,
        .data = (char*) correspondences
    };
    det.H = homography_compute(&correspondencesArr,
                               HOMOGRAPHY_COMPUTE_FLAG_SVD);
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = tagSize,
        .fx = cameraIntrinsics.fx, .fy = cameraIntrinsics.fy,
        .cx = cameraIntrinsics.cx, .cy = cameraIntrinsics.cy
    };
    apriltag_pose_t pose;
    estimate_tag_pose(&info, &pose);

    matd_destroy(det.H);

    Tcl_Obj* poseObj = Tcl_ObjPrintf(
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{%f %f %f %f}\n"
        "{0   0  0  1}\n",
        MATD_EL(pose.R, 0, 0), MATD_EL(pose.R, 0, 1), MATD_EL(pose.R, 0, 2), MATD_EL(pose.t, 0, 0),
        MATD_EL(pose.R, 1, 0), MATD_EL(pose.R, 1, 1), MATD_EL(pose.R, 1, 2), MATD_EL(pose.t, 1, 0),
        MATD_EL(pose.R, 2, 0), MATD_EL(pose.R, 2, 1), MATD_EL(pose.R, 2, 2), MATD_EL(pose.t, 2, 0)
    );
    matd_destroy(pose.R);
    matd_destroy(pose.t);
    return poseObj;
}

namespace eval ::space {
    set changers [dict create]

    proc changeableTo {targetSpace changer} {
        list changeableTo $targetSpace $changer
    }
    proc change {sourceSpace targetSpace v} {
        # puts "change $sourceSpace -> $targetSpace ($v)"
        variable changers
        if {$sourceSpace eq $targetSpace} {
            return $v
        }
        if {[lindex $sourceSpace 0] eq "changeableTo"} {
            set changedSpace [lindex $sourceSpace 1]
            set changer [lindex $sourceSpace 2]
            set v [{*}$changer $v]
            return [change $changedSpace $targetSpace $v]
        }
        if {[dict exists $changers $sourceSpace $targetSpace]} {
            set changer [dict get $changers $sourceSpace $targetSpace]
            return [{*}$changer $v]
        }
        error "space change: Don't know how to change $sourceSpace to $targetSpace"
    }
    namespace export *
    namespace ensemble create
}
When camera /camera/ to display /display/ has extrinsics /extrinsics/ {
    # HACK: doesn't use db
    dict set space::changers $camera "display $display" [list apply {{R t v} {
        add [matmul $R $v] $t
    }} [dict get $extrinsics R] [dict get $extrinsics t]]
}
namespace eval ::quad {
    proc create {space vertices} { list $space $vertices }
    proc space {q} { lindex $q 0 }
    proc vertices {q} { lindex $q 1 }

    proc change {q targetSpace} {
        set sourceSpace [space $q]
        create $targetSpace [lmap v [vertices $q] {
            ::space change $sourceSpace $targetSpace $v
        }]
    }
    proc scale {q s} {
        create [space $q] [lmap v [vertices $q] {
            lmap x $v {* $x $s}
        }]
    }
    proc offset {q args} {
        # TODO: implement
    }

    namespace export *
    namespace ensemble create
}

$cc compile

When camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     camera /camera/ has intrinsics /cameraIntrinsics/ {
    When tag /tag/ has detection /det/ on $camera {
        set tagSize [expr {31.5 / 1000}]; # 31.5 mm

        set p [dict get $det p]
        set tagPose [estimateTagPose $cameraIntrinsics \
                         $cameraWidth $cameraHeight \
                         $tagSize $p]
        set tagToCameraSpaceChanger [list apply {{tagPose v} {
            lassign [matmul $tagPose [list {*}$v 1]] x y z w
            list [/ $x $w] [/ $y $w] [/ $z $w]
        }} $tagPose]
        set tagSpace [space changeableTo $camera $tagToCameraSpaceChanger]

        set r [expr {$tagSize / 2}]
        set vertices \
            [list [list [- $r]    $r  0] \
                 [list     $r     $r  0] \
                 [list     $r  [- $r] 0] \
                 [list  [- $r] [- $r] 0]]

        set quad [quad create $tagSpace $vertices]
        Claim tag $tag has quad $quad
    }
}

When tag /tag/ has quad /q/ {
    Claim $tag has quad [quad scale $q [expr {10.0 / 6.0}]]
}
