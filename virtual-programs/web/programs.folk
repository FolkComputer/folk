# TODO: support e.g.:
#    - programs/virtual/label.folk
#    - programs/printed/0123.folk
#    - programs/core/powerSwitch.folk (aliases to virtual-programs/core/powerSwitch.folk)
#    - programs/web/id (displays the content of a live web program if that endpoint is active)

proc log {msg} {
    puts "=== /programs/: === $msg"
}

proc count_char {input_string char} {
    # Use string map to replace the character with an empty string
    # and compare the lengths to get the count
    set without_char [string map [list $char ""] $input_string]
    set char_count [expr {[string length $input_string] - [string length $without_char]}]
    return $char_count
}

proc getFilename {directory program_id} {
    set filenames [list \
        "virtual-programs/$program_id.folk" \
        "$::env(HOME)/folk-printed-programs/$program_id.folk" \
        "$::env(HOME)/folk-live/$program_id.folk" \
        "user-programs/[info hostname]/$program_id.folk" \
    ]

    foreach filename $filenames {
        if {[file exists $filename]} {
            return $filename
        }
    }
    return 0
}

proc get_virtual_program {filename} {
    if {[file exists $filename]} {
        set fp [open $filename r]
        set file_data [read $fp]
        close $fp
        return $file_data
    }
    return "# (new file $program_id)"
}

proc get_printed_program {program_id} {
    # Implementation for getting printed program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

proc get_core_program {program_id} {
    # Implementation for getting core program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

proc get_web_program {program_id} {
    # Implementation for getting web program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

# proc handle_programs_route_old {path html_command} {
#     set pathString [lindex [split $path "/"] 2]
#     log "pathString: $pathString"

#     set parts [split $pathString "/"]
#     set count [llength $parts]

#     switch $count {
#         1 {
#             set directory "virtual"
#             set program_id $pathString
#         }
#         2 {
#             set directory [lindex $parts 0]
#             set program_id [lindex $parts 1]
#         }
#         default {
#             return [uplevel 1 [list $html_command "<html><body><h1>Error: Invalid path structure</h1></body></html>"]]
#         }
#     }

#     log "directory: $directory"
#     log "program_id: $program_id"

#     switch $directory {
#         "virtual" {
#             set file_data [get_virtual_program $program_id]
#         }
#         "printed" {
#             set file_data [get_printed_program $program_id]
#         }
#         "core" {
#             set file_data [get_core_program $program_id]
#         }
#         "web" {
#             set file_data [get_web_program $program_id]
#         }
#         default {
#             return [uplevel 1 [list $html_command "<html><body><h1>Error: Unknown directory type</h1></body></html>"]]
#         }
#     }

#     return [generate_html $file_data $program_id $directory $html_command]
# }

proc generate_html {file_data program_id directory html_command} {
    log "directory is $directory"
    puts "file_data: $file_data"
    puts "got: $program_id"
    
    set filename "$directory/$program_id.folk"
    
    set mapped_html [string map [list \
        "file_data" [htmlEscape $file_data] \
        "program_id" $program_id \
        "file_name" $filename \
    ] {
        <html>
        <body>
        <div>
          <span id="status">Status</span>
          <button onclick="handleSave()">Save</button>
          <button id="print" onclick="handlePrint()">Print</button>
        </div>
        <textarea id="code" style="width: 100%;height: 95vh;">file_data</textarea>
        <pre id="error"></pre>
        <script src="/lib/folk.js"></script>
        <script>
          const isVirtualProgram = !'file_name'.includes('folk-printed-programs');

          if (isVirtualProgram) {
            document.getElementById("print").disabled = true;
          }

          const codeEle = document.getElementById("code");
          const errorEle = document.getElementById("error");
          function uuidv4() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
              (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
          }

          // Cmd + S || Ctrl + S => Save
          document.addEventListener('keydown', function(e) {
            if ((window.navigator.platform.match('Mac') ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
              e.preventDefault();
              handleSave();
            }
          }, false);
          // Cmd + P || Ctrl + P => Print
          document.addEventListener('keydown', function(e) {
            if ((window.navigator.platform.match('Mac') ? e.metaKey : e.ctrlKey)  && e.keyCode == 80) {
              e.preventDefault();
              handlePrint();
            }
          }, false);

          const ws = new FolkWS(document.getElementById('status'));
          ws.watchCollected(tcl`program_id has error /something/ with info /errorInfo/`, errors => {
            errorEle.style.backgroundColor = errors.length ? "#f55" : "";
            errorEle.innerText = errors.map(e => e.errorInfo).join('\n');
          });

          function handleSave() {
            const code = document.getElementById("code").value;
            ws.send(tcl`
              set fp [open file_name w]
              puts -nonewline $fp ${code}
              close $fp
              puts "Saved program_id.folk"
            `);

            if (isVirtualProgram) {
              ws.send(tcl`EditVirtualProgram file_name ${code}`)
            }
          }

          let jobid;
          function handlePrint() {
            const code = document.getElementById("code").value;
            jobid = String(Math.random());
            ws.send(tcl`Wish to print program program_id with code ${code} job-id ${jobid}`);
          }
        </script>
        </body>
        </html>
    }]
    
    return [uplevel 1 [list $html_command $mapped_html]]
}

proc clipFolkExtension {filename} {
    string range $filename 0 end-5
}

proc handleProgramsRoute {path} {
    set pathList [split $path "/"]
    set count [llength $pathList]

    switch $count {
        2 {
            # e.g. http://folkName.local:4273/programs/0.folk
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 1]]
            log "(2) PATHLIST: $pathList"
        }
        3 {
            # e.g. http://folkName.local:4273/programs/0.folk
            # e.g. printed, virtual, web, core
            log "(3) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 2]]
        }
        4 {
            # e.g. programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/printed/0.folk
            set directory [lindex $pathList 2]
            set program_id [clipFolkExtension [lindex $pathList 3]]
            log "(4) PATHLIST: $pathList"
        }
        default {
            return "<html><body><h1>Error: Invalid path structure</h1></body></html>"
        }
    }
    # TODO: Actually read the file content.
    #       For now we'll set it to a placeholder string.
    set filename "$directory/$program_id.folk"
    set filename [getFilename $directory $program_id]
    log "filename: $filename"
    log "program_id: $program_id"
    set file_data [get_virtual_program $filename]
    if {$file_data == 0} {
        # TODO: Set appropriate HTTP status code
        #       Can maybe edit the WHen below to return a 404 status code?
        set file_data "404|Error: $filename not found"
    }

    return "<html><body>
        <h1>Program Details:</h1>
        <ul>
            <li>Directory: $directory</li>
            <li>Program ID: $program_id</li>
        <ul>

        <h2>File content:</h2>
        <pre>$file_data</pre>
        </body></html>
    "
}

# Router for `/programs/(.*)$`
Wish the web server handles route {/programs/(.*)$} with handler {
    set rawHTML [handleProgramsRoute $path]
    html $rawHTML
}