# TODO: support e.g.:
#    - programs (list out all the programs)
#    - programs/virtual/label.folk
#    - programs/virtual/display/arc.folk
#    - programs/printed/0123.folk
#    - programs/core/powerSwitch.folk (aliases to virtual-programs/core/powerSwitch.folk)
#    - programs/web/id (displays the content of a live web program if that endpoint is active)

proc log {msg} {
    puts "=== /programs/: === $msg"
}

set ::search_paths_dict [dict create \
    "virtual" "virtual-programs" \
    "printed" "$::env(HOME)/folk-printed-programs" \
    "live" "$::env(HOME)/folk-live" \
    "user" "user-programs/[info hostname]" \
]


###############
# Example result:
# [
#   {
#     title "Labels"
#     description "Display text on the screen with the font `PTSans-Regular`"
#     example "Wish /someone/ is labelled "Hello, world!""
#     code "When /someone/ wishes /thing/ is labelled /text/ {
#             # Set the default font
#             Wish $thing is labelled $text with font "PTSans-Regular"
#          }"
#   }
# ]
###############

proc parse_tcl_docs {file_data} {
    set lines [split $file_data "\n"]
    set result [list]
    set currentBlock [dict create]
    set inBlock 0
    set blockLevel 0

    foreach line $lines {
        if {[string match "# ---*" $line]}  {
            set blockLevel [+ 1 $blockLevel]
            continue;
        }

        if {$inBlock} {
            switch $blockLevel {
                1 {
                    # Description
                    # use dict update to set the description?
                }
                2 {
                   # Example
                }
                3 {
                    # Code
                    # 
                    # Need to figure 
                }
                default {
                    log "---- not supposed to be here ----"
                }
            }
            # evaluate line, put it into the currentBlock as needed
        }
        if {!$inBlock && [string match "# *" $line]} {
            # We've started a new comment+code block
            set content [string range $trimmed_line 2 end]
            dict set currentBlock title $content
        } else {
            continue;
        }
    }

    return [dict create documentation "TODO: Parse documentation" code $file_data]
}

# Example usage:
# set file_data [read [open "paste.txt" r]]
# set result [parse_tcl_docs $file_data]
# puts "Documentation:\n[dict get $result documentation]"
# puts "\nCode:\n[dict get $result code]"

# Example usage:
# set file_data [read [open "paste.txt" r]]
# puts [parse_tcl_docs $file_data]

proc list_programs {directory} {
    set programs [list]
    
    foreach path $::search_paths {
        set full_path [file join $path $directory]
        if {[file isdirectory $full_path]} {
            set files [glob -nocomplain -directory $full_path *.folk]
            foreach file $files {
                lappend programs [file tail $file]
            }
        }
    }

    return $programs
}

proc getFilename {directory program_id} {
    set filenames [list \
        "virtual-programs/$program_id.folk" \
        "$::env(HOME)/folk-printed-programs/$program_id.folk" \
        "$::env(HOME)/folk-live/$program_id.folk" \
        "user-programs/[info hostname]/$program_id.folk" \
    ]

    foreach filename $filenames {
        if {[file exists $filename]} {
            return $filename
        }
    }
    return 0
}

proc getFileData {filename} {
    if {[file exists $filename]} {
        set fp [open $filename r]
        set file_data [read $fp]
        close $fp
        return $file_data
    }
    # return "# (new file $program_id)"
    return "# (new file $filename)"
}

proc get_printed_program {program_id} {
    # Implementation for getting printed program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc get_core_program {program_id} {
    # Implementation for getting core program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc get_web_program {program_id} {
    # Implementation for getting web program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc clipFolkExtension {filename} {
    string range $filename 0 end-5
}

proc generate_directory_listing {directory programs} {
    log "generate_directory_listing: $directory | $programs |"
    set mapped_html [string map [list \
        "directory" $directory \
        "program_list" [join $programs "\n"] \
    ] {
        <html>
        <head>
            <title>directory - Folk Program Directory</title>
            /* TODO: Add IBM Plex Sans & Mono via <link> */
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
            </style>
        </head>
        <body>
        <h1>Programs in directory</h1>
        <ul>
        [program_list]
        </ul>
        </body>
        </html>
    }]
    
    set formatted_list ""
    foreach program $programs {
        append formatted_list "<li><a href=\"/programs/$directory/$program\">$program</a></li>\n"
    }
    
    set mapped_html [string map [list "[program_list]" $formatted_list] $mapped_html]
    
    return $mappted_html
}

proc handleProgramsRoute {path} {
    set pathList [split $path "/"]
    set count [llength $pathList]

    switch $count {
        2 {
            # e.g. http://folkName.local:4273/programs/0.folk
            log "(2) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 1]]
        }
        3 {
            # e.g. http://folkName.local:4273/programs/0.folk
            # e.g. printed, virtual, web, core
            log "(3) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 2]]
        }
        4 {
            # e.g. programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/printed/0.folk
            log "(4) PATHLIST: $pathList"
            set directory [lindex $pathList 2]
            set program_id [clipFolkExtension [lindex $pathList 3]]
        }
        default {
            return "<html><body><h1>Error: Invalid path structure</h1></body></html>"
        }
    }
    log "program id: $program_id"
    # TODO: Actually read the file content.
    #       For now we'll set it to a placeholder string.
    set filename "$directory/$program_id.folk"
    set filename [getFilename $directory $program_id]
    log "filename: $filename"
    log "program_id: $program_id"
    set file_data [getFileData $filename]
    if {$file_data == 0} {
        # TODO: Set appropriate HTTP status code
        #       Can maybe edit the WHen below to return a 404 status code?
        set file_data "404|Error: $filename not found"
    }

    set parsedFile [parse_tcl_docs $file_data]

    # set file_data [dict get $parsedFile documentation]
    # set file_data [dict get $parsedFile code]

    # TODO: Parse the file_data to extract the docstring
    # break into lines,
    # foreach line [split $file_data "\n"] {
    #     if {[string match "# *" $line]} {
    #         set docstring $line
    #         break
    #     }
    # }

    return "<html>
    <head>
        <meta charset=UTF-8>
        <meta name=viewport content=\"width=device-width, initial-scale=1.0\">
        <title>$program_id - Folk Program</title>
        <link rel=\"stylesheet\" href=\"/style.css\">
    <body>
        <section>
            <h1 class=\"subtitle code\">$program_id</h1>
            <h2 class=\"code\">path: [info hostname]/$directory/$program_id.folk</h2>
        </section>

        <!-- TODO: Pull out docstring -> HTML in here -->
        <section>
            <h2 class=subtitle>Documentation:</h2>
            <p class=todo>TODO: Write a docstring above each (?) When in this program to see what the generated equivalent would feel like in docs/virtual-programs/shapes/index.html</p>
            [dict get $parsedFile documentation]
        </section>

        <section>
            <h2 class=subtitle>File content:</h2>
            <pre>[dict get $parsedFile code]</pre>
        </section>
        </body></html>
    "
}

proc htmlEscape {s} { string map {& "&amp;" < "&lt;" > "&gt;" "\"" "&quot;"} $s }

proc emitHTMLForProgramList {programList label} {
    set prettyLabel [string map {- " "} $label]
    set prettyLabel [string totitle $prettyLabel]:
    set returnList [list "<details data-label='$label' data-count='[llength $programList]'><summary>$prettyLabel ([llength $programList])</summary>"]
    lappend returnList "<ul>"
    foreach item $programList {
        lappend returnList "<li>
          <details>
            <summary class=subtitle>$item</summary>
            <pre><code>[htmlEscape [getFileData $item]]</code></pre>
        </li>"
    }
    lappend returnList "</ul>"
    lappend returnList "</details>"
    join $returnList
}

Wish the web server handles route {/programs$} with handler {
    # TODO:
    # - Make this synchronous
    # - Maybe should actually, move this to a virtual-program/watcher.folk.default programs that makes claims like:
    #   Claim virtual programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim core programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim web programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim real programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    set programs [Statements::findMatches [list /someone/ claims /page/ has program /program/]]
    set vp [list]; # virtual programs
    set cp [list]; # core programs
    set wp [list]; # web programs
    set rp [list]; # real programs

    foreach match $programs {
        set page [dict get $match page]
        switch -glob $page {
            "virtual-programs/*" {
                lappend vp $page
            }
            "setup.folk.default" {
                lappend cp $page
            }
            "web-program-*" {
                lappend wp $page
            }
            default {
                lappend rp $page
            }
        }
    }

    set rawHTML [subst {
        <html>
        <head>
            <title>All programs</title>
            <link rel="stylesheet" href="/style.css">
            <script src="/lib/folk.js"></script>
            <script>
            /* TODO:
                (  ) Add a ws.watch() for /someone/ claims /page/ has program /program/
            */
            </script>
        </head>
        <body>
                <nav>
                    <a href="/new"><button>New program</button></a>
                    <a href="/">Statements</a>
                    <a href="/statementClauseToId.pdf">statementClauseToId graph</a>
                    <a href="/statements.pdf">statements graph</a>
                </nav>

            [emitHTMLForProgramList $rp "real-programs"]
            [emitHTMLForProgramList $wp "web-programs"]
            [emitHTMLForProgramList $vp "virtual-programs"]
            [emitHTMLForProgramList $cp "core-programs"]
            [expr {[llength $rp] ?  "<h2>[llength $rp] [expr {[llength $rp] == 1 ? "program is" : "programs are"}] out.</h2>" : "No real programs are out."}]
        </body>
        </html>
    }]
    html $rawHTML
}

# Router for `/programs/(.*)$`
Wish the web server handles route {/programs/(.*)$} with handler {
    set rawHTML [handleProgramsRoute $path]
    html $rawHTML
}