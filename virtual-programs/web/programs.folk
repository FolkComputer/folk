# TODO: support e.g.:
#    - programs (list out all the programs)
#    - programs/virtual/label.folk
#    - programs/printed/0123.folk
#    - programs/core/powerSwitch.folk (aliases to virtual-programs/core/powerSwitch.folk)
#    - programs/web/id (displays the content of a live web program if that endpoint is active)

proc log {msg} {
    puts "=== /programs/: === $msg"
}

set ::search_paths_dict [dict create \
    "virtual" "virtual-programs" \
    "printed" "$::env(HOME)/folk-printed-programs" \
    "live" "$::env(HOME)/folk-live" \
    "user" "user-programs/[info hostname]" \
]

# set ::search_paths [list \
#     "virtual-programs" \
#     "$::env(HOME)/folk-printed-programs" \
#     "$::env(HOME)/folk-live" \
#     "user-programs/[info hostname]" \
# ]

proc list_programs {directory} {
    set programs [list]
    
    foreach path $::search_paths {
        set full_path [file join $path $directory]
        if {[file isdirectory $full_path]} {
            set files [glob -nocomplain -directory $full_path *.folk]
            foreach file $files {
                lappend programs [file tail $file]
            }
        }
    }

    return $programs
}

proc getFilename {directory program_id} {
    set filenames [list \
        "virtual-programs/$program_id.folk" \
        "$::env(HOME)/folk-printed-programs/$program_id.folk" \
        "$::env(HOME)/folk-live/$program_id.folk" \
        "user-programs/[info hostname]/$program_id.folk" \
    ]

    foreach filename $filenames {
        if {[file exists $filename]} {
            return $filename
        }
    }
    return 0
}

proc getFileData {filename} {
    if {[file exists $filename]} {
        set fp [open $filename r]
        set file_data [read $fp]
        close $fp
        return $file_data
    }
    return "# (new file $program_id)"
}

proc get_printed_program {program_id} {
    # Implementation for getting printed program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc get_core_program {program_id} {
    # Implementation for getting core program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc get_web_program {program_id} {
    # Implementation for getting web program
    # For now, we'll use the same logic as getFileData
    return [getFileData $program_id]
}

proc clipFolkExtension {filename} {
    string range $filename 0 end-5
}

proc generate_directory_listing {directory programs} {
    log "generate_directory_listing: $directory | $programs |"
    set mapped_html [string map [list \
        "directory" $directory \
        "program_list" [join $programs "\n"] \
    ] {
        <html>
        <head>
            <title>directory - Folk Program Directory</title>
            /* TODO: Add IBM Plex Sans & Mono via <link> */
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
            </style>
        </head>
        <body>
        <h1>Programs in directory</h1>
        <ul>
        [program_list]
        </ul>
        </body>
        </html>
    }]
    
    set formatted_list ""
    foreach program $programs {
        append formatted_list "<li><a href=\"/programs/$directory/$program\">$program</a></li>\n"
    }
    
    set mapped_html [string map [list "[program_list]" $formatted_list] $mapped_html]
    
    return $mappted_html
}

proc handleProgramsRoute {path} {
    set pathList [split $path "/"]
    set count [llength $pathList]

    switch $count {
        2 {
            # e.g. http://folkName.local:4273/programs/0.folk
            log "(2) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 1]]
        }
        3 {
            # e.g. http://folkName.local:4273/programs/0.folk
            # e.g. printed, virtual, web, core
            log "(3) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 2]]
        }
        4 {
            # e.g. programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/printed/0.folk
            log "(4) PATHLIST: $pathList"
            set directory [lindex $pathList 2]
            set program_id [clipFolkExtension [lindex $pathList 3]]
        }
        default {
            return "<html><body><h1>Error: Invalid path structure</h1></body></html>"
        }
    }
    # TODO: Actually read the file content.
    #       For now we'll set it to a placeholder string.
    set filename "$directory/$program_id.folk"
    set filename [getFilename $directory $program_id]
    log "filename: $filename"
    log "program_id: $program_id"
    set file_data [getFileData $filename]
    if {$file_data == 0} {
        # TODO: Set appropriate HTTP status code
        #       Can maybe edit the WHen below to return a 404 status code?
        set file_data "404|Error: $filename not found"
    }

    return "<html>
    <head>
        <meta charset=UTF-8>
        <meta name=viewport content=\"width=device-width, initial-scale=1.0\">
        <title>$program_id - Folk Program</title>
        <link rel=\"stylesheet\" href=\"/style.css\">
    <body>
        <section>
            <h1 class=code>$program_id</h1>
            <h2 class=code>[info hostname]/$directory/$program_id.folk</h2>
        </section>

        <!-- TODO: Pull out docstring -> HTML in here -->
        <section>
            <details>
                <summary><span class=subtitle>Documentation:</h2></span>
                <p>TODO: Write a docstring above each (?) When in this program to see what the generated equivalent would feel like in docs/virtual-programs/shapes/index.html</p>
                <pre>extacted comment</pre>
            </details>
        </section>

        <section>
            <details>
                <summary><span class=subtitle>File content:</span>
                <pre>$file_data</pre>
            </details> 
        </section>
        </body></html>
    "
}

proc htmlEscape {s} { string map {& "&amp;" < "&lt;" > "&gt;" "\"" "&quot;"} $s }

proc emitHTMLForProgramList {programList label} {
    set prettyLabel [string map {- " "} $label]
    set prettyLabel [string totitle $prettyLabel]:
    set returnList [list "<details data-label='$label' data-count='[llength $programList]'><summary>$prettyLabel ([llength $programList])</summary>"]
    lappend returnList "<ul>"
    foreach item $programList {
        lappend returnList "<li>
          <details>
            <summary class=subtitle>$item</summary>
            <pre><code>[htmlEscape [getFileData $item]]</code></pre>
        </li>"
    }
    lappend returnList "</ul>"
    lappend returnList "</details>"
    join $returnList
}

Wish the web server handles route {/programs$} with handler {
    # TODO:
    # - Make this synchronous
    # - Maybe should actually, move this to a virtual-program/watcher.folk.default programs that makes claims like:
    #   Claim virtual programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim core programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim web programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    #   Claim real programs are [list {page a program p_a} {page b program p_b} {page c program p_c}]
    set programs [Statements::findMatches [list /someone/ claims /page/ has program /program/]]
    set vp [list]; # virtual programs
    set cp [list]; # core programs
    set wp [list]; # web programs
    set rp [list]; # real programs

    foreach match $programs {
        set page [dict get $match page]
        switch -glob $page {
            "virtual-programs/*" {
                lappend vp $page
            }
            "setup.folk.default" {
                lappend cp $page
            }
            "web-program-*" {
                lappend wp $page
            }
            default {
                lappend rp $page
            }
        }
    }

    set rawHTML [subst {
        <html>
        <head>
            <title>All programs</title>
            <link rel="stylesheet" href="/style.css">
            <script src="/lib/folk.js"></script>
            <script>
            /* TODO:
                (  ) Add a ws.watch() for /someone/ claims /page/ has program /program/
            */
            </script>
        </head>
        <body>
                <nav>
                    <a href="/new"><button>New program</button></a>
                    <a href="/">Statements</a>
                    <a href="/statementClauseToId.pdf">statementClauseToId graph</a>
                    <a href="/statements.pdf">statements graph</a>
                </nav>

            [emitHTMLForProgramList $rp "real-programs"]
            [emitHTMLForProgramList $wp "web-programs"]
            [emitHTMLForProgramList $vp "virtual-programs"]
            [emitHTMLForProgramList $cp "core-programs"]
            [expr {[llength $rp] ?  "<h2>[llength $rp] [expr {[llength $rp] == 1 ? "program is" : "programs are"}] out.</h2>" : "No real programs are out."}]
        </body>
        </html>
    }]
    html $rawHTML
}


Wish the web server handles route {/programs_deprecated_handler$} with handler {
    set programs [Statements::findMatches [list /someone/ claims /programName/ has program /program/]]
    log "# programs: [llength $programs]"
    set rawHTML "<html>
    <head>
        <link rel=stylesheet href=/style.css>
        <title>Running programs</title>
    </head>
    <body>"
    foreach program $programs {
        lappend rawHTML [subst {
            <details>
            <summary class=subtitle>[dict get $program programName]</summary>
            <pre><code>[dict get $program program]</code></pre>
            </details>
        }]
    }
    lappend rawHTML "
    </body>
    </html>"
    html $rawHTML
}


# Router for `/programs/(.*)$`
Wish the web server handles route {/programs/(.*)$} with handler {
    set rawHTML [handleProgramsRoute $path]
    html $rawHTML
}