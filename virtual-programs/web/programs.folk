# TODO: support e.g.:
#    - programs/virtual/label.folk
#    - programs/printed/0123.folk
#    - programs/core/powerSwitch.folk (aliases to virtual-programs/core/powerSwitch.folk)
#    - programs/web/id (displays the content of a live web program if that endpoint is active)

proc log {msg} {
    puts "=== /programs/: === $msg"
}

proc list_programs {directory} {
    set programs [list]
    set search_paths [list \
        "virtual-programs" \
        "$::env(HOME)/folk-printed-programs" \
        "$::env(HOME)/folk-live" \
        "user-programs/[info hostname]" \
    ]
    
    foreach path $search_paths {
        set full_path [file join $path $directory]
        if {[file isdirectory $full_path]} {
            set files [glob -nocomplain -directory $full_path *.folk]
            foreach file $files {
                lappend programs [file tail $file]
            }
        }
    }

    return $programs
}

proc getFilename {directory program_id} {
    set filenames [list \
        "virtual-programs/$program_id.folk" \
        "$::env(HOME)/folk-printed-programs/$program_id.folk" \
        "$::env(HOME)/folk-live/$program_id.folk" \
        "user-programs/[info hostname]/$program_id.folk" \
    ]

    foreach filename $filenames {
        if {[file exists $filename]} {
            return $filename
        }
    }
    return 0
}

proc get_virtual_program {filename} {
    if {[file exists $filename]} {
        set fp [open $filename r]
        set file_data [read $fp]
        close $fp
        return $file_data
    }
    return "# (new file $program_id)"
}

proc get_printed_program {program_id} {
    # Implementation for getting printed program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

proc get_core_program {program_id} {
    # Implementation for getting core program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

proc get_web_program {program_id} {
    # Implementation for getting web program
    # For now, we'll use the same logic as get_virtual_program
    return [get_virtual_program $program_id]
}

proc clipFolkExtension {filename} {
    string range $filename 0 end-5
}

proc generate_directory_listing {directory programs} {
    set mapped_html [string map [list \
        "directory" $directory \
        "program_list" [join $programs "\n"] \
    ] {
        <html>
        <head>
            <title>directory - Folk Program Directory</title>
            /* TODO: Add IBM Plex Sans & Mono via <link> */
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
            </style>
        </head>
        <body>
        <h1>Programs in directory</h1>
        <ul>
        [program_list]
        </ul>
        </body>
        </html>
    }]
    
    set formatted_list ""
    foreach program $programs {
        append formatted_list "<li><a href=\"/programs/$directory/$program\">$program</a></li>\n"
    }
    
    set mapped_html [string map [list "[program_list]" $formatted_list] $mapped_html]
    
    return $mappted_html
}

proc handleProgramsRoute {path} {
    set pathList [split $path "/"]
    set count [llength $pathList]

    switch $count {
        2 {
            # e.g. http://folkName.local:4273/programs/0.folk
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 1]]
            log "(2) PATHLIST: $pathList"
        }
        3 {
            # e.g. http://folkName.local:4273/programs/0.folk
            # e.g. printed, virtual, web, core
            log "(3) PATHLIST: $pathList"
            set directory "printed"
            set program_id [clipFolkExtension [lindex $pathList 2]]
        }
        4 {
            # e.g. programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/virtual/label.folk
            # e.g. http://folk-cwe.local:4273/programs/printed/0.folk
            set directory [lindex $pathList 2]
            set program_id [clipFolkExtension [lindex $pathList 3]]
            log "(4) PATHLIST: $pathList"
        }
        default {
            return "<html><body><h1>Error: Invalid path structure</h1></body></html>"
        }
    }
    # TODO: Actually read the file content.
    #       For now we'll set it to a placeholder string.
    set filename "$directory/$program_id.folk"
    set filename [getFilename $directory $program_id]
    log "filename: $filename"
    log "program_id: $program_id"
    set file_data [get_virtual_program $filename]
    if {$file_data == 0} {
        # TODO: Set appropriate HTTP status code
        #       Can maybe edit the WHen below to return a 404 status code?
        set file_data "404|Error: $filename not found"
    }

    return "<html>
    <head>
        <meta charset=UTF-8>
        <meta name=viewport content=\"width=device-width, initial-scale=1.0\">
        <title>$program_id - Folk Program</title>
        <link rel=\"stylesheet\" href=\"/style.css\">
    <body>
        <section>
            <h1 class=code>$program_id</h1>
            <h2 class=code>[info hostname]/$directory/$program_id.folk</h2>
        </section>

        <!-- TODO: Pull out docstring -> HTML in here -->
        <section>
            <details>
                <summary><span class=subtitle>Documentation:</h2></span>
                <p>TODO: Write a docstring above each (?) When in this program to see what the generated equivalent would feel like in docs/virtual-programs/shapes/index.html</p>
                <pre>extacted comment</pre>
            </details>
        </section>


        <section>
            <details>
                <summary><span class=subtitle>File content:</span>
                <pre>$file_data</pre>
            </details> 
        </section>

        </body></html>
    "
}

# Router for `/programs/(.*)$`
Wish the web server handles route {/programs/(.*)$} with handler {
    set rawHTML [handleProgramsRoute $path]
    html $rawHTML
}