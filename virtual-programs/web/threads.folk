set threadMonitorLib [apply {{} {
    set cc [C]
    $cc cflags -I.
    $cc include "workqueue.h"
    $cc include "common.h"
    $cc code {
        extern ThreadControlBlock threads[];
        extern int _Atomic threadCount;

        extern Db* db;

        Jim_Obj* itemToStringObj(WorkQueueItem item) {
            Jim_Obj* obj;

#define EMIT(...) obj = Jim_ObjPrintf(__VA_ARGS__)
            if (item.op == ASSERT) {
                EMIT("Assert");
            } else if (item.op == RETRACT) {
                EMIT("Retract");
            } else if (item.op == HOLD) {
                EMIT("Hold (%.20s: %" PRId64 ") (%.50s)",
                     item.hold.key, item.hold.version,
                     clauseToString(item.hold.clause));
            } else if (item.op == SAY) {
                EMIT("Say");
            } else if (item.op == RUN) {
                Statement* stmt = statementAcquire(db, item.run.stmt);
                if (stmt != NULL) {
                    EMIT("Run when (%.100s) (%.100s)",
                         clauseToString(item.run.whenPattern),
                         clauseToString(statementClause(stmt)));
                    statementRelease(db, stmt);
                } else {
                    EMIT("Run (INVALIDATED)");
                }
            } else if (item.op == REMOVE_PARENT) {
                EMIT("Remove Parent");
            } else {
                EMIT("???");
            }
#undef EMIT
            return obj;
        }
    }
    $cc proc workerInfo {int tid} Jim_Obj* {
        ThreadControlBlock *thread = NULL;
        for (int i = 0; i < threadCount; i++) {
            if (threads[i].tid == tid) {
                thread = &threads[i];
                break;
            }
        }
        if (thread == NULL) {
            return Jim_NewEmptyStringObj(interp);
        }

        Jim_Obj* ret = Jim_NewDictObj(interp, NULL, 0);

        WorkQueueItem item = thread->currentItem;
        Jim_DictAddElement(interp, ret, Jim_NewStringObj(interp, "op", -1),
                           itemToStringObj(item));

        Jim_DictAddElement(interp, ret,
                           Jim_NewStringObj(interp, "isAwaitingPush", -1),
                           Jim_NewStringObj(interp, thread->isAwaitingPush ? "(Awaiting Push)" : "", -1));

        WorkQueueItem items[100];
        int nitems = unsafe_workQueueCopy(items, 100, thread->workQueue);
        Jim_Obj* workQueueObj = Jim_NewListObj(interp, NULL, 0);
        for (int i = 0; i < nitems; i++) {
            Jim_ListAppendElement(interp, workQueueObj,
                                  itemToStringObj(items[i]));
        }
        Jim_DictAddElement(interp, ret,
                           Jim_NewStringObj(interp, "workQueue", -1),
                           workQueueObj);

        return ret;
    }
    return [$cc compile]
}}]

Wish the web server handles route "/threads" with handler [list apply {{threadMonitorLib} {
    set pid [pid]
    set tids [glob -tails -directory /proc/$pid/task *]

    set userStacks [dict create]
    try {
        set euStackOutput [exec eu-stack --pid=[pid] --verbose]
        set currentTid none
        foreach line [split $euStackOutput "\n"] {
            if {[regexp {TID ([0-9]+):} $line -> tid]} {
                set currentTid $tid
            } else {
                dict set userStacks $currentTid \
                    "[dict getdef $userStacks $currentTid {}]\n$line"
            }
        }
    } on error e {}

    html [subst {
        <html>
        <head>
        <link rel="stylesheet" href="/style.css">
        <title>Threads</title>
        </head>

        <body>

        <h2>Threads</h2>

        <ol>
        [join [lmap tid $tids {
            set taskdir /proc/$pid/task/$tid

            set statusFd [open $taskdir/status r]
            set status [read $statusFd]; close $statusFd

            set workerInfo [$threadMonitorLib workerInfo $tid]

            try {
                set userStack [dict get $userStacks $tid]
            } on error e {
                set userStack "<not found>"
            }
            try {
                set stackFd [open $taskdir/stack r]
                set kernelStack [read $stackFd]; close $stackFd
            } on error e {
                set kernelStack "<not permitted>"
            }

            subst {<li style="[expr {$workerInfo eq "" ? "color: gray" : ""}]">
                $taskdir: [regexp -inline {State:[^\n]*\n} $status]<br>
                  [if {$workerInfo eq ""} {subst {
                      (Not a Folk worker thread)<br>
                  }} else {subst {
                      [htmlEscape [dict get $workerInfo op]] [dict get $workerInfo isAwaitingPush]<br>
                      <details>
                          <summary>Work queue:</summary>
                          <pre>[htmlEscape [join [dict get $workerInfo workQueue] "\n"]]</pre>
                      </details>
                  }}]
                <details><summary>User stack:</summary><pre>[htmlEscape $userStack]</pre></details>
                <details><summary>Kernel stack:</summary><pre>[htmlEscape $kernelStack]</pre></details>
            </li>}
        }] "\n"]
        </ol>

        </body>
        </html>
    }]
}} $threadMonitorLib]
