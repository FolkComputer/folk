set getCc {{} {
    if {[info exists ::depGraphCc]} { return $::depGraphCc }

    set cc [C]
    $cc cflags -I.
    $cc include "db.h"
    $cc code {
        typedef struct {
            EdgeType type;
            void* to;
        } EdgeTo;
        typedef struct ListOfEdgeTo {
            size_t capacityEdges;
            size_t nEdges; // This is an estimate.
            EdgeTo edges[];
        } ListOfEdgeTo;
        typedef struct Statement {
            Clause* clause;

            // List of edges to parent & child Matches:
            ListOfEdgeTo* edges; // Allocated separately so it can be resized.
        } Statement;
    }
    $cc proc clauseToJimObj {Clause* clause} Jim_Obj* {
        Jim_Obj* termObjs[clause->nTerms];
        for (int i = 0; i < clause->nTerms; i++) {
            termObjs[i] = Jim_NewStringObj(interp, clause->terms[i], -1);
        }
        return Jim_NewListObj(interp, termObjs, clause->nTerms);
    }
    $cc proc clause {Statement* stmt} Jim_Obj* {
        return clauseToJimObj(statementClause(stmt));
    }
    $cc proc parentMatches {Statement* stmt} Jim_Obj* {
        int nParents = 0;
        Jim_Obj* parentObjs[stmt->edges->nEdges];
        for (int i = 0; i < stmt->edges->nEdges; i++) {
            if (stmt->edges->edges[i].type == EDGE_PARENT) {
                parentObjs[nParents++] = Jim_ObjPrintf("(Match*) %p", stmt->edges->edges[i].to);
            }
        }
        return Jim_NewListObj(interp, parentObjs, nParents);
    }
    $cc proc childMatches {Statement* stmt} Jim_Obj* {
        int nChildren = 0;
        Jim_Obj* childObjs[stmt->edges->nEdges];
        for (int i = 0; i < stmt->edges->nEdges; i++) {
            if (stmt->edges->edges[i].type == EDGE_CHILD) {
                childObjs[nChildren++] = Jim_ObjPrintf("(Match*) %p", stmt->edges->edges[i].to);
            }
        }
        return Jim_NewListObj(interp, childObjs, nChildren);
    }
    foreach fn {clause parentMatches childMatches} {
        proc $fn {args} [subst {::$fn {*}\$args}]
    }

    $cc compile
    set ::depGraphCc $cc
    return $cc
}}

set dbDotify {{getCc db} {
    set cc [apply $getCc]
    set dot [list]
    foreach stmt [Query! /...anything/] {
        set label [$cc clause $stmt]
        set label [join [lmap line [split $label "\n"] {
            expr { [string length $line] > 80 ? "[string range $line 0 80]..." : $line }
        }] "\n"]
        set label [string map {"\"" "\\\""} [string map {"\\" "\\\\"} $label]]
        lappend dot "<$stmt> \[label=\"$stmt: $label\"\];"

        foreach matchId [$cc parentMatches $stmt] {
            # set parents [lmap edge [matchEdges $matchId] {expr {
            #     [dict get $edge type] == 1 ? "[dict get $edge statement]" : [continue]
            # }}]
            # lappend dot "<$matchId> \[label=\"$matchId <- $parents\"\];"
            lappend dot "<$matchId> -> <$stmt>;"
        }
        
        foreach childMatchId [$cc childMatches $stmt] {
            lappend dot "<$stmt> -> <$childMatchId>;"
        }
    }
    return "digraph { rankdir=LR; [join $dot "\n"] }"
}}

set getDotAsPdf {{dot} {
    upvar $contentTypeVar contentType
    set contentType "application/pdf"
    set fd [open |[list dot -Tpdf <<$dot] r]
    fconfigure $fd -encoding binary -translation binary
    set response [read $fd]; close $fd; return $response
}}

Wish the web server handles route "/dep-graph.pdf" with handler [list apply {{getCc dbDotify getDotAsPdf} {
    __dbLock
    set dot [apply $dbDotify $getCc [__db]]
    __dbUnlock

    dict create statusAndHeaders "HTTP/1.1 200 OK
Connection: close
Content-Type: application/pdf" \
        body [apply $getDotAsPdf $dot]
}} $getCc $dbDotify $getDotAsPdf]
