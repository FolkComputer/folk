set getCc {{} {
    if {[info exists ::depGraphCc]} { return $::depGraphCc }

    set cc [C]
    $cc cflags -I.
    $cc include "db.h"

    $cc code {
        typedef struct ListOfEdgeTo {
            size_t capacityEdges;
            size_t nEdges; // This is an estimate.
            uint64_t edges[];
        } ListOfEdgeTo;

        #include <pthread.h>
    }
    set dbCFd [open "db.c" r]; set dbC [read $dbCFd]; close $dbCFd
    $cc code [lindex [regexp -inline {typedef struct Statement \{.*\} Statement;} $dbC] 0]
    $cc code [lindex [regexp -inline {typedef struct Match \{.*\} Match;} $dbC] 0]

    $cc proc clauseToJimObj {Clause* clause} Jim_Obj* {
        Jim_Obj* termObjs[clause->nTerms];
        for (int i = 0; i < clause->nTerms; i++) {
            termObjs[i] = Jim_NewStringObj(interp, clause->terms[i], -1);
        }
        return Jim_NewListObj(interp, termObjs, clause->nTerms);
    }
    $cc proc clause {Statement* stmt} Jim_Obj* {
        return clauseToJimObj(statementClause(stmt));
    }
    $cc proc childMatches {Statement* stmt} Jim_Obj* {
        int nChildren = 0;
        Jim_Obj* childObjs[stmt->childMatches->nEdges];
        for (int i = 0; i < stmt->childMatches->nEdges; i++) {
            MatchRef child = { .val = stmt->childMatches->edges[i] };
            childObjs[nChildren++] = Jim_ObjPrintf("m%d:%d", child.idx, child.gen);
        }
        return Jim_NewListObj(interp, childObjs, nChildren);
    }
    $cc proc childStatements {Match* match} Jim_Obj* {
        int nChildren = 0;
        Jim_Obj* childObjs[match->childStatements->nEdges];
        for (int i = 0; i < match->childStatements->nEdges; i++) {
            StatementRef child = { .val = match->childStatements->edges[i] };
            childObjs[nChildren++] = Jim_ObjPrintf("s%d:%d", child.idx, child.gen);
        }
        return Jim_NewListObj(interp, childObjs, nChildren);
    }

    $cc compile
    set ::depGraphCc $cc
    return $cc
}}

set dbDotify {{getCc db} {
    set cc [apply $getCc]
    set dot [list]
    foreach stmt [Query! /...anything/] {
        set stmt [dict get $stmt __stmt]
        set label [$cc clause $stmt]
        set label [join [lmap line [split $label "\n"] {
            expr { [string length $line] > 80 ? "[string range $line 0 80]..." : $line }
        }] "\n"]
        set label [string map {"\"" "\\\""} [string map {"\\" "\\\\"} $label]]
        lappend dot "<$stmt> \[label=\"$stmt: $label\"\];"

        # foreach matchId [$cc parentMatches $stmt] {
        #     # set parents [lmap edge [matchEdges $matchId] {expr {
        #     #     [dict get $edge type] == 1 ? "[dict get $edge statement]" : [continue]
        #     # }}]
        #     # lappend dot "<$matchId> \[label=\"$matchId <- $parents\"\];"
        #     lappend dot "<$matchId> -> <$stmt>;"
        # }
        
        foreach childMatchId [$cc childMatches $stmt] {
            lappend dot "<$stmt> -> <$childMatchId>;"
        }
    }
    return "digraph { rankdir=LR; [join $dot "\n"] }"
}}

set getDotAsPdf {{dot} {
    set fd [open |[list dot -Tpdf <<$dot] r]
    fconfigure $fd -translation binary
    set response [read $fd]; close $fd; return $response
}}

Wish the web server handles route "/dep-graph.pdf" with handler [list apply {{getCc dbDotify getDotAsPdf} {
    __dbLock
    set dot [apply $dbDotify $getCc [__db]]
    __dbUnlock

    dict create statusAndHeaders "HTTP/1.1 200 OK
Connection: close
Content-Type: application/pdf

" \
        body [apply $getDotAsPdf $dot]
}} $getCc $dbDotify $getDotAsPdf]
