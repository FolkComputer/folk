set dbLib [apply {{} {
    set cc [C]
    $cc cflags -I.
    $cc include "db.h"

    $cc code {
        typedef struct ListOfEdgeTo {
            size_t capacityEdges;
            size_t nEdges; // This is an estimate.
            uint64_t edges[];
        } ListOfEdgeTo;

        #include <pthread.h>
    }
    set dbCFd [open "db.c" r]; set dbC [read $dbCFd]; close $dbCFd
    $cc code [lindex [regexp -inline {typedef struct Statement \{.*\} Statement;} $dbC] 0]
    $cc code [lindex [regexp -inline {typedef struct Match \{.*\} Match;} $dbC] 0]
    $cc argtype StatementRef { StatementRef $argname; sscanf(Jim_String($obj), "s%d:%d", &$argname.idx, &$argname.gen); }
    $cc argtype MatchRef { MatchRef $argname; sscanf(Jim_String($obj), "m%d:%d", &$argname.idx, &$argname.gen); }

    $cc proc clauseToJimObj {Clause* clause} Jim_Obj* {
        Jim_Obj* termObjs[clause->nTerms];
        for (int i = 0; i < clause->nTerms; i++) {
            termObjs[i] = Jim_NewStringObj(interp, clause->terms[i], -1);
        }
        return Jim_NewListObj(interp, termObjs, clause->nTerms);
    }

    $cc proc statementParentCount {Db* db StatementRef stmtRef} int {
        Statement* stmt = statementAcquire(db, stmtRef);
        int ret = stmt->parentCount;
        statementRelease(db, stmt);
        return ret;
    }
    $cc proc statementPtrCount {Db* db StatementRef stmtRef} int {
        Statement* stmt = statementAcquire(db, stmtRef);
        int ret = stmt->ptrCount - 1;
        statementRelease(db, stmt);
        return ret;
    }
    $cc proc clause {Db* db StatementRef stmtRef} Jim_Obj* {
        Statement* stmt = statementAcquire(db, stmtRef);
        Jim_Obj* ret = clauseToJimObj(statementClause(stmt));
        statementRelease(db, stmt);
        return ret;
    }
    $cc proc childMatches {Db* db StatementRef stmtRef} Jim_Obj* {
        Statement* stmt = statementAcquire(db, stmtRef);

        int nChildren = 0;
        Jim_Obj* childObjs[stmt->childMatches->nEdges];
        for (int i = 0; i < stmt->childMatches->nEdges; i++) {
            MatchRef child = { .val = stmt->childMatches->edges[i] };
            childObjs[nChildren++] = Jim_ObjPrintf("m%d:%d", child.idx, child.gen);
        }
        statementRelease(db, stmt);
        return Jim_NewListObj(interp, childObjs, nChildren);
    }

    $cc proc matchAcq {Db* db MatchRef matchRef} Match* {
        return matchAcquire(db, matchRef);
    }
    $cc proc matchRel {Db* db Match* match} void {
        matchRelease(db, match);
    }
    $cc proc matchPtrCount {Db* db MatchRef matchRef} int {
        Match* match = matchAcquire(db, matchRef);
        int ret = match->ptrCount - 1;
        matchRelease(db, match);
        return ret;
    }
    $cc proc matchShouldFree {Db* db MatchRef matchRef} int {
        Match* match = matchAcquire(db, matchRef);
        int shouldFree = match->shouldFree;
        matchRelease(db, match);
        return shouldFree;
    }
    $cc proc childStatements {Db* db MatchRef matchRef} Jim_Obj* {
        Match* match = matchAcquire(db, matchRef);

        int nChildren = 0;
        Jim_Obj* childObjs[match->childStatements->nEdges];
        for (int i = 0; i < match->childStatements->nEdges; i++) {
            StatementRef child = { .val = match->childStatements->edges[i] };
            childObjs[nChildren++] = Jim_ObjPrintf("s%d:%d", child.idx, child.gen);
        }
        matchRelease(db, match);
        return Jim_NewListObj(interp, childObjs, nChildren);
    }

    return [$cc compile]
}}]

set dbDotify {{dbLib db} {
    set dot [list]
    set matchRefs [dict create]
    foreach stmt [Query! /...anything/] {
        set stmtRef [dict get $stmt __ref]
        set label [$dbLib clause $db $stmtRef]
        set label [join [lmap line [split $label "\n"] {
            expr { [string length $line] > 80 ? "[string range $line 0 80]..." : $line }
        }] "\n"]
        set label [string map {"\"" "\\\""} [string map {"\\" "\\\\"} $label]]
        set stmtParentCount [$dbLib statementParentCount $db $stmtRef]
        set stmtPtrCount [$dbLib statementPtrCount $db $stmtRef]
        lappend dot "<$stmtRef> \[label=\"$stmtRef ($stmtParentCount parents) ($stmtPtrCount ptrs): $label\"\];"

        foreach childMatchRef [$dbLib childMatches $db $stmtRef] {
            lappend dot "<$stmtRef> -> <$childMatchRef>;"
            dict set matchRefs $childMatchRef true
        }
    }
    foreach {matchRef _} $matchRefs {
        set match [$dbLib matchAcq $db $matchRef]
        if {$match eq "(Match*) 0x0"} { continue }

        set matchPtrCount [$dbLib matchPtrCount $db $matchRef]
        set matchShouldFree [$dbLib matchShouldFree $db $matchRef]
        lappend dot "<$matchRef> \[label=\"$matchRef (shouldFree $matchShouldFree) ($matchPtrCount)\"\];"
        foreach childStatementRef [$dbLib childStatements $db $matchRef] {
            lappend dot "<$matchRef> -> <$childStatementRef>;"
        }

        $dbLib matchRel $db $match
    }
    return "digraph { rankdir=LR; [join $dot "\n"] }"
}}

set getDotAsPdf {{dot} {
    set fd [open |[list dot -Tpdf <<$dot] r]
    fconfigure $fd -translation binary
    set response [read $fd]; close $fd; return $response
}}

Wish the web server handles route "/dep-graph.pdf" with handler [list apply {{dbLib dbDotify getDotAsPdf} {
    set dot [apply $dbDotify $dbLib [__db]]

    dict create statusAndHeaders "HTTP/1.1 200 OK
Connection: close
Content-Type: application/pdf

" \
        body [apply $getDotAsPdf $dot]
}} $dbLib $dbDotify $getDotAsPdf]
