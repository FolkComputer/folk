Wish the web server handles route "/setup" with handler {
    html [subst {
<html>
<head>
<title>Folk setup</title>
<script src="/lib/folk.js"></script>
</head>

<body>
<script>
const folk = new FolkWS();

let hasSeenHandlers = false;
folk.watchCollected(`/someone/ wishes the web server handles route "/setup" with handler /handler/`, handlers => {
    if (hasSeenHandlers) {
        window.location.reload();
    } else {
        hasSeenHandlers = true;
    }
});
</script>

<h1>Folk setup</h1>

<div>
  <h2>Start service on boot</h2>
  LIST IF SYSTEMD SERVICE EXISTS
</div>

<div>
  <h2>Configure user permissions</h2>
  LIST IF PART OF ALL GROUPS
</div>

<div>
  <h2>Errors</h2>
  LIST ALL ERRORS
</div>

<div>
  <h2>Display</h2>
  <div>
    <label>
      <input type="radio" name="display-type" value="glfw">
      GLFW (windowed)
    </label>
  </div>

  <div>
    <label>
      <input type="radio" name="display-type" value="direct">
      Direct to display
    </label>

    <h3>Available displays:</h3>
    [join [lmap disp [Query! $::thisNode has display /display/ with /...opts/] {
      set display $disp(display)
      set info [dict get $disp(opts) info]
      subst {
        <div style="margin: 10px 0;">
          <strong>Display $display</strong> ($info(name))
          <fieldset style="margin-left: 20px;">
            <legend>Select mode:</legend>
            [join [lmap mode $info(modes) {
              lassign [dict get $mode visibleRegion] width height
              subst {
                <label>
                  <input type="radio" name="display-mode-$display" value="$mode">
                  ${width}x${height}
                </label><br>
              }
            }] \n]
          </fieldset>
        </div>
      }
    }] \n]
  </div>

  <script>
  const displayRadios = document.querySelectorAll('input\[name="display-type"\]');
  displayRadios.forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.value === 'glfw' && this.checked) {
        await folk.evaluate('Hold! -save -key display-type Wish $::thisNode uses display glfw with width 640 height 480');
      }
    });
  });
  </script>
</div>

<div>
  <h2>Camera</h2>
  [join [lmap cameraData [Query! $::thisNode has camera /camera/ with /...opts/] { dict with cameraData {
    set camera [dict get $cameraData camera]
    set formats [dict get $cameraData(opts) formats]
    if {[llength $formats] == 0} {
      # Cameras often have extra camera devices with no formats for
      # some reason. Not very useful for us, so leave 'em out.
      continue
    }
    set cameraId [string map {/ _} $camera]
    subst {
      <div style="margin: 10px 0; border: 1px solid #ccc; padding: 10px;">
        <label>
          <input type="checkbox" name="camera-enabled" value="$camera" data-camera-id="$cameraId">
          <strong>$camera</strong>
        </label>

        <fieldset id="camera-formats-$cameraId" style="margin-left: 20px; margin-top: 10px">
          <legend>Select format:</legend>
          [join [lmap format $formats { subst {
            <label style="display: block; margin: 5px 0;">
              <input type="radio" name="camera-format-$cameraId" value="$format" data-camera="$camera">
              $format
            </label>
          } }] \n]
        </fieldset>

        <div id="camera-preview-$cameraId" style="margin-top: 10px; display: none;">
          <img src="/camera-frame?camera=[string map {/ %2F} $camera]"
            style="max-width: 320px; border: 1px solid #999;"
            alt="Camera preview">
        </div>
      </div>
    }
  } }] \n]

  <script>
  // Handle camera enable/disable
  document.querySelectorAll('input\[name="camera-enabled"\]').forEach(checkbox => {
    checkbox.addEventListener('change', async function() {
      const cameraId = this.dataset.cameraId;
      const previewDiv = document.getElementById(`camera-preview-\${cameraId}`);

      if (this.checked) {
        previewDiv.style.display = 'block';
      } else {
        previewDiv.style.display = 'none';
        // TODO: Remove the wish when unchecked
      }
    });
  });

  // Handle camera format selection
  document.querySelectorAll('input\[type="radio"\]\[name^="camera-format-"\]').forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.checked) {
        const camera = this.dataset.camera;
        const format = this.value;
        // TODO: Parse format dict and extract width/height, then create wish
        await folk.evaluate(`Hold! -save -key camera-\${camera} Wish $::thisNode uses camera "\${camera}" with \${format}`);
      }
    });
  });
  </script>
</div>

<div>
  <h2>Projector-camera calibration</h2>
  - radio buttons for projectors
  - check boxes for cameras
<button>Calibrate</button>
</div>

</body>
</html>
}]
}
