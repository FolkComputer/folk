Wish the web server handles route "/setup" with handler {
    html [subst {
<html>
<head>
<title>Folk setup</title>
<script src="/lib/folk.js"></script>
</head>

<body>
<script>
const folk = new FolkWS();

let hasSeenHandlers = false;
folk.watchCollected(`/someone/ wishes the web server handles route "/setup" with handler /handler/`, handlers => {
    if (hasSeenHandlers) {
        window.location.reload();
    } else {
        hasSeenHandlers = true;
    }
});
</script>

<h1>Folk setup</h1>

<div>
  <h2>Start service on boot</h2>
  LIST IF SYSTEMD SERVICE EXISTS
</div>

<div>
  <h2>Configure user permissions</h2>
  LIST IF PART OF ALL GROUPS
</div>

<div>
  <h2>Errors</h2>
  LIST ALL ERRORS
</div>

<style>
  .mode-select input\[type=radio] {
      display: none;
  }
  .mode-select .resolution:hover, 
  .mode-select label:has(input\[type=radio]):hover {
      background-color: #a8e6a3;
  }
  .mode-select .mode:has(input:checked) {
      background-color: #ccc;
  }
  .mode-select .mode:has(input:checked) .resolution,
  .mode-select label:has(input:checked) {
      background-color: #27ae60;
  }
  .mode-select .resolution {
      width: 100px;
  }
  .mode {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
  }
</style>

<div class="mode-select">
  <h2>Displays</h2>
  [HtmlWhen $::thisNode has display /displayIdx/ with /...opts/ {
    set info [dict get $opts info]

    set modesByRegion [dict create]
    foreach mode [dict getdef $info modes [list]] {
      dict lappend modesByRegion $mode(visibleRegion) $mode
    }
    set regions [lsort -decreasing -integer -index 0 \
                     [dict keys $modesByRegion]]

    subst {
      <div style="margin: 10px 0;">
        <strong>Display $displayIdx</strong> (<code>$info(name)</code>)<br>
        [if {[dict exists $info physicalResolution]} { subst {
            (Physical resolution: [join $info(physicalResolution) x])
        } } else { list }]

        [if {[llength $regions] > 0} { subst {
        <fieldset style="margin-left: 20px;">
          <legend>Select mode:</legend>
          [join [lmap region $regions {
            lassign $region width height
            set refreshRates [lmap mode [dict get $modesByRegion $region] \
                                   {dict get $mode refreshRate}]
            set refreshRates [lsort -decreasing -integer $refreshRates]
            subst {
              <div class="mode">
                <span class="resolution">${width}x${height}</span>
                [join [lmap refreshRate $refreshRates { subst {
                  <label>
                    <input type="radio" name="display-refreshRate-$displayIdx">
                    [format "%.3g" [/ $refreshRate 1000]] Hz
                  </label>
                } }] \n]
              </div>
            }
          }] \n]
        </fieldset>
        } } else { list }]
      </div>
    }
  }]

  <script>
  const displayRadios = document.querySelectorAll('input\[name="display-type"\]');
  displayRadios.forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.value === 'glfw' && this.checked) {
        await folk.run('Hold! -save -key display-type Wish $::thisNode uses display glfw with width 640 height 480');
      }
    });
  });
  </script>
</div>

<div class="mode-select">
  <h2>Cameras</h2>
  [join [lmap cameraData [Query! $::thisNode has camera /camera/ with /...opts/] { dict with cameraData {
    set camera [dict get $cameraData camera]

    set resolutions [list]
    foreach format [dict get $cameraData(opts) formats] {
        # For now, we only support MJPG. The more raw formats are
        # rarely used by cameras at even medium resolutions and
        # framerates, anyway, so it's only worth supporting MJPG.
        if {$format(fourcc) eq "MJPG"} {
            lappend resolutions {*}$format(resolutions)
        }
    }
    set resolutions [lsort -command {apply {{a b} {
        expr {[dict get $b width] - [dict get $a width]}
    }}} $resolutions]

    if {[llength $resolutions] == 0} {
      # Cameras often have extra camera devices with no formats (or no
      # MJPG, at least) for some reason. Not very useful for us.
      subst {
      <div style="margin: 10px 0; border: 1px solid #ccc; padding: 10px;">
        <strong>$camera</strong> (no supported formats)
      </div>
      }

    } else {
      set cameraId [string map {/ _} $camera]
      subst {
      <div style="margin: 10px 0; border: 1px solid #ccc; padding: 10px;">
        <label>
          <input type="checkbox" name="camera-enabled" value="$camera" data-camera-id="$cameraId">
          <strong>$camera</strong>
        </label>

        <fieldset style="margin-left: 20px; margin-top: 10px">
          <legend>Select resolution:</legend>
          [join [lmap resolution $resolutions { subst {
            <div class="mode">
              <span class="resolution">${resolution(width)}x${resolution(height)}</span>
              [join [lmap framerate $resolution(framerates) { subst {
                <label>
                  <input type="radio" name="camera-framerate-$cameraId">
                  [format "%.3g" $framerate] Hz
                </label>
              } }] \n]
            </div>
          } }] \n]
        </fieldset>

        <div id="camera-preview-$cameraId" style="margin-top: 10px; display: none;">
          <img src="/camera-frame?camera=[string map {/ %2F} $camera]"
            style="max-width: 320px; border: 1px solid #999;">
        </div>
      </div>
      }
    }
  } }] \n]

  <script>
  // Handle camera enable/disable.
  document.querySelectorAll('input\[name="camera-enabled"\]').forEach(checkbox => {
    checkbox.addEventListener('change', async function() {
      const cameraId = this.dataset.cameraId;
      const previewDiv = document.getElementById(`camera-preview-\${cameraId}`);

      if (this.checked) {
        previewDiv.style.display = 'block';
      } else {
        previewDiv.style.display = 'none';
        // TODO: Remove the wish when unchecked
      }
    });
  });

  // Handle camera format selection.
  document.querySelectorAll('input\[type="radio"\]\[name^="camera-framerate-"\]').forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.checked) {
        const camera = this.dataset.camera;
        const format = this.value;
        // TODO: Parse format dict and extract width/height, then create wish
        await folk.run(`Hold! -save -key camera-\${camera} Wish $::thisNode uses camera "\${camera}" with \${format}`);
      }
    });
  });
  </script>
</div>

<div>
  <h2>Projector-camera calibration</h2>
  - radio buttons for projectors
  - check boxes for cameras
<button>Calibrate</button>
</div>

</body>
</html>
}]
}
