Wish the web server handles route "/setup" with handler {
    html [subst {
<html>
<head>
<title>Folk setup</title>
<script src="/lib/folk.js"></script>
</head>

<body>
<script>
const folk = new FolkWS();

let hasSeenHandlers = false;
folk.watchCollected(`/someone/ wishes the web server handles route "/setup" with handler /handler/`, handlers => {
    if (hasSeenHandlers) {
        window.location.reload();
    } else {
        hasSeenHandlers = true;
    }
});
</script>

<h1>Folk setup</h1>

<div>
  <h2>Start service on boot</h2>
  LIST IF SYSTEMD SERVICE EXISTS
</div>

<div>
  <h2>Configure user permissions</h2>
  LIST IF PART OF ALL GROUPS
</div>

<div>
  <h2>Errors</h2>
  LIST ALL ERRORS
</div>

<div>
  <h2>Display</h2>
  <div>
    <label>
      <input type="radio" name="display-type" value="glfw">
      GLFW (windowed)
    </label>
  </div>

  <div>
    <label>
      <input type="radio" name="display-type" value="direct">
      Direct to display
    </label>

    <h3>Available displays:</h3>
    [join [lmap disp [Query! $::thisNode has display /displayIdx/ with /...opts/] {
      set displayIdx $disp(displayIdx)
      set info [dict get $disp(opts) info]

      set modesByRegion [dict create]
      foreach mode $info(modes) {
        dict lappend modesByRegion $mode(visibleRegion) $mode
      }
      set regions [lsort -decreasing -integer -index 0 [dict keys $modesByRegion]]

      subst {
        <div style="margin: 10px 0;">
          <strong>Display $displayIdx</strong>: <code>$info(name)</code><br>
          (Physical resolution: [join $info(physicalResolution) x])

          <fieldset style="margin-left: 20px;">
            <legend>Select mode:</legend>
            [join [lmap region $regions {
              lassign $region width height
              set refreshRates [lmap mode [dict get $modesByRegion $region] \
                                     {dict get $mode refreshRate}]
              set refreshRates [lsort -decreasing -integer $refreshRates]
              subst {
                <label style="display: block;">
                  <input type="radio" name="display-mode-$displayIdx" value="$mode">
                  ${width}x${height}
                  [join [lmap refreshRate $refreshRates { subst {
                    <label>
                      <input type="radio" name="display-refreshrate-$displayIdx-${width}x${height}">
                      [format "%.3g" [/ $refreshRate 1000]] Hz
                    </label>
                  } }] \n]
                </label>
              }
            }] \n]
          </fieldset>
        </div>
      }
    }] \n]
  </div>

  <script>
  const displayRadios = document.querySelectorAll('input\[name="display-type"\]');
  displayRadios.forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.value === 'glfw' && this.checked) {
        await folk.evaluate('Hold! -save -key display-type Wish $::thisNode uses display glfw with width 640 height 480');
      }
    });
  });
  </script>
</div>

<div>
  <h2>Camera</h2>
  [join [lmap cameraData [Query! $::thisNode has camera /camera/ with /...opts/] { dict with cameraData {
    set camera [dict get $cameraData camera]

    set resolutions [list]
    foreach format [dict get $cameraData(opts) formats] {
        # For now, we only support MJPG. The more raw formats are
        # rarely used by cameras at even medium resolutions and
        # framerates, anyway, so it's only worth supporting MJPG.
        if {$format(fourcc) eq "MJPG"} {
            lappend resolutions {*}$format(resolutions)
        }
    }
    set resolutions [lsort -command {apply {{a b} {
        expr {[dict get $b width] - [dict get $a width]}
    }}} $resolutions]

    if {[llength $resolutions] == 0} {
      # Cameras often have extra camera devices with no formats (or no
      # MJPG, at least) for some reason. Not very useful for us.
      subst {
      <div style="margin: 10px 0; border: 1px solid #ccc; padding: 10px;">
        <strong>$camera</strong> (no supported formats)
      </div>
      }

    } else {
      set cameraId [string map {/ _} $camera]
      subst {
      <div style="margin: 10px 0; border: 1px solid #ccc; padding: 10px;">
        <label>
          <input type="checkbox" name="camera-enabled" value="$camera" data-camera-id="$cameraId">
          <strong>$camera</strong>
        </label>

        <fieldset style="margin-left: 20px; margin-top: 10px">
          <legend>Select resolution:</legend>
          [join [lmap resolution $resolutions { subst {
            <label style="display: block;">
              <input type="radio" name="camera-format-$cameraId" value="$resolution" data-camera="$camera">
              ${resolution(width)}x${resolution(height)}
              [join [lmap framerate $resolution(framerates) { subst {
                <label>
                  <input type="radio" name="camera-framerate-$cameraId-${resolution(width)}x${resolution(height)}">
                  [format "%.3g" $framerate] Hz
                </label>
              } }] \n]
            </label>
          } }] \n]
        </fieldset>

        <div id="camera-preview-$cameraId" style="margin-top: 10px; display: none;">
          <img src="/camera-frame?camera=[string map {/ %2F} $camera]"
            style="max-width: 320px; border: 1px solid #999;"
            alt="Camera preview">
        </div>
      </div>
      }
    }
  } }] \n]

  <script>
  // Handle camera enable/disable.
  document.querySelectorAll('input\[name="camera-enabled"\]').forEach(checkbox => {
    checkbox.addEventListener('change', async function() {
      const cameraId = this.dataset.cameraId;
      const previewDiv = document.getElementById(`camera-preview-\${cameraId}`);

      if (this.checked) {
        previewDiv.style.display = 'block';
      } else {
        previewDiv.style.display = 'none';
        // TODO: Remove the wish when unchecked
      }
    });
  });

  // Handle camera format selection.
  document.querySelectorAll('input\[type="radio"\]\[name^="camera-framerate-"\]').forEach(radio => {
    radio.addEventListener('change', async function() {
      if (this.checked) {
        const camera = this.dataset.camera;
        const format = this.value;
        // TODO: Parse format dict and extract width/height, then create wish
        await folk.evaluate(`Hold! -save -key camera-\${camera} Wish $::thisNode uses camera "\${camera}" with \${format}`);
      }
    });
  });
  </script>
</div>

<div>
  <h2>Projector-camera calibration</h2>
  - radio buttons for projectors
  - check boxes for cameras
<button>Calibrate</button>
</div>

</body>
</html>
}]
}
