Wish $this has filename "tags-and-calibration.folk"

if {$::isLaptop} { return }

namespace eval ::Camera {
    variable WIDTH 1280
    variable HEIGHT 720
}

package require math::linearalgebra
namespace import ::math::linearalgebra::add \
	::math::linearalgebra::sub \
	::math::linearalgebra::matmul \
	::math::linearalgebra::scale \
	::math::linearalgebra::angle \
	::math::linearalgebra::solvePGauss

# camera (tag) point -> projection point
# calibration for Hex
if [catch {source "/home/folk/generated-calibration.tcl"}] {
  set points {
	{622 404 1706 1051}
	{624 650 1661 51}
	{1031 669 8 44}
	{1024 403 13 1146}
  }
} else {
  set points [list]
  foreach correspondence $generatedCalibration::points {
    lassign $correspondence cx cy dx dy
    lappend points [list [expr {double($cx)/$generatedCalibration::cameraWidth*$Camera::WIDTH}] \
                         [expr {double($cy)/$generatedCalibration::cameraHeight*$Camera::HEIGHT}] \
                         [expr {double($dx)/$generatedCalibration::displayWidth*$Display::WIDTH}] \
                         [expr {double($dy)/$generatedCalibration::displayHeight*$Display::HEIGHT}]]
  }
}
for {set i 0} {$i < [llength $points]} {incr i} {
    lassign [lindex $points $i] x$i y$i u$i v$i
}

set A [subst {
    {$x0 $y0 1 0   0   0 [expr -$x0*$u0] [expr -$y0*$u0]}
    {$x1 $y1 1 0   0   0 [expr -$x1*$u1] [expr -$y1*$u1]}
    {$x2 $y2 1 0   0   0 [expr -$x2*$u2] [expr -$y2*$u2]}
    {$x3 $y3 1 0   0   0 [expr -$x3*$u3] [expr -$y3*$u3]}
    {0   0   0 $x0 $y0 1 [expr -$x0*$v0] [expr -$y0*$v0]}
    {0   0   0 $x1 $y1 1 [expr -$x1*$v1] [expr -$y1*$v1]}
    {0   0   0 $x2 $y2 1 [expr -$x2*$v2] [expr -$y2*$v2]}
    {0   0   0 $x3 $y3 1 [expr -$x3*$v3] [expr -$y3*$v3]}
}]

set b [list $u0 $u1 $u2 $u3 $v0 $v1 $v2 $v3]

lassign [solvePGauss $A $b] a0 a1 a2 b0 b1 b2 c0 c1

set ::H [subst {
    {$a0 $a1 $a2}
    {$b0 $b1 $b2}
    {$c0 $c1 1}
}]
set ::Hinv [solvePGauss $::H [math::linearalgebra::mkIdentity 3]]

# FIXME: these shouldn't be global
proc ::cameraToProjector {cameraPoint} {
    # FIXME: this is slow but not the cause of leak
    lassign [::math::linearalgebra::matmul $::H [list [lindex $cameraPoint 0] [lindex $cameraPoint 1] 1]] Hx Hy Hz
    set Hx [expr {$Hx / $Hz}]
    set Hy [expr {$Hy / $Hz}]
    return [list $Hx $Hy]
}
proc ::projectorToCamera {projectorPoint} {
    lassign [::math::linearalgebra::matmul $::Hinv [list [lindex $projectorPoint 0] [lindex $projectorPoint 1] 1]] Hinvx Hinvy Hinvz
    set Hinvx [expr {$Hinvx / $Hinvz}]
    set Hinvy [expr {$Hinvy / $Hinvz}]
    return [list $Hinvx $Hinvy]
}
# Wish $this is highlighted white

When (non-capturing) tag /tag/ has center /c/ size /size/ {
     Claim tag $tag is a tag

     lassign [::cameraToProjector $c] px py
     Claim $tag is a rectangle with x [expr $px-20] y [expr $py-10] width [expr $size*2] height [expr $size*2]
}

When (non-capturing) tag /tag/ is a tag {
     puts "Added tag $tag"

     set fp [open "$::env(HOME)/folk-printed-programs/$tag.folk" r]
     set code [read $fp]
     close $fp

     # Wish $tag is outlined green
     Claim $tag has program code $code
}


When (non-capturing) tag /tag/ has corners /corners/ {
    set tagcorners [lmap p $corners {::cameraToProjector $p}]
    # foreach tagcorner $tagcorners { Display::text fb {*}$tagcorner 10 "$tag" }
    Display::fillQuad {*}$tagcorners white

    set tagbottom [sub [lindex $tagcorners 1] [lindex $tagcorners 0]]
    set tagright [sub [lindex $tagcorners 2] [lindex $tagcorners 1]]

    set offsets {{-4.7 -2.6} {1 -2.6} {1 0.8} {-4.7 0.8}}
    set corners [add $tagcorners [matmul $offsets [list $tagbottom $tagright]]]
    set edges [list]
    for {set i 0} {$i < [llength $corners]} {incr i} {
        if {$i > 0} { lappend edges [list [expr {$i - 1}] $i] }
    }
    lappend edges [list [expr {[llength $corners] - 1}] 0]
    set region [list $corners $edges [::tcl::mathfunc::atan2 {*}$tagright]] 
    Claim $tag has region $region
}
