Wish $this has filename "tags-and-calibration.folk"

if {$::isLaptop} { return }

package require math::linearalgebra
namespace import ::math::linearalgebra::add \
	::math::linearalgebra::sub \
	::math::linearalgebra::matmul \
	::math::linearalgebra::scale \
	::math::linearalgebra::angle \
	::math::linearalgebra::solvePGauss

set cc [c create]
$cc include <stdlib.h>
$cc code {
  typedef struct {
      uint32_t width;
      uint32_t height;
      uint16_t* columnCorr;
      uint16_t* rowCorr;
  } dense_t;
  dense_t* dense;
}
$cc proc deserializeDenseCorrespondence {} void {
  FILE* in = fopen("/home/folk/generated-dense.dense", "r");
  dense = calloc(sizeof(dense_t), 1);
  fread(&dense->width, sizeof(uint32_t), 1, in);
  fread(&dense->height, sizeof(uint32_t), 1, in);
  dense->rowCorr = calloc(dense->width*dense->height, sizeof(uint16_t));
  dense->columnCorr = calloc(dense->width*dense->height, sizeof(uint16_t));
  fread(dense->columnCorr, sizeof(uint16_t), dense->width*dense->height, in); 
  fread(dense->rowCorr, sizeof(uint16_t), dense->width*dense->height, in);
}
$cc proc ::cameraToProjector {Tcl_Obj* cameraPoint} Tcl_Obj* [csubst {
    int cameraPointLength; Tcl_Obj** cameraPointValues;
    Tcl_ListObjGetElements(NULL, cameraPoint, &cameraPointLength, &cameraPointValues);
    double cx; Tcl_GetDoubleFromObj(NULL, cameraPointValues[0], &cx);
    double cy; Tcl_GetDoubleFromObj(NULL, cameraPointValues[1], &cy);

    double dcx = cx/$Camera::WIDTH * dense->width;
    double dcy = cy/$Camera::HEIGHT * dense->height;
    
    int i = (int)dcy*dense->width + (int)dcx;
    int Hx = dense->columnCorr[i];
    int Hy = dense->rowCorr[i];
    Tcl_Obj* projectorPointValues[] = {Tcl_NewIntObj(Hx), Tcl_NewIntObj(Hy)};
    return Tcl_NewListObj(2, projectorPointValues);
}]
$cc proc ::projectorToCamera {Tcl_Obj* projectorPoint} Tcl_Obj* {
    Tcl_Obj* cameraPointValues[] = {Tcl_NewIntObj(100), Tcl_NewIntObj(100)};
    return Tcl_NewListObj(2, cameraPointValues);
}
$cc compile

deserializeDenseCorrespondence

When (non-capturing) tag /tag/ has center /c/ size /size/ {
     Claim tag $tag is a tag

     lassign [::cameraToProjector $c] px py
     Claim $tag is a rectangle with x [expr $px-20] y [expr $py-10] width [expr $size*2] height [expr $size*2]
}

When (non-capturing) tag /tag/ is a tag {
     puts "Added tag $tag"

     set fp [open "$::env(HOME)/folk-printed-programs/$tag.folk" r]
     set code [read $fp]
     close $fp

     # Wish $tag is outlined green
     Claim $tag has program code $code
}


When (non-capturing) tag /tag/ has corners /corners/ {
    set tagcorners [lmap p $corners {::cameraToProjector $p}]
    # foreach tagcorner $tagcorners { Display::text fb {*}$tagcorner 10 "$tag" }
    Display::fillQuad {*}$tagcorners white

    set tagbottom [sub [lindex $tagcorners 1] [lindex $tagcorners 0]]
    set tagright [sub [lindex $tagcorners 2] [lindex $tagcorners 1]]

    set offsets {{-4.7 -2.6} {1 -2.6} {1 0.8} {-4.7 0.8}}
    set corners [add $tagcorners [matmul $offsets [list $tagbottom $tagright]]]
    set edges [list]
    for {set i 0} {$i < [llength $corners]} {incr i} {
        if {$i > 0} { lappend edges [list [expr {$i - 1}] $i] }
    }
    lappend edges [list [expr {[llength $corners] - 1}] 0]
    set region [list $corners $edges [::tcl::mathfunc::atan2 {*}$tagright]] 
    Claim $tag has region $region
}
