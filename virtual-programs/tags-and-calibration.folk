Wish $this has filename "tags-and-calibration.folk"

if {$::isLaptop} { return }

package require math::linearalgebra
namespace import ::math::linearalgebra::add \
	::math::linearalgebra::sub \
	::math::linearalgebra::matmul \
	::math::linearalgebra::scale \
	::math::linearalgebra::angle \
	::math::linearalgebra::solvePGauss

set cc [c create]
$cc include <stdlib.h>
$cc code {
  typedef struct {
      uint32_t width;
      uint32_t height;
      uint16_t* columnCorr;
      uint16_t* rowCorr;
  } dense_t;
  dense_t* dense;
}
$cc proc deserializeDenseCorrespondence {} void {
  FILE* in = fopen("/home/folk/generated-clean-dense.dense", "r");
  dense = calloc(sizeof(dense_t), 1);
  fread(&dense->width, sizeof(uint32_t), 1, in);
  fread(&dense->height, sizeof(uint32_t), 1, in);
  dense->rowCorr = calloc(dense->width*dense->height, sizeof(uint16_t));
  dense->columnCorr = calloc(dense->width*dense->height, sizeof(uint16_t));
  fread(dense->rowCorr, sizeof(uint16_t), dense->width*dense->height, in);
  fread(dense->columnCorr, sizeof(uint16_t), dense->width*dense->height, in); 
}
$cc proc ::cameraToProjector {Tcl_Obj* cameraPoint} Tcl_Obj* {
    int cameraPointLength; Tcl_Obj** cameraPointValues;
    Tcl_ListObjGetElements(NULL, cameraPoint, &cameraPointLength, &cameraPointValues);
    double cx; Tcl_GetDoubleFromObj(NULL, cameraPointValues[0], &cx);
    double cy; Tcl_GetDoubleFromObj(NULL, cameraPointValues[1], &cy);

    int i = (int)cy * dense->width + (int)cx;
    int Hx = dense->columnCorr[i];
    int Hy = dense->rowCorr[i];
    Tcl_Obj* projectorPointValues[] = {Tcl_NewIntObj(Hx), Tcl_NewIntObj(Hy)};
    return Tcl_NewListObj(2, projectorPointValues);
}
$cc proc ::projectorToCamera {Tcl_Obj* projectorPoint} Tcl_Obj* {
    Tcl_Obj* cameraPointValues[] = {Tcl_NewIntObj(100), Tcl_NewIntObj(100)};
    return Tcl_NewListObj(2, cameraPointValues);
}
$cc compile

deserializeDenseCorrespondence

Say when tag /tag/ has center /c/ size /size/ {
     Claim tag $tag is a tag

     lassign [cameraToProjector $c] px py
     Claim $tag is a rectangle with x [expr $px-20] y [expr $py-10] width [expr $size*2] height [expr $size*2]
} with environment {}

When tag /tag/ is a tag {
     puts "Added tag $tag"

     set fp [open "$::env(HOME)/folk-printed-programs/$tag.folk" r]
     set code [read $fp]
     close $fp

     # Wish $tag is outlined green
     Claim $tag has program code $code
}


Say when tag /tag/ has corners /corners/ {
	set tagcorners [lmap p $corners {cameraToProjector $p}]
  #foreach tagcorner $tagcorners { Display::text fb {*}$tagcorner 10 "$tag" }
  Display::fillQuad {*}$tagcorners white
	set tagbottom [sub [lindex $tagcorners 1] [lindex $tagcorners 0]]
	set tagright [sub [lindex $tagcorners 2] [lindex $tagcorners 1]]

	set offsets {{-4.7 -3.5} {1 -3.5} {1 0.8} {-4.7 0.8}}
	set corners [add $tagcorners [matmul $offsets [list $tagbottom $tagright]]]
	set edges [list]
	for {set i 0} {$i < [llength $corners]} {incr i} {
		if {$i > 0} { lappend edges [list [expr {$i - 1}] $i] }
	}
	lappend edges [list [expr {[llength $corners] - 1}] 0]
	set region [list $corners $edges [::tcl::mathfunc::atan2 {*}$tagright]] 
	Claim $tag has region $region
} with environment {
    %matmul ::math::linearalgebra::matmul
    %sub ::math::linearalgebra::sub
    %add ::math::linearalgebra::add
}
