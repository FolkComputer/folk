package require json
package require json::write

When /page/ is a keyboard with path /kbPath/ /...anything/ &\
     /page/ is an editor {
    set previewProgramId "$page$kbPath"

    When $previewProgramId has editor code /editorCode/ &\
         $previewProgramId has program code /programCode/ &\
         the $kbPath cursor is /cursor/ {
        json::write indented false

        Claim $page has js coder info with type editor1 json [json::write object \
            previewProgramId [json::write string $previewProgramId] \
            kbPath           [json::write string $kbPath]]

        Claim $page has js coder state with json [json::write object \
            editorCode       [json::write string $editorCode] \
            programCode      [json::write string $programCode] \
            cursor           $cursor]
    }
}

When /view/ is a code view with /...anything/ &\
     /view/ has selected program /selectedProgram/ &\
     view code for /selectedProgram/ is /programCode/ &\
     /view/ has cursor /cursor/ {
    json::write indented false

    Claim $view has js coder info with type codeView json [json::write object \
        selectedProgram [json::write string $selectedProgram]]

    Claim $view has js coder state with json [json::write object \
        programCode [json::write string $programCode] \
        cursor      $cursor]
}

Wish the web server handles route "/editor-control" with handler {
    html {
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Editor copy/paste</title>
        <script src="/lib/folk.js"></script>
    </head>
    <body>
        <span id="status">Status</span>
        <p>
            Select a keyboard or code view: <select id="coder-select"></select>
        </p>
        <textarea id="code" cols="120" rows="40"></textarea>
        <script>
const ws = new FolkWS(document.getElementById('status'));
const coderSelectElem = document.querySelector("#coder-select");
const textarea = document.querySelector("#code");

var coderInfo = {};
var currentCoder = null;

// temporarily disable event processing after sending new code to prevent recursive event sends
var allowLocalEventsToProcess = true;
var allowRemoteEventsToProcess = true;
var _remoteTimoutHandle;
var _localTimeoutHandle;
function disableRemoteEventProcessing(durationMs) {
    if (_remoteTimoutHandle) clearTimeout(_remoteTimoutHandle);
    allowRemoteEventsToProcess = false;

    _remoteTimoutHandle = setTimeout(() => {
        allowRemoteEventsToProcess = true;
    }, durationMs);
}

function disableLocalEventProcessing(durationMs) {
    if (_localTimeoutHandle) clearTimeout(_localTimeoutHandle);
    allowLocalEventsToProcess = false;

    _localTimeoutHandle = setTimeout(() => {
        allowLocalEventsToProcess = true;
    }, durationMs);
}

function updateCursorAndCode(ev) {
    if (!allowLocalEventsToProcess) return;
    disableRemoteEventProcessing(500);

    const newCode = textarea.value;
    const newCursor = textarea.selectionStart;

    switch (currentCoder.type) {
        case "codeView":
            ws.evaluate(tcl`
                Hold (non-capturing) (on virtual-programs/code-view.folk) view-state-of:${currentCoder.id} {
                    set newCode [binary decode base64 ${btoa(newCode)}]
                    set newCursor ${newCursor}
                    set selectedProgram ${currentCoder.json.selectedProgram}
                    set view ${currentCoder.id}

                    When ${currentCoder.id} has view dimensions /dims/ {
                        Claim $view has view dimensions $dims
                        Claim $view has cursor $newCursor
                        lassign [editor::cursorToXy $newCode $newCursor] cursorX cursorY
                        Claim $view has max cursor x $cursorX
                    }
                    
                    Hold (on virtual-programs/code-view.folk) code-for:$selectedProgram {
                        Claim view code for $selectedProgram is $newCode
                    }
                }
            `);
            break;
        case "editor1":
            const {kbPath, previewProgramId} = currentCoder.json;
            ws.evaluate(tcl`
                Hold (non-capturing) (on virtual-programs/editor.folk) ${"cursor" + kbPath} {
                    set kbPath ${kbPath}
                    set newCode [binary decode base64 ${btoa(newCode)}]

                    Claim the $kbPath cursor is ${newCursor}
                    lassign [editor::cursorToXy $newCode ${newCursor}] cursorX cursorY
                    Claim the $kbPath max cursor x is $cursorX

                    Every time ${previewProgramId} has program code /programCode/ {
                        Hold (on virtual-programs/editor.folk) code$kbPath {
                            Claim ${previewProgramId} has program code $programCode
                            Claim ${previewProgramId} has editor code $newCode
                        }
                    }
                }
            `);
            break;
    }    
}

function updateProgramCode() {
    disableRemoteEventProcessing(500);

    const currentCode = textarea.value;

    switch (currentCoder.type) {
        case "codeView":
            // TODO: replace this with an event firing when events are added
            ws.evaluate(tcl`
                Hold (on virtual-programs/code-view.folk) saving-code-for:${currentCoder.id} {
                    Wish to save code on view ${currentCoder.id}
                }
            `);
            break;
        case "editor1":
            const {kbPath, previewProgramId} = currentCoder.json;

            ws.evaluate(tcl`
                Hold (on virtual-programs/editor.folk) ${"code" + kbPath} {
                    set currentCode [binary decode base64 ${btoa(currentCode)}]

                    Claim ${previewProgramId} has program code $currentCode
                    Claim ${previewProgramId} has editor code $currentCode
                }
            `);
            break;
    }
}

textarea.addEventListener("input", updateCursorAndCode);
textarea.addEventListener("selectionchange", updateCursorAndCode);
textarea.addEventListener("keydown", ev => {
    if(ev.keyCode === 83 /* s */ && (navigator.platform.match("Mac") ? ev.metaKey : ev.ctrlKey)) {
        ev.preventDefault();
        updateProgramCode();
    }
});

var lastCoder; // to clean up the previous coder when another is picked
async function selectCoder(coder) {
    if (lastCoder) lastCoder.stop();

    currentCoder = coder;

    switch (coder.type) {
        case "codeView":
            lastCoder = await ws.watch(`${coder.id} has js coder state with json /json/`, {
                add: ({json}) => {
                    if (!allowRemoteEventsToProcess) return;
                    disableLocalEventProcessing(500);

                    json = JSON.parse(json);

                    textarea.value = json.programCode;
                    textarea.selectionStart = json.cursor;
                    textarea.selectionEnd = json.cursor;
                    textarea.focus();
                }
            });
            break;
        case "editor1":
            lastCoder = await ws.watch(`${coder.id} has js coder state with json /json/`, {
                add: ({json}) => {
                    if (!allowRemoteEventsToProcess) return;
                    disableLocalEventProcessing(500);

                    json = JSON.parse(json);

                    textarea.value = json.editorCode;
                    textarea.selectionStart = json.cursor;
                    textarea.selectionEnd = json.cursor;
                    textarea.focus();
                }
            });
            break;
    }
}

// update states as they change
ws.watchCollected("/id/ has js coder info with type /type/ json /json/", infos => {
    for (let info of infos) {
        info.json = JSON.parse(info.json);
    }

    coderSelectElem.innerHTML = "";

    coderInfo = {};
    for (let info of infos) {
        coderInfo[info.id] = info;

        if (info.type === "codeView") {
            coderSelectElem.innerHTML += `<option value="${info.id}">Code view #${info.id}</option>`;
        } else if (info.type === "editor1") {
            coderSelectElem.innerHTML += `<option value="${info.id}">Editor #${info.id} (${info.json.kbPath})</option>`;
        }
    }

    // does the coder not exist anymore?
    if (currentCoder && coderInfo[currentCoder.id] === undefined) {
        currentCoder = null;
    }

    // don't select the default coder if we already have one selected
    if (currentCoder === null && infos.length >= 1) {
        selectCoder(infos[0]);
    }
});

// fired when selected keyboard changes
coderSelectElem.addEventListener("input", (ev) => {
    selectCoder(coderInfo[ev.target.value]);
});
        </script>
    </body>
</html>
    }
}
