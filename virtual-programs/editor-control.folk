When /page/ is a keyboard with path /kbPath/ /...anything/ &\
     /page/ is an editor {
    set previewProgramId "$page$kbPath"

    When $previewProgramId has editor code /editorCode/ &\
         $previewProgramId has program code /programCode/ &\
         the $kbPath cursor is /cursor/ {
        Claim $page has js coder info with type editor1 previewProgramId $previewProgramId kbPath $kbPath
        Claim $page has js coder state with editorCode $editorCode programCode $programCode cursor $cursor
    }
}

When /view/ is a code view with /...anything/ &\
     /view/ has selected program /selectedProgram/ &\
     view code for /selectedProgram/ is /programCode/ &\
     /view/ has cursor /cursor/ {
    Claim $view has js coder info with type codeView selectedProgram $selectedProgram
    Claim $view has js coder state with programCode $programCode cursor $cursor
}

Wish the web server handles route "/editor-control" with handler {
    html {
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Editor copy/paste</title>
        <script src="/lib/folk.js"></script>
    </head>
    <body>
        <span id="status">Status</span>
        <p>
            Select a keyboard or code view: <select id="coder-select"></select>
        </p>
        <textarea id="code" cols="120" rows="40"></textarea>
        <script>
const ws = new FolkWS(document.getElementById('status'));
const coderSelectElem = document.querySelector("#coder-select");
const textarea = document.querySelector("#code");

var coderConfigs = {};
var currentCoder = null;

// temporarily disable event processing after sending new code to prevent recursive event sends
var allowLocalEventsToProcess = true;
var allowRemoteEventsToProcess = true;
var _remoteTimoutHandle;
var _localTimeoutHandle;
function disableRemoteEventProcessing(durationMs) {
    if (_remoteTimoutHandle) clearTimeout(_remoteTimoutHandle);
    allowRemoteEventsToProcess = false;

    _remoteTimoutHandle = setTimeout(() => {
        allowRemoteEventsToProcess = true;
    }, durationMs);
}

function disableLocalEventProcessing(durationMs) {
    if (_localTimeoutHandle) clearTimeout(_localTimeoutHandle);
    allowLocalEventsToProcess = false;

    _localTimeoutHandle = setTimeout(() => {
        allowLocalEventsToProcess = true;
    }, durationMs);
}

function updateCursorAndCode(ev) {
    if (!allowLocalEventsToProcess) return;
    disableRemoteEventProcessing(500);

    const newCode = textarea.value;
    const newCursor = textarea.selectionStart;

    switch (currentCoder.config.type) {
        case "codeView":
            ws.evaluate(tcl`
                Hold (non-capturing) (on virtual-programs/code-view.folk) view-state-of:${currentCoder.id} {
                    set newCode ${newCode}
                    set newCursor ${newCursor}
                    set selectedProgram ${currentCoder.config.selectedProgram}
                    set view ${currentCoder.id}

                    When ${currentCoder.id} has view dimensions /dims/ {
                        Claim $view has view dimensions $dims
                        Claim $view has cursor $newCursor
                        lassign [editor::cursorToXy $newCode $newCursor] cursorX cursorY
                        Claim $view has max cursor x $cursorX
                    }
                    
                    Hold (on virtual-programs/code-view.folk) code-for:$selectedProgram {
                        Claim view code for $selectedProgram is $newCode
                    }
                }
            `);
            break;
        case "editor1":
            const {kbPath, previewProgramId} = currentCoder.config;
            ws.evaluate(tcl`
                Hold (non-capturing) (on virtual-programs/editor.folk) ${"cursor" + kbPath} {
                    set kbPath ${kbPath}
                    set newCode ${newCode}

                    Claim the $kbPath cursor is ${newCursor}
                    lassign [editor::cursorToXy $newCode ${newCursor}] cursorX cursorY
                    Claim the $kbPath max cursor x is $cursorX

                    Every time ${previewProgramId} has program code /programCode/ {
                        Hold (on virtual-programs/editor.folk) code$kbPath {
                            Claim ${previewProgramId} has program code $programCode
                            Claim ${previewProgramId} has editor code $newCode
                        }
                    }
                }
            `);
            break;
    }    
}

function updateProgramCode() {
    disableRemoteEventProcessing(500);

    const currentCode = textarea.value;

    switch (currentCoder.config.type) {
        case "codeView":
            // TODO: replace this with an event firing when events are added
            ws.evaluate(tcl`
                Hold (on virtual-programs/code-view.folk) saving-code-for:${currentCoder.id} {
                    Wish to save code on view ${currentCoder.id}
                }
            `);
            break;
        case "editor1":
            const {kbPath, previewProgramId} = currentCoder.config;

            ws.evaluate(tcl`
                Hold (on virtual-programs/editor.folk) ${"code" + kbPath} {
                    set currentCode ${currentCode}

                    Claim ${previewProgramId} has program code $currentCode
                    Claim ${previewProgramId} has editor code $currentCode
                }
            `);
            break;
    }
}

textarea.addEventListener("input", updateCursorAndCode);
textarea.addEventListener("selectionchange", updateCursorAndCode);
textarea.addEventListener("keydown", ev => {
    if(ev.keyCode === 83 /* s */ && (navigator.platform.match("Mac") ? ev.metaKey : ev.ctrlKey)) {
        ev.preventDefault();
        updateProgramCode();
    }
});

var lastCoder; // to clean up the previous coder when another is picked
async function selectCoder(coder) {
    if (lastCoder) lastCoder.stop();

    currentCoder = coder;

    switch (coder.config.type) {
        case "codeView":
            lastCoder = await ws.watch(`${coder.id} has js coder state with /...params/`, {
                add: ({params}) => {
                    if (!allowRemoteEventsToProcess) return;
                    disableLocalEventProcessing(500);

                    params = loadDict(params);

                    textarea.value = params.programCode;
                    textarea.selectionStart = parseInt(params.cursor);
                    textarea.selectionEnd = parseInt(params.cursor);
                    textarea.focus();
                }
            });
            break;
        case "editor1":
            lastCoder = await ws.watch(`${coder.id} has js coder state with /...params/`, {
                add: ({params}) => {
                    if (!allowRemoteEventsToProcess) return;
                    disableLocalEventProcessing(500);

                    params = loadDict(params);

                    textarea.value = params.editorCode;
                    textarea.selectionStart = params.cursor;
                    textarea.selectionEnd = params.cursor;
                    textarea.focus();
                }
            });
            break;
    }
}

// update states as they change
ws.watchCollected("/id/ has js coder info with /...config/", coders => {
    for (let coder of coders) {
        coder.config = loadDict(coder.config);
    }

    coderSelectElem.innerHTML = "";

    coderConfigs = {};
    for (let coder of coders) {
        coderConfigs[coder.id] = coder;

        if (coder.config.type === "codeView") {
            coderSelectElem.innerHTML += `<option value="${coder.id}">Code view #${coder.id}</option>`;
        } else if (coder.config.type === "editor1") {
            coderSelectElem.innerHTML += `<option value="${coder.id}">Editor #${coder.id} (${coder.config.kbPath})</option>`;
        }
    }

    // does the coder not exist anymore?
    if (currentCoder && coderConfigs[currentCoder.id] === undefined) {
        currentCoder = null;
    }

    // don't select the default coder if we already have one selected
    if (currentCoder === null && coders.length >= 1) {
        selectCoder(coders[0]);
    }
});

// fired when selected keyboard changes
coderSelectElem.addEventListener("input", (ev) => {
    selectCoder(coderConfigs[ev.target.value]);
});
        </script>
    </body>
</html>
    }
}
