# Example program, i.e the public API
#
# When $this has camera slice /slice/ {
#     Wish $this displays camera slice $slice
# }

# Callback: extract out a camera slice
When the image library is /imageLib/ &\
     the quad library is /quadLib/ &\
     the pose library is /poseLib/ &\
     /someone/ wishes /p/ has camera slice &\
     camera /cam/ has intrinsics /cameraIntrinsics/ &\
     camera /cam/ has frame /f/ at timestamp /timestamp/ &\
     /p/ has quad /q/ {

    set fWidth [$imageLib Image_width $f]
    set fHeight [$imageLib Image_height $f]

    # Convert quad to camera coordinates
    set q [$quadLib change $q $cam]
    set minX 10000; set minY 10000
    set maxX -10000; set maxY -10000
    foreach v [$quadLib vertices $q] {
        lassign [$poseLib project $cameraIntrinsics \
                     $fWidth $fHeight \
                     $v] cx cy
        if {$cx < $minX} { set minX $cx }
        if {$cx > $maxX} { set maxX $cx }
        if {$cy < $minY} { set minY $cy }
        if {$cy > $maxY} { set maxY $cy }
    }

    # Clamp to image bounds
    if {$minX < 0} { set minX 0 }
    if {$maxX < 0} { set maxX 0 }
    if {$minY < 0} { set minY 0 }
    if {$maxY < 0} { set maxY 0 }
    if {$minX >= $fWidth} { set minX [- $fWidth 1] }
    if {$maxX >= $fWidth} { set maxX [- $fWidth 1] }
    if {$minY >= $fHeight} { set minY [- $fHeight 1] }
    if {$maxY >= $fHeight} { set maxY [- $fHeight 1] }

    set w [expr {$maxX - $minX}]
    set h [expr {$maxY - $minY}]
    if {$w <= 0 || $h <= 0} { return }

    # Extract and claim the image for the page
    set subimage [$imageLib subimage $f $minX $minY $w $h]
    Claim $p has camera slice $subimage
}

# Auto-trigger callback for `when has camera slice` statements
When when /p/ has camera slice /slice/ /lambda/ with environment /e/ {
  Wish $p has camera slice
}

# Display a camera slice
When /someone/ wishes /p/ displays camera slice /slice/ &\
     /p/ has resolved geometry /geom/ {
         # TODO: Mask the tag out?
    Wish to draw an image onto $p with image $slice \
        position [list 0 0] \
        anchor topleft \
        width [/ [dict get $geom left] 1.5]
}

When /someone/ wishes /p/ displays image /im/ with /...options/ {
    set im [image load $im]
    When $p has region /r/ {
        # Compute a scale for im that will fit in the region width/height
        # Draw im with scale and rotation
        if {![dict exists $options center]} {
            dict set options center [region centroid $r]
        }
        # set width [region width $r]
        # set height [region height $r]
        # set scale [expr {min($width / [image width $im],
        #                      $height / [image height $im])}]
        # Wish $p is labelled $im
        if {![dict exists $options radians]} {
            dict set options radians [region angle $r]
        }
        Wish to draw an image with image $im {*}$options
    }
    # On unmatch {
    #     # HACK: Leaves time for the display to finish trying to display this.
    #     after 5000 [list image freeJpeg $im]
    # }
}

When /someone/ wishes /p/ displays image /im/ {
    Wish $p displays image $im with scale 1
}
