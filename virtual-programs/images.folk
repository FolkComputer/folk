# TODO: Fix this program.
return

# Example program, i.e the public API
#
# When $this has camera slice /slice/ {
#     Wish $this displays camera slice $slice
# }

# Callback: extract out a camera slice
When /someone/ wishes /p/ has camera slice & \
     camera /cam/ has intrinsics /cameraIntrinsics/ & \
     camera /cam/ has frame /f/ at timestamp /timestamp/ & \
     /p/ has quad /q/ {

    # Convert quad to camera coordinates
    set q [quad change $q $cam]
    set minX 10000; set minY 10000
    set maxX -10000; set maxY -10000
    foreach v [quad vertices $q] {
        lassign [intrinsics project $cameraIntrinsics \
                     [::image width $f] [::image height $f] \
                     $v] cx cy
        if {$cx < $minX} { set minX $cx }
        if {$cx > $maxX} { set maxX $cx }
        if {$cy < $minY} { set minY $cy }
        if {$cy > $maxY} { set maxY $cy }
    }

    # Clamp to image bounds
    set minX [expr {max(0, min($minX, [image width $f]))}]
    set maxX [expr {max(0, min($maxX, [image width $f]))}]
    set minY [expr {max(0, min($minY, [image height $f]))}]
    set maxY [expr {max(0, min($maxY, [image height $f]))}]

    set w [expr {$maxX - $minX}]
    set h [expr {$maxY - $minY}]
    if {$w <= 0 || $h <= 0} { return }

    # Extract and claim the image for the page
    set subimage [image subimage $f [int $minX] [int $minY] [int $w] [int $h]]
    Claim $p has camera slice $subimage
}

# Auto-trigger callback for `when has camera slice` statements
When when /p/ has camera slice /slice/ /lambda/ with environment /e/ {
  Wish $p has camera slice
}

# Display a camera slice
When /someone/ wishes /p/ displays camera slice /slice/ & /p/ has region /r/ {
  set center [region centroid $r]
  # set scale [expr {$Display::WIDTH / $Camera::WIDTH}]
  # Use 1x scale instead of $scale so the projected tag doesn't redetect.
  # TODO: Mask the tag out?
    Wish to draw an image with center $center image $slice radians 0 scale 1
}

When /someone/ wishes /p/ displays image /im/ with /...options/ {
    set im [image load $im]
    When $p has region /r/ {
        # Compute a scale for im that will fit in the region width/height
        # Draw im with scale and rotation
        if {![dict exists $options center]} {
            dict set options center [region centroid $r]
        }
        # set width [region width $r]
        # set height [region height $r]
        # set scale [expr {min($width / [image width $im],
        #                      $height / [image height $im])}]
        # Wish $p is labelled $im
        if {![dict exists $options radians]} {
            dict set options radians [region angle $r]
        }
        Wish to draw an image with image $im {*}$options
    }
    # On unmatch {
    #     # HACK: Leaves time for the display to finish trying to display this.
    #     after 5000 [list image freeJpeg $im]
    # }
}

When /someone/ wishes /p/ displays image /im/ {
    Wish $p displays image $im with scale 1
}
