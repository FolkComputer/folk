
# Example program, i.e the public API
#
# When $this has camera slice /slice/ {
#     Wish $this displays camera slice $slice
# }

if {$::isLaptop} { return }

# Generic image class for sub-image manipulations
namespace eval ::image {
    proc width {im} { dict get $im width }
    proc height {im} { dict get $im height }
    proc subimage {im x y subwidth subheight} {
	dict with im {
	    set x [expr {int($x)}]
	    set y [expr {int($y)}]
	    set subdata [expr {$data + ($y*$width + $x) * $components}]
	    dict create \
		width $subwidth \
		height $subheight \
		components $components \
		bytesPerRow $bytesPerRow \
		data [format 0x%x $subdata]
	}
    }

    set cc [c create]
    c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/libjpeg.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep libjpeg] end]}]
    $cc cflags -ljpeg
    source "pi/cUtils.tcl"
    defineImageType $cc
    $cc include <stdlib.h>
    $cc include <string.h>
    $cc import ::Heap::cc folkHeapAlloc as folkHeapAlloc

    $cc code {
        #undef EXTERN
        #include <jpeglib.h>
        #include <stdint.h>
        #include <unistd.h>

        void 
    jpeg(FILE* dest, uint8_t* data, uint32_t components, uint32_t width, uint32_t height, int quality)
    {
        JSAMPARRAY image;
        if (components == 1) {
            image = calloc(height, sizeof (JSAMPROW));
            for (size_t i = 0; i < height; i++) {
                image[i] = calloc(width * 3, sizeof (JSAMPLE));
                for (size_t j = 0; j < width; j++) {
                    image[i][j * 3 + 0] = data[(i * width + j)];
                    image[i][j * 3 + 1] = data[(i * width + j)];
                    image[i][j * 3 + 2] = data[(i * width + j)];
                }
            }
        } else if (components == 3) {
            image = calloc(height, sizeof (JSAMPROW));
            for (size_t i = 0; i < height; i++) {
                image[i] = calloc(width * 3, sizeof (JSAMPLE));
                for (size_t j = 0; j < width; j++) {
                    image[i][j * 3 + 0] = data[(i * width + j) * 3];
                    image[i][j * 3 + 1] = data[(i * width + j) * 3 + 1];
                    image[i][j * 3 + 2] = data[(i * width + j) * 3 + 2];
                }
            }
        }

      struct jpeg_compress_struct compress;
      struct jpeg_error_mgr error;
      compress.err = jpeg_std_error(&error);
      jpeg_create_compress(&compress);
      jpeg_stdio_dest(&compress, dest);

      compress.image_width = width;
      compress.image_height = height;
      compress.input_components = 3;
      compress.in_color_space = JCS_RGB;
      jpeg_set_defaults(&compress);
      jpeg_set_quality(&compress, quality, TRUE);
      jpeg_start_compress(&compress, TRUE);
      jpeg_write_scanlines(&compress, image, height);
      jpeg_finish_compress(&compress);
      jpeg_destroy_compress(&compress);

      for (size_t i = 0; i < height; i++) {
        free(image[i]);
      }
      free(image);
    }

    }
    $cc proc saveAsJpeg {image_t im char* filename} void {
        FILE* out = fopen(filename, "w");
        jpeg(out, im.data, im.components, im.width, im.height, 100);
        fclose(out);
    }
    $cc proc loadJpeg {char* filename} image_t {
        FILE* file = fopen(filename, "rb");
        if (!file) {
            fprintf(stderr, "Error opening file: %s\n", filename);
            exit(1);
        }
        
        struct jpeg_decompress_struct cinfo;
        struct jpeg_error_mgr jerr;
        
        cinfo.err = jpeg_std_error(&jerr);
        jpeg_create_decompress(&cinfo);
        jpeg_stdio_src(&cinfo, file);
        jpeg_read_header(&cinfo, TRUE);
        jpeg_start_decompress(&cinfo);
        
        image_t ret;
        ret.width = cinfo.output_width;
        ret.height = cinfo.output_height;
        ret.components = cinfo.output_components;
        ret.bytesPerRow = ret.width * ret.components;
        ret.data = folkHeapAlloc(ret.bytesPerRow * ret.height);
        
        JSAMPROW row_pointer[1];
        while (cinfo.output_scanline < cinfo.output_height) {
            row_pointer[0] = (JSAMPLE*)ret.data + cinfo.output_scanline * ret.bytesPerRow;
            jpeg_read_scanlines(&cinfo, row_pointer, 1);
        }
        
        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);
        fclose(file);
        
        return ret;
    }
    $cc proc freeJpeg {image_t im} void {
        // TODO: Free the JPEG.
        // ckfree(im.data);
    }
    $cc compile

    namespace export *
    namespace ensemble create
}

# Callback: extract out a camera slice
When /someone/ wishes /p/ has camera slice & \
     the camera frame is /f/ & \
     /p/ has region /r/ {

    # Convert region in projector coordinates to camera
    lassign [regionToBbox $r] minX minY maxX maxY
    lassign [projectorToCamera [list $minX $minY]] px0 py0
    lassign [projectorToCamera [list $maxX $maxY]] px1 py1

    # Clamp to image bounds
    set x [expr {int(max(min($px0, $px1), 0))}]
    set y [expr {int(max(min($py0, $py1), 0))}]
    set w [expr {int(min(abs($px1 - $px0), [image width $f]))}]
    set h [expr {int(min(abs($py1 - $py0), [image height $f]))}]

    # Extract and claim the image for the page
    set subimage [image subimage $f $x $y $w $h]
    Claim $p has camera slice $subimage
}

# Auto-trigger callback for `when has camera slice` statements
When when /p/ has camera slice /slice/ /lambda/ with environment /e/ {
  Wish $p has camera slice
}

# Display a camera slice
When /someone/ wishes /p/ displays camera slice /slice/ & /p/ has region /r/ {
  set center [region centroid $r]
  # set scale [expr {$Display::WIDTH / $Camera::WIDTH}]
  # Use 1x scale instead of $scale so the projected tag doesn't redetect.
  # TODO: Mask the tag out?
    Wish display runs [list Display::image {*}$center $slice 0 1]
}

When /someone/ wishes /p/ displays image /im/ {
    # TODO: Download im if it starts with https?://
    # Load im if it ends in .jpg or .png or .jpeg
    if {[string match "*.jpg" $im] ||
        [string match "*.jpeg" $im] ||
        [string match "*.png" $im]} {
        # TODO: Support .png
        set path [expr {[file pathtype $im] eq "relative" ?
                        "$::env(HOME)/folk-images/$im" :
                        $im}]
        set im [image loadJpeg $path]
    }
    When $p has region /r/ {
        # Compute a scale for im that will fit in the region width/height
        # Draw im with scale and rotation
        set center [region centroid $r]
        Wish display runs [list Display::image {*}$center $im [region angle $r] 1]
    }
    On unmatch {
        # HACK: Leaves time for the display to finish trying to display this.
        after 5000 [list image freeJpeg $im]
    }
}
