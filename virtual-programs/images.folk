
# Example program, i.e the public API
#
# When $this has camera slice /slice/ {
#     Wish $this displays camera slice $slice
# }

if {$::isLaptop} { return }

# Generic image class for sub-image manipulations
namespace eval ::image {
    proc width {im} { dict get $im width }
    proc height {im} { dict get $im height }
    proc subimage {im x y subwidth subheight} {
	dict with im {
	    set x [expr {int($x)}]
	    set y [expr {int($y)}]
	    set subdata [expr {$data + ($y*$width + $x) * $components}]
	    dict create \
		width $subwidth \
		height $subheight \
		components $components \
		bytesPerRow $bytesPerRow \
		data [format 0x%x $subdata]
	}
    }

    set cc [c create]
    c loadlib [expr {$tcl_platform(os) eq "Darwin" ? "/opt/homebrew/lib/libjpeg.dylib" : [lindex [exec /usr/sbin/ldconfig -p | grep libjpeg] end]}]
    $cc cflags -ljpeg
    source "pi/cUtils.tcl"
    defineImageType $cc
    $cc include <stdlib.h>
    $cc include <string.h>

    $cc code {
        #undef EXTERN
        #include <jpeglib.h>
        #include <stdint.h>
        #include <unistd.h>

        void 
    jpeg(FILE* dest, uint8_t* rgb, uint32_t width, uint32_t height, int quality)
    {
      JSAMPARRAY image;
      image = calloc(height, sizeof (JSAMPROW));
      for (size_t i = 0; i < height; i++) {
        image[i] = calloc(width * 3, sizeof (JSAMPLE));
        for (size_t j = 0; j < width; j++) {
          image[i][j * 3 + 0] = rgb[(i * width + j)];
          image[i][j * 3 + 1] = rgb[(i * width + j)];
          image[i][j * 3 + 2] = rgb[(i * width + j)];
        }
      }

      struct jpeg_compress_struct compress;
      struct jpeg_error_mgr error;
      compress.err = jpeg_std_error(&error);
      jpeg_create_compress(&compress);
      jpeg_stdio_dest(&compress, dest);

      compress.image_width = width;
      compress.image_height = height;
      compress.input_components = 3;
      compress.in_color_space = JCS_RGB;
      jpeg_set_defaults(&compress);
      jpeg_set_quality(&compress, quality, TRUE);
      jpeg_start_compress(&compress, TRUE);
      jpeg_write_scanlines(&compress, image, height);
      jpeg_finish_compress(&compress);
      jpeg_destroy_compress(&compress);

      for (size_t i = 0; i < height; i++) {
        free(image[i]);
      }
      free(image);
    }

    }
    $cc proc saveAsJpeg {image_t im char* filename} void {
        FILE* out = fopen(filename, "w");
        jpeg(out, im.data, im.width, im.height, 100);
        fclose(out);
    }
    $cc compile

    namespace export *
    namespace ensemble create
}

# Callback: extract out a camera slice
When /someone/ wishes /p/ has camera slice & \
     the camera frame is /f/ & \
     /p/ has region /r/ {

    # Convert region in projector coordinates to camera
    lassign [regionToBbox $r] minX minY maxX maxY
    lassign [projectorToCamera [list $minX $minY]] px0 py0
    lassign [projectorToCamera [list $maxX $maxY]] px1 py1

    # Clamp to image bounds
    set x [expr {int(max(min($px0, $px1), 0))}]
    set y [expr {int(max(min($py0, $py1), 0))}]
    set w [expr {int(min(abs($px1 - $px0), [image width $f]))}]
    set h [expr {int(min(abs($py1 - $py0), [image height $f]))}]

    # Extract and claim the image for the page
    set subimage [image subimage $f $x $y $w $h]
    Claim $p has camera slice $subimage
}

# Auto-trigger callback for `when has camera slice` statements
When when /p/ has camera slice /slice/ /lambda/ with environment /e/ {
  Wish $p has camera slice
}

# Display a camera slice
When /someone/ wishes /p/ displays camera slice /slice/ & /p/ has region /r/ {
  set origin [lindex $r 0 0]
  # set scale [expr {$Display::WIDTH / $Camera::WIDTH}]
  # Use 1x scale instead of $scale so the projected tag doesn't redetect.
  # TODO: Mask the tag out?
  Wish display runs [list Display::image {*}$origin $slice 1]
}
