# Images

Wish $this has filename "images.folk"

namespace eval ::image {
    proc width {im} { dict get $im width }
    proc height {im} { dict get $im height }
    proc subimage {im x y subwidth subheight} {
	dict with im {
	    set x [expr {int($x)}]
	    set y [expr {int($y)}]
	    set subdata [expr {$data + ($y*$width + $x) * $components}]
	    dict create \
		width $subwidth \
		height $subheight \
		components $components \
		bytesPerRow $bytesPerRow \
		data [format 0x%x $subdata]
	}
    }
    namespace export *
    namespace ensemble create
}


When /someone/ wishes /p/ has camera image {
    When the camera frame is /f/ {
	When $p has region /r/ {
	    # Convert region in projector coordinates to camera
	    lassign [regionToBbox $r] minX minY maxX maxY
	    lassign [projectorToCamera [list $minX $minY]] px0 py0
	    lassign [projectorToCamera [list $maxX $maxY]] px1 py1

	    # Clamp to image bounds
	    set x [expr {int(max($px0, 0))}]
	    set y [expr {int(max($py0, 0))}]
	    set w [expr {int(min($px1 - $px0, [image width $f]))}]
	    set h [expr {int(min($py1 - $py0, [image height $f]))}]

	    # Extract and claim the image for the page
	    set subimage [image subimage $f $x $y $w $h]
	    Claim $p has camera slice $subimage for region $r
	}
    }
}

Wish $this is outlined thick palegoldenrod


Wish $this has camera image
When $this has camera slice /im/ for region /r/ {
  set origin [lindex $r 0 0]

  lassign [regionToBbox $r] minX minY maxX maxY
  set regionWidth [expr {$maxX - $minX}]
  set scale [expr {$Display::WIDTH / $regionWidth}] 

  Wish display runs [list Display::image {*}$origin $im $scale]
}
