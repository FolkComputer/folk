namespace eval ::vec2 {
    proc add {a b} {
        list [+ [lindex $a 0] [lindex $b 0]] [+ [lindex $a 1] [lindex $b 1]]
    }
    proc sub {a b} {
        list [- [lindex $a 0] [lindex $b 0]] [- [lindex $a 1] [lindex $b 1]]        
    }
    proc scale {s a} {
        list [* $s [lindex $a 0]] [* $s [lindex $a 1]]
    }
    proc distance {a b} {
        lassign $a ax ay
        lassign $b bx by
        expr {sqrt(pow($ax-$bx, 2) + pow($ay-$by, 2))}
    }
    proc normalize {a} {
        set l2 [vec2 distance $a [list 0 0]]
        vec2 scale [/ 1 $l2] $a
    }
    proc dot {a b} {
        expr {[lindex $a 0]*[lindex $b 0] + [lindex $a 1]*[lindex $b 1]}
    }
    proc distanceToLineSegment {a v w} {
        set l2 [vec2 distance $v $w]
        if {$l2 == 0.0} {
            return [distance $a $v]
        }
        set t [max 0 [min 1 [/ [dot [sub $a $v] [sub $w $v]] $l2]]]
        set proj [add $v [scale $t [sub $w $v]]]
        vec2 distance $a $proj
    }
    namespace export *
    namespace ensemble create
}

namespace eval ::region {
    proc vertices {r} { lindex $r 0 }
    proc edges {r} { lindex $r 1 }
    # Angle the region is rotated above the horizontal, in radians:
    proc angle {r} {
        expr {[llength $r] >= 3 ? [lindex $r 2] : 0}
    }

    proc mapVertices {varname r body} {
        lreplace $r 0 0 [uplevel [list lmap $varname [vertices $r] $body]]
    }

    proc edgeToLineSegment {r e} {
        list [lindex [vertices $r] [lindex $e 0]] [lindex [vertices $r] [lindex $e 1]]
    }
    proc distance {r1 r2} {
	puts $r2
        set minDist 1e9
        foreach v1 [vertices $r1] e2 [edges $r2] {
            set dist [vec2 distanceToLineSegment $v1 {*}[edgeToLineSegment $r2 $e2]]
            if {$dist < $minDist} { set minDist $dist }
        }
        set minDist
    }

    proc contains {r1 p} {
        lassign $r1 vertices edges
        lassign $vertices a b c d

        set ab [vec2 sub $b $a]
        set ap [vec2 sub $p $a]
        set bc [vec2 sub $c $b]
        set bp [vec2 sub $p $b]
        set dot_abap [vec2 dot $ab $ap]
        set dot_bcbp [vec2 dot $bc $bp]

        expr {0 <= $dot_abap && $dot_abap <= [vec2 dot $ab $ab] && \
                0 <= $dot_bcbp && $dot_bcbp <= [vec2 dot $bc $bc]}
    }
    proc intersects {r1 r2} {
        # FIXME: implement
    }

   proc centroid {r1} {
        # This only works for rectangular regions
        lassign $r1 vertices edges
        lassign $vertices a b c d

        set vecsum [vec2 add [vec2 add [vec2 add $a $b] $c] $d]
        vec2 scale 0.25 $vecsum
    }

    # Utilities that transform regions while preserving center
    proc clip {r args} {
        foreach {property value} $args {
            if {$property eq "width"} {
                
            } elseif {$property eq "height"} {
                
            } else {
                error "region clip: Invalid property $property"
            }
        }
    }
    proc move {r args} {
        set angle [angle $r]
        # FIXME: This one should work on any region -- just map over vertices.
        foreach {direction distance} $args {
            if {![regexp {([0-9]+)px} $distance -> distance]} {
                error "region move: Invalid distance $distance"
            }
            set dx [if {$direction eq "left"} {- $distance} \
                    elseif {$direction eq "right"} {+ $distance} \
                    else {+ 0}]
            set dy [if {$direction eq "up"} {- $distance} \
                    elseif {$direction eq "down"} {+ $distance} \
                    else {+ 0}]
            if {$dx == 0 && $dy == 0} {
                error "region move: Invalid direction $direction"
            }

            # Translate dx and dy into polar coordinates.
            set theta [atan2 $dy $dx]
            set mag [hypot $dy $dx]

            # Rotate dx and dy into the global coordinate space.
            set dv [list [expr {$mag*cos($theta)}] [expr {$mag*sin($theta)}]]

            set r [mapVertices v $r {vec2 add $v $dv}]
        }
        set r
    }

    namespace export *
    namespace ensemble create
}

When when the distance between /p1/ and /p2/ is /distanceVar/ /body/ with environment /e/ & /p1/ has region /r1/ & /p2/ has region /r2/ {
    Claim the distance between $p1 and $p2 is [region distance $r1 $r2]
}
