# TODO: Make this not-hard-coded
#       In fact, this shouldn't be "editor-1" at all but
#       probably should be the MAC address or some Bluetooth
#       thread ID?
set id "editor-1"

When /page/ is editor /n/ & /page/ has region /r/ {
    Wish $page is outlined gray
    Claim $id has region [region move $r up 450px]
}

proc updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
    lset newCursor 0 [expr {max(0, [dict get $updates x] + [lindex $oldCursor 0])}]
  }
  if {[dict exists $updates y]} {
    lset newCursor 1 [expr {max(0, [dict get $updates y] + [lindex $oldCursor 1])}]
  }
  return $newCursor
}

# NOTE: Should this go into a common-functions file?
proc x {vector} { lindex $vector 0 }
proc y {vector} { lindex $vector 1 }

# TODO: Scope to "When the editor is out" or something
Commit cursor { Claim the cursor is [list 0 0]}

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [expr {$x - 1}]
  set line [lindex $lines $y]
  set character [string cat [string index $line $x] $newCharacter]
  set line [string replace $line $x $x $character]
  lset lines $y $line
  return [join $lines "\n"]
}

proc swapCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set line [string replace $line $x $x $newCharacter]
  lset lines $y $line
  return [join $lines "\n"]
}

proc deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lset lines $y ""
    # TODO:
    # - move cursor to end of previous line
    lreplace lines $y $y
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]
    lset lines $y $line
  }
  return [join $lines "\n"]
}

proc insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
   if {$count % 2 == 0} {
     return [swapCharacter $code "_" $cursor]
   } else {
     return $code    
   }
}

proc newRegion {program x y w h} {
  set vertices [list [list [expr {$x+$w}] $y] \
              [list $x $y] \
              [list $x [expr {$y+$h}]] \
              [list [expr {$x+$w}] [expr {$y+$h}]]]
  set edges [list [list 0 1] [list 1 2] [list 2 3] [list 3 0]]
  Claim $program has region [region create $vertices $edges]
}

set baseCode "Claim\nWish \$this is outlined green"
Commit code { Claim $id has program code $baseCode }

proc drawText {text cursor count region} {
  set lineNumber 1
  set showCursor [expr {$count % 2 == 0}]
  # TODO: Make the font size change relative to `Wish $this is small|medium|large editor 1` (by default should use small, e.g. fontSize 1)
  Display::text {*}[region centroid $region] 1 $text [region angle $region] NeomatrixCode
}

#######################################
# In order to construct a cursor that's relative to the virtual keyboard you must
# know three things:
#   1. The center of the virtual region
#   2. The angle of the virtual region
#   3. The position of the cursor relative to the virtual region (this is rather involved because it requires calcualting from the center and then taking cursor units from that point)
#######################################
proc rotateStroke {points center angle} {
  lmap v $points {
    set v [vec2 sub $v $center]
    set v [vec2 rotate $v $angle]
    set v [vec2 add $v $center]
    set v
  }
}

proc getLineShift {lines} {
  set longestLineLength 0
  foreach line [split $lines "\n"] {
    set lineLength [string length $line]
    if {$lineLength > $longestLineLength} {
      set longestLineLength $lineLength
    }
  }
  return [list [expr {$longestLineLength / 2}] [expr {[llength $lines] / 2}]]
}

proc debug {position color} {
  # Display::circle {*}$position 3 2 $color false
  Display::circle {*}$position 8 2 $color false
}

proc drawCursor {cursorPosition lineShift region} {
  puts "$lineShift | $cursorPosition"
  set anchor [region centroid $region]
  set angle [region angle $region]

  # 9 is the width of a character, 20 is the height of a character
  # These values could theortically be set from drawText in Display.tcl
  set cursorHeight 20
  set cursorWidth 9
  set shiftMultiplier [list 10 10]

  set cursorScale [list 20 20] ;# OLD
  # set cursorScale [list $cursorHeight $cursorWidth]

  # Calculate the shift for the anchor point
  set lineShiftHalf [list [lindex $lineShift 0] 0]
  set multipliedShift [vec2::mult $shiftMultiplier $lineShift]
  # This adjusted shift is seemingly wrong ....
  set adjustedShift [sub $multipliedShift $lineShiftHalf]
  # set adjustedShift $multipliedShift
  set shiftedAnchor [sub $anchor $adjustedShift]
  # add (x * width) to the shiftedAnchor position from the beginning of the line ...
  # Calculate the final cursor position
  set scaledCursor [vec2::mult $cursorScale $cursorPosition]
  puts "lineShiftHalf | multipliedShift | adjustedShift | shiftedAnchor | scaledCursor"
  puts "$lineShiftHalf | $multipliedShift | $adjustedShift | $shiftedAnchor | $scaledCursor"
  debug $scaledCursor blue
  # Something is going wrong here, I think
  set finalCursor [add $shiftedAnchor $scaledCursor]
  debug $finalCursor gold
  # Rotate and display the cursor
  set rotatedFinalCursor [lindex [rotateStroke [list $finalCursor] $anchor $angle] 0]
  # This is where the cursor point is relative to.
  debug $rotatedFinalCursor white
  # cursor, green
  Display::stroke [rotateStroke \
      [list $finalCursor \
      [add $finalCursor [list 0 $cursorHeight]] \
    ] \
    $anchor $angle] 2 green

  # cursor box
  Display::stroke [rotateStroke \
      [list $finalCursor \
      [add $finalCursor [list $cursorWidth 0]] \
      [add $finalCursor [list [* -3 $cursorWidth] $cursorHeight]] \
      [add $finalCursor [list 0 $cursorHeight]] \
    ] \
    $anchor $angle] 2 green
}

When $id has program code /code/ & the clock time is /t/ & the cursor is /cursor/ & $id has region /r/ {
  set intTime [expr {int($t * 10)}]
  drawText [insertCursor $code $cursor $intTime] $cursor $intTime $r
  set lineShift [getLineShift $code]
  drawCursor $cursor $lineShift $r
}

proc getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [lindex $cursor 1]]
  string length $currentLine
}

Every time keyboard claims key /currentCharacter/ is down with modifiers /modifier/ & the cursor is /cursor/ & $id has program code /code/ {
  Commit cursor {
    switch $currentCharacter {
      UP {
        set updatedCursor [updateCursor $cursor {y -1}]
        set currentLineLength  [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      DOWN {
        set updatedCursor [updateCursor $cursor {y 1}]
        set currentLineLength [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      RIGHT {
        set currentLineLength [getCurrentLineLength $code $cursor]
        # TODO: Check if the cursor is at the end of the line, if so cap it
        Claim the cursor is [updateCursor $cursor {x 1}]
      }
      LEFT { Claim the cursor is [updateCursor $cursor {x -1}] }
      BACKSPACE {
        # if cursor is at the beginning of the line, delete the newline
        if {[x $cursor] == 0} {
          set newCursor [updateCursor $cursor {y -1}]
          set previousLineLength  [getCurrentLineLength $code $newCursor]
          set newCursor [list $previousLineLength [y $newCursor]]
          Claim the cursor is $newCursor
          # Delete the old line???
        } else {
          Claim the cursor is [updateCursor $cursor {x -1}]
        }
        Commit code { Claim $id has program code [deleteCharacter $code $cursor] }
      }
      SPACE {
        Claim the cursor is [updateCursor $cursor {x 1}]
        Commit code { Claim $id has program code [insertCharacter $code " " $cursor] }
      }
      ENTER {
        # GOAL: Move cursor to beginning of next line
        set updatedCursor [updateCursor $cursor {y 1}]
        Claim the cursor is [list 0 [lindex $updatedCursor 1]]
        Commit code { Claim $id has program code [insertNewline $code $cursor] }
      }
      LEFTSHIFT -
      RIGHTSHIFT -
      LEFTCTRL -
      RIGHTCTRL {
        Claim the cursor is $cursor
      }
      default {
        Claim the cursor is [updateCursor $cursor {x 1}]
        if {$modifier == "ctrl" & $currentCharacter == "p"} {
          Wish to print $code with job id [expr {rand()}]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "r"} {
          Commit code { Claim $id has program code $baseCode }
          Claim the cursor is [list 0 0]
          return
        }
        Commit code { Claim $id has program code [insertCharacter $code $currentCharacter $cursor] }
      }
    }
  }
}

Claim $this has demo {
  # Tape this program underneath the main keyboard of your system to try it out
  Claim $this is editor editor-1
}