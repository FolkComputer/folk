set baseCode "Wish \$this is outlined green"

# This makes all keyboards into editors automatically, so a keyboard
# doesn't need an extra printed claim to be an editor. May choose to
# change later, or exclude keyboards that opt out.
When /page/ is a keyboard with /...opts/ {
    dict set opts locale [dict getdef $opts locale us]
    if {[dict exists $opts path]} {
        Wish -keep 100ms $page is an editor with {*}$opts
    }
}

# HACK: This is so that the wish can cycle in and out but the identity
# of the inner claim is retained, so the editor doesn't reboot.
When /someone/ wishes /page/ is an editor with /...opts/ {
    Claim $page is an editor with {*}$opts
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  Wish tag $page is stabilized

  set id [list editing $page $kbPath]

  set writableTextureId [list $id canvas]
  Wish -keep 100ms the GPU creates canvas $writableTextureId with width 1024 height 1024
  When the GPU has created canvas $writableTextureId with /...opts/ {
      Claim $id has canvas $writableTextureId with {*}$opts
  }
  When $page has resolved geometry /geom/ {
      Claim $id has resolved geometry $geom
  }
  When $page has canvas projection /proj/ {
      Claim $id has canvas projection $proj
  }
  When the quad library is /quadLib/ & $page has quad /q/ {
      Claim $id has quad [$quadLib move $q up 210%]
  }

  if {[llength [Query! /someone/ claims $id has program code /c/]] == 0} {
      Hold! -key "programCode$kbPath" \
          Claim $id has program code $baseCode
  }
  if {[llength [Query! /someone/ claims $id has editor code /c/]] == 0} {
      Hold! -save -key "code$kbPath" {
          Claim $id has editor code $baseCode
      }
  }

  if {[llength [Query! /someone/ claims $id has start time /startTime/]] == 0} {
      set t [expr {[clock milliseconds] / 1000.0}]
      Hold! -key [list $id start-time] \
          Claim $id has start time $t
      Hold! -key [list $id most-recent-time] \
          Claim $id has most recent time $t
  }
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  On unmatch {
      Hold! -key [list $id start-time] {}
  }
}

fn x {vector} { lindex $vector 0 }
fn y {vector} { lindex $vector 1 }

fn updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
      lset newCursor 0 [::math::max 0 $([dict get $updates x] + [x $oldCursor])]
  }
  if {[dict exists $updates y]} {
      lset newCursor 1 [::math::max 0 $([dict get $updates y] + [y $oldCursor])]
  }
  return $newCursor
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  if {[llength [Query! /someone/ claims the $kbPath cursor is /anything/]] == 0} {
    Hold! -key "cursor$kbPath" {
      Claim the $kbPath cursor is [list 0 0]
    }
  }
}

fn insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [- $x 1]
  set line [lindex $lines $y]

  if {$x < 0} {
    if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
    lset lines $y [string cat $newCharacter $line]
    return [join $lines "\n"]
  } else {
    set character [string cat [string index $line $x] $newCharacter]
    set line [string replace $line $x $x $character]
    lset lines $y $line
    return [join $lines "\n"]
  }
}

fn deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lset lines $y ""
    set newLines {}
    for {set i 0} {$i < [llength $lines]} {incr i} {
      if {$i != $y} {
        lappend newLines [lindex $lines $i]
      }
    }
    set lines $newLines
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]

    if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
    lset lines $y $line
  }
  return [join $lines "\n"]
}

fn deleteToBeginning {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set newLine [string range $line $x end]
  lset lines $y $newLine
  return [join $lines "\n"]
}

fn insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]

  if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

fn getLineLength {code cursor} {
  set lines [split $code "\n"]
  set line [lindex $lines [lindex $cursor 1]]
  set ll [string length $line]
  return $ll
}

fn lineNumberView {ystart linecount} {
  set yend [expr {$ystart + $linecount}]
  set numbers [list]
  for {set i [expr {$ystart + 1}]} {$i <= $yend} {incr i} {
    lappend numbers $i
  }
  join $numbers "\n"
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

    # Construct the editor window $id':
    set writableTextureId [list $id' canvas]
    Wish -keep 100ms the GPU creates canvas $writableTextureId with width 1024 height 1024
    When the GPU has created canvas $writableTextureId with /...opts/ {
        Claim $id' has canvas $writableTextureId with {*}$opts
    }
    When $page has resolved geometry /geom/ {
        Claim $id' has resolved geometry $geom
    }
    When $page has canvas projection /proj/ {
        Claim $id' has canvas projection $proj
    }

    When the quad library is /quadLib/ & $id has quad /q/ {
        Claim $id' has quad [$quadLib move $q down 105%]
    }

    set scale 0.0075
    Wish $id' is outlined white

    When $id has program code /code/ & $id has editor code /editorCode/ {
        set p [list 0.02 0.01]
        Wish to draw text onto $id' with \
            position $p text $editorCode \
            scale $scale anchor topleft font NeomatrixCode

        # Draw line numbers
        set lp [list 0.005 0.01]
        set linecount [llength [split $editorCode "\n"]]
        set linenumbers [lineNumberView 0 $linecount]
        Wish to draw text onto $id' with \
            position $lp text $linenumbers \
            scale $scale anchor topleft font NeomatrixCode

        When the $kbPath cursor is /cursor/ {
            set em [expr {$scale * 1}]
            # From NeomatrixCode.csv
            set advance [expr {0.5859375 * $scale}]

            # Draw cursor
            set curs [vec2 scale $cursor $advance $em]

            set x1 [vec2 add $p $curs]
            set x2 [vec2 add $x1 [list 0 [expr {$em * 1.3}]]]

            set s [expr {$scale / 6}]
            Wish to draw a circle onto $id' with center $x1 radius $s thickness 0 color green filled true
            Wish to draw a line onto $id' with points [list $x1 $x2] width $s color green
        }
    }
}

fn getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [y $cursor]]
  string length $currentLine
}

When /id/ is printing /code/ & /id/ has resolved geometry /geom/ {
  Wish to draw text onto $id' with text "Printing..." \
      x [- [dict get $geom width] 0.01] y 0.01 \
      anchor bottomright \
      radians 1.55 font NeomatrixCode color green
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

  # Desired behavior: query all the other stuff every time you hit a
  # key, then destroy the when (don't want _any_ reaction after the
  # original firing, and don't want to keep the match around).
  Subscribe: keyboard $kbPath claims key /key/ is /keyState/ with /...options/ {
    ForEach! the $kbPath cursor is /cursor/ &\
             $id has program code /code/ &\
             $id has editor code /editorCode/ &\
             $id has start time /startTime/ &\
             $id has most recent time /mostRecentTime/ {
      set timestamp [dict get $options timestamp]
      if {$timestamp < $mostRecentTime} {
          puts stderr "editor: Warning: Dropping '$key' ($keyState)"
          return
      }

      Hold! -key [list $id most-recent-time] \
          Claim $id has most recent time $timestamp

      if {$timestamp > $startTime && ($keyState == "down" || $keyState == "repeat")} {
        if {[dict exists $options printable]} {
          Hold! -key "cursor$kbPath" {
            Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
            Hold! -save -key "code$kbPath" \
              Claim $id has editor code [insertCharacter $editorCode [dict get $options printable] $cursor]
          }
        } else {
          Hold! -key "cursor$kbPath" {
            switch $key {
              Up {
                set updatedCursor [updateCursor $cursor {y -1}]
                set currentLineLength  [getCurrentLineLength $editorCode $updatedCursor]
                if {[x $updatedCursor] > $currentLineLength} {
                  Claim the $kbPath cursor is [list $currentLineLength  [y $updatedCursor]]
                } else {
                  Claim the $kbPath cursor is $updatedCursor
                }
              }
              Down {
                set linecount [llength [split $editorCode "\n"]]
                set updatedCursor [updateCursor $cursor {y 1}]
                set currentLineLength [getCurrentLineLength $editorCode $updatedCursor]

                if {[y $updatedCursor] == $linecount} {
                  Claim the $kbPath cursor is $cursor
                  return
                } elseif {[x $updatedCursor] > $currentLineLength} {
                  Claim the $kbPath cursor is [list $currentLineLength  [y $updatedCursor]]
                } else {
                  Claim the $kbPath cursor is $updatedCursor
                }
              }
              Right {
                set currentLineLength [getCurrentLineLength $editorCode $cursor]
                if {[x $cursor] == $currentLineLength} {
                  if {[y $cursor] == [expr {[llength [split $editorCode "\n"]] - 1}]} {
                    Claim the $kbPath cursor is $cursor
                  } else {
                    set newCursor [updateCursor $cursor {y 1}]
                    Claim the $kbPath cursor is [list 0 [y $newCursor]]
                  }
                } else {
                  Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
                }
              }
              Left {
                if {[x $cursor] == 0 && [y $cursor] == 0} {
                  Claim the $kbPath cursor is $cursor
                } elseif {[x $cursor] == 0} {
                  set newCursor [updateCursor $cursor {y -1}]
                  set previousLineLength  [getCurrentLineLength $editorCode $newCursor]
                  set newCursor [list $previousLineLength [y $newCursor]]
                  Claim the $kbPath cursor is $newCursor
                } else {
                  Claim the $kbPath cursor is [updateCursor $cursor {x -1}]
                }
              }
              Delete {
                # if cursor is at the beginning of the line, delete the newline
                if {[x $cursor] == 0 && [y $cursor] > 0} {
                  set newCursor [updateCursor $cursor {y -1}]
                  set previousLineLength  [getCurrentLineLength $editorCode $newCursor]
                  set newCursor [list $previousLineLength [y $newCursor]]
                  Claim the $kbPath cursor is $newCursor
                } else {
                  Claim the $kbPath cursor is [updateCursor $cursor {x -1}]
                }
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code [deleteCharacter $editorCode $cursor]
              }
              Remove {
                Claim the $kbPath cursor is $cursor
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code [deleteCharacter $editorCode [updateCursor $cursor {x 1}]]
              }
              Return {
                set updatedCursor [updateCursor $cursor {y 1}]
                Claim the $kbPath cursor is [list 0 [y $updatedCursor]]
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code [insertNewline $editorCode $cursor]
              }
              Control_p {
                # TODO: Implement DELETE, operates like BACKSPACE, but in the opposite direction
                # TODO: MUTE VOLUMEUP VOLUMEDOWN
                #       implement sound.folk that allows a system-wide
                #       volume setting to be adjusted.
                #       Perhaps `Wish $system volume is 0.5` or something

                Notify: print code $code

                Hold! -key "print$kbPath" { Claim $id is printing $code }
                sleep 2
                Hold! -key "print$kbPath" {}

                Claim the $kbPath cursor is $cursor
              }
              Control_r {
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code $baseCode
                Claim the $kbPath cursor is [list 0 0]
              }
              Control_s {
                Hold! -key "programCode$kbPath" \
                  Claim $id has program code $editorCode
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code $editorCode
                Claim the $kbPath cursor is $cursor
              }
              Control_a {
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code $editorCode
                lassign $cursor x y
                Claim the $kbPath cursor is [list 0 $y]
              }
              Control_e {
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code $editorCode
                lassign $cursor x y
                Claim the $kbPath cursor is [list [getLineLength $editorCode $cursor] $y]
              }
              Control_u {
                # delete from cursor back to 0 and move cursor to 0
                Hold! -save -key "code$kbPath" \
                  Claim $id has editor code [deleteToBeginning $editorCode $cursor]
                lassign $cursor x y
                Claim the $kbPath cursor is [list 0 $y]
              }
              default {
                Claim the $kbPath cursor is $cursor
              }
            }
          }
        }
      }
    }
  }
}

Claim $this has demo {
  # Find your keyboard path with the script in this guide: https://folk.computer/guides/keyboard
  Claim $this is a keyboard with path /dev/input/by-path/pci-0000:02:00.0-usb-0:2:1.2-event-mouse locale us
  Claim $this is an editor
}
