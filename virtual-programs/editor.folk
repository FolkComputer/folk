Wish $this has filename "editor.folk"

Wish $this has top dock

proc x {v} { lindex $v 0 }
proc y {v} { lindex $v 1 }
proc subtractBy50 {coords} {
  list [lindex $coords 0] [expr {[lindex $coords 1] - 50}]
}

When /thing/ wishes /page/ has /position/ dock & /page/ has region /r/ & /p2/ has region /r2/ {
     if {$page eq $p2} { return }
     lassign [lindex $r 0] a b c d
     lassign $a x y
     Display::stroke [list $a $b [subtractBy50 $b] [subtractBy50 $a] $a] 8 green
     set bMinX [expr {$x}]
     set bMinY [expr {$y - 50}]
     set bMaxX [lindex $b 0]
     set bMaxY [lindex $b 1]
     lassign [regionToBbox $r2] b2MinX b2MinY b2MaxX b2MaxY
     
     set hasIntersections [rectanglesOverlap [list $bMinX $bMinY] \
                 [list $bMaxX $bMaxY]\
                 [list $b2MinX $b2MinY]\
                 [list $b2MaxX $b2MaxY]\
     false ]
     set notVirtual [expr {![string match "virtual-programs*" $p2] & ![string match "web-program*" $p2]}]
     if {$hasIntersections & $notVirtual} {
       Claim $p2 has docked program $p2
     }
}

proc blinkingCursor {count} {
  expr {$count % 16 == 0 ? "_" : " "}
}

Wish $this is outlined red

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  # Get the current line
  set line [lindex $lines $y]
  # Replace the character at position x with the new character
  set character [string cat [string index $line $x] $newCharacter]
  set line [string replace $line $x $x $character]
  # Put the modified line back in the array
  lset lines $y $line

  # Return the modified lines
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
  return [insertCharacter $code [blinkingCursor $count] $cursor]
}

When /page/ has docked program /d/ & /d/ has program code /code/ {
  Wish $this is outlined blue
}

When /page/ has docked program /d/ & /d/ has program code /code/ & /node/ has step count /count/ & $this has a cursor /cursor/ {
  Wish $page is outlined white
  Wish $this is labelled [insertCursor $code $cursor $count]
}

Commit cursor { Claim $this has a cursor [list 0 0]}

proc isCommandWithChar { currentKey lastKey matchChar } {
  set isS [expr {$currentKey == $matchChar}]
  set isMeta [string match "Meta*" $lastKey]
  expr {$isS && $isMeta}
}

proc isControlWithChar {currentKey lastKey matchChar} {
  set isS [expr {$currentKey == $matchChar}]
  set isMeta [string match "leftctrl" $lastKey]
  expr {$isS && $isMeta}
}

Every time the keyboard character log is /k/ & $this has a cursor /c/ {
  Commit cursor {
    set currentCharacter [lindex $k end]
    switch $currentCharacter {
      up { Claim $this has a cursor [list [x $c] [expr {[y $c] - 1}]] }
      down { Claim $this has a cursor [list [x $c] [expr {[y $c] + 1}]] }
      right { Claim $this has a cursor [list [expr {[x $c] + 1}] [y $c]] }
      left { Claim $this has a cursor [list [expr {[x $c] - 1}] [y $c]] }
      default {
        When /page/ has docked program /d/ & /d/ has program code /code/ {
          Claim $this has patched program code [insertCharacter $code $currentCharacter $c]
        }
        Claim $this has a cursor $c
      }
    }
  }
}

When $this has a cursor /c/ {
  Wish $this is labelled "cursor: ---- $c"
}

Wish $this has halo message "hi"

When $this has patched program code /code/ {
  Wish $this is labelled "\n====\n $code \n===\n"
}