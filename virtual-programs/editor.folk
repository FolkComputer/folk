Wish $this has filename "editor.folk"

Wish $this has top dock

proc x {v} { lindex $v 0 }
proc y {v} { lindex $v 1 }
proc subtractBy50 {coords} {
  list [lindex $coords 0] [expr {[lindex $coords 1] - 50}]
}

When /thing/ wishes /page/ has /position/ dock & /page/ has region /r/ & /p2/ has region /r2/ {
     if {$page eq $p2} { return }
     lassign [lindex $r 0] a b c d
     lassign $a x y
     Display::stroke [list $a $b [subtractBy50 $b] [subtractBy50 $a] $a] 8 green
     set bMinX [expr {$x}]
     set bMinY [expr {$y - 50}]
     set bMaxX [lindex $b 0]
     set bMaxY [lindex $b 1]
     lassign [regionToBbox $r2] b2MinX b2MinY b2MaxX b2MaxY
     
     set hasIntersections [rectanglesOverlap [list $bMinX $bMinY] \
                 [list $bMaxX $bMaxY]\
                 [list $b2MinX $b2MinY]\
                 [list $b2MaxX $b2MaxY]\
     false ]
     set notVirtual [expr {![string match "virtual-programs*" $p2] & ![string match "web-program*" $p2]}]
     if {$hasIntersections & $notVirtual} {
       Claim $p2 has docked program $p2
     }
}

proc blinkingCursor {count} {
  expr {$count % 16 == 0 ? "_" : " "}
}

Wish $this is outlined red

proc insertCursor {code cursor count} {
  set lines [split $code "\n"]
  lassign $cursor x y
  # Get the current line
  set line [lindex $lines $y]
  # Replace the character at position x with the new character
  set character [string cat [string index $line $x] [blinkingCursor $count]]
  set line [string replace $line $x $x $character]
  # Put the modified line back in the array
  lset lines $y $line

  # Return the modified lines
  return [join $lines "\n"]
}

When /page/ has docked program /d/ & /d/ has program code /code/ {
  Wish $this is outlined blue
}

When $this has a cursor /cursor/ {
  Wish $this is labelled "===== 4 (cursor))"
}
When /node/ has step count /count/ {
  Wish $this is labelled "===== 3 (node)"
}

When /page/ has docked program /d/ & /d/ has program code /code/ {
  Wish $this is labelled "===== 1 (dock)"
}

When /d/ has program code /code/ {
  Wish $this is labelled "===== 2 (code)"
}

When /page/ has docked program /d/ & /d/ has program code /code/ & /node/ has step count /count/ & $this has a cursor /cursor/ {
  Wish $page is outlined white
  Wish $this is labelled [insertCursor $code $cursor $count]
}

Commit cursor { Claim $this has a cursor [list 0 0]}
Commit lastKey { Claim $this has a program [list] }

proc isCommandWithChar { currentKey lastKey matchChar } {
  set isS [expr {$currentKey == $matchChar}]
  set isMeta [string match "Meta*" $lastKey]
  expr {$isS && $isMeta}
}

proc isControlWithChar {currentKey lastKey matchChar} {
  set isS [expr {$currentKey == $matchChar}]
  set isMeta [string match "leftctrl" $lastKey]
  expr {$isS && $isMeta}
}

Every time the keyboard character log is /k/ & $this has a program /p/ & $this has a cursor /c/ {
  set currentKey [lindex $p end]
  set lastKey [lindex $p end-1]
  Commit lastKey {
    Claim $this has a last key [lindex $p end]
    Claim $this has a program [list {*}$p [lindex $k end]]
    set CMDRPressed [isCommandWithChar $currentKey $lastKey "r"]
    set CMDSPressed [isCommandWithChar $currentKey $lastKey "s"]
    set CTRLSPressed [isControlWithChar $currentKey $lastKey "s"]
    set CTRLRPressed [isControlWithChar $currentKey $lastKey "r"]
    # Wish $this is labelled "$currentKey | $lastKey"
  }
  Commit cursor {
switch $currentKey {
       up { Claim $this has a cursor [list [x $c] [expr {[y $c] - 1}]] }
       down { Claim $this has a cursor [list [x $c] [expr {[y $c] + 1}]] }
       right { Claim $this has a cursor [list [expr {[x $c] + 1}] [y $c]] }
       left { Claim $this has a cursor [list [expr {[x $c] - 1}] [y $c]] }
       default {
          # enter text into the program variable
       }
    }
  }
}

When $this has a cursor /c/ {
  Wish $this is labelled "cursor: ---- $c"
}

Wish $this is outlined blue