# TODO: Make this not-hard-coded
#       In fact, this shouldn't be "editor-1" at all but
#       probably should be the MAC address or some Bluetooth
#       thread ID?
set id "editor-1"

#####
# To match to this I have another program with:
#   Claim $this is editor editor-1
#####
When /page/ is editor /n/ & /page/ has region /r/ {
    Wish $page is outlined gray
    Claim $id has region [region move $r up 450px]
}

proc checkForModifier {key} {
  set r ""
  switch $key {
    LEFTSHIFT { set r "shift" }
    RIGHTSHIFT { set r "shift" }
    LEFTCTRL { set r "control" }
    RIGHTCTRL { set r "control" }
  }
  return $r
}

proc updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
    lset newCursor 0 [expr {max(0, [dict get $updates x] + [lindex $oldCursor 0])}]
  }
  if {[dict exists $updates y]} {
    lset newCursor 1 [expr {max(0, [dict get $updates y] + [lindex $oldCursor 1])}]
  }
  return $newCursor
}

# NOTE: Should this go into a common-functions file?
proc x {vector} { lindex $vector 0 }
proc y {vector} { lindex $vector 1 }

# TODO: Scope to "When the editor is out" or something
Commit cursor { Claim the cursor is [list 0 0]}

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [expr {$x - 1}]
  set line [lindex $lines $y]
  set character [string cat [string index $line $x] $newCharacter]
  set line [string replace $line $x $x $character]
  lset lines $y $line
  return [join $lines "\n"]
}

proc swapCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set line [string replace $line $x $x $newCharacter]
  lset lines $y $line
  return [join $lines "\n"]
}

proc deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lreplace lines $y $y
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]
    lset lines $y $line
  }
  return [join $lines "\n"]
}

proc insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
   if {$count % 2 == 0} {
     return [swapCharacter $code " " $cursor]
   } else {
     return $code    
   }
}

proc newRegion {program x y w h} {
  set vertices [list [list [expr {$x+$w}] $y] \
              [list $x $y] \
              [list $x [expr {$y+$h}]] \
              [list [expr {$x+$w}] [expr {$y+$h}]]]
  set edges [list [list 0 1] [list 1 2] [list 2 3] [list 3 0]]
  Claim $program has region [region create $vertices $edges]
}

# NOTE: This is convenient for me debugging (gets triggered with Ctrl + R)
#       but should probably be "Claim this has halo message editor" or something
#       not as intrusive as outlining to start? Just a thought.
# set baseCode "Wish \$this is outlined green\nClaim first name is Andres"
set baseCode "Claim\nWish \$this is outlined gold\nClaim this is a very looooooong line\n# Comment"
Commit code { Claim $id has program code $baseCode }

proc drawText {text cursor count region} {
  set lineNumber 1
  set showCursor [expr {$count % 2 == 0}]
  set corner [region topleft $region]
  set angle [region angle $region]
  lassign $corner cornerX cornerY
  foreach line [split $text "\n"] {
     set lineCornerY [- $cornerY [* $lineNumber 50]]
    set lineCornerX [- $cornerX [* [string length $line] 9]]
     Display::text $lineCornerX $lineCornerY 2 $line $angle
     set lineNumber [+ $lineNumber 1]
  }
}

proc drawCursor {cursorPosition region} {
  # calculate relative to topLeft of region
  set corner [region topleft $region]

  set cpX [* 1 [lindex $corner 0]]
  set cpY [* 1 [lindex $corner 1]]
  set cp [list $cpX $cpY]
  set cursorTop [list $cpX [expr {$cpY - 50}]]

  Display::stroke [list $cp $cursorTop] 2 gray
}

When $id has program code /code/ & the clock time is /t/ & the cursor is /cursor/ & $id has region /r/ {
  # NOTE: This is a useful debugging line as it flashes
  #       the actual letter corresponding to the cursor
  #       position. The current virtual cursor ()
  set intTime [expr {int($t * 10)}]
  drawText [insertCursor $code $cursor $intTime] $cursor $intTime $r
  # Hide cursor, TODO: fix to calculate accurate position based on cursor position
  # drawCursor $cursor $r

  # DEBUG INFO
  When the cursor is /cursor/ {
    Wish $id has halo message "cursor: $cursor"
  }
}

proc getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [lindex $cursor 1]]
  string length $currentLine
}

# Must use `Every time` but it's incompatible with the keyboard claim or something, as written? Confer with Omar ...
Every time keyboard claims key /currentCharacter/ is down with modifiers /modifier/ & the cursor is /cursor/ & $id has program code /code/ {
  Commit cursor {
    switch $currentCharacter {
      UP {
        set updatedCursor [updateCursor $cursor {y -1}]
        set currentLineLength  [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      DOWN {
        set updatedCursor [updateCursor $cursor {y 1}]
        set currentLineLength [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      RIGHT {
        set currentLineLength [getCurrentLineLength $code $cursor]
        # TODO: Check if the cursor is at the end of the line, if so cap it
        Claim the cursor is [updateCursor $cursor {x 1}]
      }
      LEFT { Claim the cursor is [updateCursor $cursor {x -1}] }
      BACKSPACE {
        Claim the cursor is [updateCursor $cursor {x -1}]
        Commit code { Claim $id has program code [deleteCharacter $code $cursor] }
      }
      SPACE {
        Claim the cursor is [updateCursor $cursor {x 1}]
        Commit code { Claim $id has program code [insertCharacter $code " " $cursor] }
      }
      ENTER {
        # Note: Still need to figure out the exact & text manipulation methods for all the
        #      different cases of enter. This is just a simple one for now.
        Claim the cursor is [updateCursor $cursor {x [expr {-1 * [x $cursor]}] y 1}]
        # Claim the cursor is [updateCursor $cursor {x 0 y 1}]
        # NOTE: Useful debugging print line, still figuring out the math.
        #       Unforuntately this doesn't have consistent cursor spacing as the
        #       X-coordinate increases.
        # puts "calc: [expr {-1 * [x $cursor]}]"
        Commit code { Claim $id has program code [insertNewline $code $cursor] }
      }
      LEFTSHIFT -
      RIGHTSHIFT -
      LEFTCTRL -
      RIGHTCTRL {
        Claim the cursor is $cursor
      }
      default {
        Claim the cursor is [updateCursor $cursor {x 1}]
        # Unneccessary b/c of properly handled stuff??
        # if {$modifier == "shift"} {
        #   set currentCharacter [string toupper $currentCharacter]
        # }
        if {$modifier == "ctrl" & $currentCharacter == "p"} {
          Wish to print $code with job id [expr {rand()}]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "r"} {
          Commit code { Claim $id has program code $baseCode }
          Claim the cursor is [list 0 0]
          return
        }
        Commit code { Claim $id has program code [insertCharacter $code $currentCharacter $cursor] }
      }
    }
  }
}

Claim $this has demo {
  # Tape this program underneath the main keyboard of your system to try it out
  Claim $this is editor editor-1
}