When the editor utils library is /utils/ {

set baseCode "Wish \$this is outlined green"

# This makes all keyboards into editors automatically, so a keyboard
# doesn't need an extra printed claim to be an editor. May choose to
# change later, or exclude keyboards that opt out.
When /page/ is a keyboard with /...opts/ &\
     /nobody/ claims /page/ is not an editor {
    dict set opts locale [dict getdef $opts locale us]
    if {[dict exists $opts path]} {
        Wish (keep 100ms) $page is an editor with {*}$opts
    }
}

# HACK: This is so that the wish can cycle in and out but the identity
# of the inner claim is retained, so the editor doesn't reboot.
When /someone/ wishes /page/ is an editor with /...opts/ {
    Claim $page is an editor with {*}$opts
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  Wish tag $page is stabilized

  set id [list editing $page $kbPath]

  set writableTextureId [list $id canvas]
  Wish (keep 100ms) the GPU creates canvas $writableTextureId with width 1024 height 1024
  When the GPU has created canvas $writableTextureId with /...opts/ {
      Claim $id has canvas $writableTextureId with {*}$opts
  }
  When $page has resolved geometry /geom/ {
      Claim $id has resolved geometry $geom
  }
  When $page has canvas projection /proj/ {
      Claim $id has canvas projection $proj
  }
  When the quad library is /quadLib/ & $page has quad /q/ {
      Claim $id has quad [$quadLib move $q up 210%]
  }

  if {[llength [Query! /someone/ claims $id has program code /c/]] == 0} {
      Hold! -key "programCode$kbPath" \
          Claim $id has program code $baseCode
  }
  if {[llength [Query! /someone/ claims $id has editor code /c/]] == 0} {
      Hold! -save -key "code$kbPath" {
          Claim $id has editor code $baseCode
      }
  }

  if {[llength [Query! /someone/ claims $id has start time /startTime/]] == 0} {
      set t [expr {[clock milliseconds] / 1000.0}]
      Hold! -key [list $id start-time] \
          Claim $id has start time $t
      Hold! -key [list $id most-recent-time] \
          Claim $id has most recent time $t
  }
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  On unmatch {
      Hold! -key [list $id start-time] {}
  }
}

fn x {vector} { lindex $vector 0 }
fn y {vector} { lindex $vector 1 }

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  if {[llength [Query! /someone/ claims the $kbPath cursor is /anything/]] == 0} {
    Hold! -key "cursor$kbPath" {
      Claim the $kbPath cursor is 0
      Claim the $kbPath max cursor x is 0
    }
  }
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

    # Construct the editor window $id':
    set writableTextureId [list $id' canvas]
    Wish (keep 100ms) the GPU creates canvas $writableTextureId with width 1024 height 1024
    When the GPU has created canvas $writableTextureId with /...opts/ {
        Claim $id' has canvas $writableTextureId with {*}$opts
    }
    When $page has resolved geometry /geom/ {
        Claim $id' has resolved geometry $geom
    }
    When $page has canvas projection /proj/ {
        Claim $id' has canvas projection $proj
    }

    When the quad library is /quadLib/ & $id has quad /q/ {
        Claim $id' has quad [$quadLib move $q down 105%]
    }

    set scale 0.0075
    Wish $id' is outlined white

    When $id has program code /code/ & $id has editor code /editorCode/ {
        set p [list 0.02 0.01]
        Wish to draw text onto $id' with \
            position $p text $editorCode \
            scale $scale anchor topleft font NeomatrixCode

        # Draw line numbers
        set lp [list 0.005 0.01]
        set linecount [llength [split $editorCode "\n"]]
        set linenumbers [$utils lineNumberView 0 $linecount]
        Wish to draw text onto $id' with \
            position $lp text $linenumbers \
            scale $scale anchor topleft font NeomatrixCode

        When the $kbPath cursor is /cursor/ {
            set cursor [$utils cursorToXy $editorCode $cursor]

            set em [expr {$scale * 1}]
            # From NeomatrixCode.csv
            set advance [expr {0.5859375 * $scale}]

            # Draw cursor
            set curs [vec2 scale $cursor $advance $em]

            set x1 [vec2 add $p $curs]
            set x2 [vec2 add $x1 [list 0 [expr {$em * 1.3}]]]

            set s [expr {$scale / 6}]
            Wish to draw a circle onto $id' with center $x1 radius $s thickness 0 color green filled true
            Wish to draw a line onto $id' with points [list $x1 $x2] width $s color green
        }
    }
}

# OK, what's next?

# - figure out how to speed up Hold serialization when you edit the code (cache the outgoing env? share env values instead of whole env?)
# - figure out how to KEEP PRESENTATION VISUALS so the page doesn't vanish but NOT MATCH ON DATA QUERY so you don't get weird behavior when editing the code
#   - maybe you can set a query policy?

When /page/ is printing /jobid/ & /page/ has region /r/ {
  set r [region move $r left 50px]
  lassign [region left $r] x y
  set angle [region angle $r]
  Wish to draw text with x $x y $y text  "Printing (jobid: $jobid)" radians [+ $angle 1.55] font NeomatrixCode
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

  Subscribe: keyboard $kbPath claims key /key/ is /keyState/ with /...options/ {
    ForEach! the $kbPath cursor is /cursor/ &\
             the $kbPath max cursor x is /maxCursorX/ &\
             $id has program code /programCode/ &\
             $id has editor code /editorCode/ &\
             $id has start time /startTime/ {
      set timestamp [dict get $options timestamp]

      if {$keyState == "down" || $keyState == "repeat"} {
        if {[dict exists $options printable]} {
          lassign [$utils insertText $code $cursor [dict get $options printable]] code cursor maxCursorX
        } else {
          lassign [$utils handleNavigation $key $editorCode $cursor $maxCursorX] cursor maxCursorX
          lassign [$utils handleRemovalAndReturn $key $editorCode $cursor $maxCursorX] editorCode cursor maxCursorX

          # TODO: Implement DELETE, operates like BACKSPACE, but in the opposite direction
          # TODO: MUTE VOLUMEUP VOLUMEDOWN
          #       implement sound.folk that allows a system-wide
          #       volume setting to be adjusted.
          #       Perhaps `Wish $system volume is 0.5` or something
          switch $key {
            Control_p {
              set tooSoon false

              # debouncing, in case the user accidentally hits it twice
              set results [Query! $id has printed /lastPrintedCode/ at /previousTime/]
              if {[llength $results] > 0} {
                set previousTime [dict get [lindex $results 0] previousTime]

                if {($timestamp - $previousTime) < 1000} {
                  set tooSoon true
                }
              }

              if {!$tooSoon} {
                Hold! -key print { Claim $id has printed $programCode at $timestamp }

                Notify: print code $programCode
                Hold! -key print-feedback {
                  Claim $id' is printing
                  sleep 2
                  Hold! -key print-feedback {}
                }
              }
            }
            Control_r {
              set editorCode $baseCode
              set programCode $editorCode

              set cursor 0
            }
            Control_s {
              set programCode $editorCode
            }
          }
        }
      }

      Hold! -keep 12ms -key "code$kbPath" {
        Claim $id has program code $programCode
        Claim $id has editor code $editorCode
      }

      Hold! -key "cursor$kbPath" {
        Claim the $kbPath cursor is $cursor
        Claim the $kbPath max cursor x is $maxCursorX
      }
    }
  }
}

Claim $this has demo {
  # Find your keyboard path with the script in this guide: https://folk.computer/guides/keyboard
  Claim $this is a keyboard with path /dev/input/by-path/pci-0000:02:00.0-usb-0:2:1.2-event-mouse locale us
  Claim $this is an editor
}

}
