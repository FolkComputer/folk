set id "editor-1"
set ::debug_cursor true
set ::debug_print true

When /page/ is editor /n/ & /page/ has region /r/ {
    Wish $page is outlined gray
    Claim $id has region [region move $r up 450px]
}

proc updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
    lset newCursor 0 [expr {max(0, [dict get $updates x] + [lindex $oldCursor 0])}]
  }
  if {[dict exists $updates y]} {
    lset newCursor 1 [expr {max(0, [dict get $updates y] + [lindex $oldCursor 1])}]
  }
  return $newCursor
}

# NOTE: Should this go into a common-functions file?
proc x {vector} { lindex $vector 0 }
proc y {vector} { lindex $vector 1 }

# TODO: Scope to "When the editor is out" or something
Commit cursor { Claim the cursor is [list 0 0]}

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [- $x 1]
  set line [lindex $lines $y]

  if {$x < 0} {
    lset lines $y [string cat $newCharacter $line]
    return [join $lines "\n"]
  } else {
    set character [string cat [string index $line $x] $newCharacter]
    set line [string replace $line $x $x $character]
    lset lines $y $line
    return [join $lines "\n"]
  }
}

proc swapCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set line [string replace $line $x $x $newCharacter]
  lset lines $y $line
  return [join $lines "\n"]
}

proc deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lset lines $y ""
    set newLines {}
    for {set i 0} {$i < [llength $lines]} {incr i} {
      if {$i != $y} {
        lappend newLines [lindex $lines $i]
      }
    }
    set lines $newLines
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]
    lset lines $y $line
  }
  return [join $lines "\n"]
}

proc deleteToBeginning {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set newLine [string range $line $x end]
  lset lines $y $newLine
  return [join $lines "\n"]
}


proc insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
   if {$count % 2 == 0} {
     return [swapCharacter $code "_" $cursor]
   } else {
     return $code    
   }
}

proc newRegion {program x y w h} {
  set vertices [list [list [expr {$x+$w}] $y] \
              [list $x $y] \
              [list $x [expr {$y+$h}]] \
              [list [expr {$x+$w}] [expr {$y+$h}]]]
  set edges [list [list 0 1] [list 1 2] [list 2 3] [list 3 0]]
  Claim $program has region [region create $vertices $edges]
}

set baseCode "Wish \$this is outlined green"
# long base code
# set baseCode "Claim\nWish \$this is outlined green\nClaim this is a super long linelooooooooong line\nClaim the future is good\nClaim lorem ipsum long long long long long long long long long long long\nClaim bl000000000000000000000000000000_______oooooop\nClaim hello hello hello hello hello hello hello"
Commit code { Claim $id has program code $baseCode }

proc drawText {text cursor count region} {
  set lineNumber 1
  set showCursor [expr {$count % 2 == 0}]
  # TODO: Make the font size change relative to `Wish $this is small|medium|large editor 1` (by default should use small, e.g. fontSize 1)
  Display::text {*}[region centroid $region] 1 $text [region angle $region] NeomatrixCode
}

proc rotateStroke {points center angle} {
  lmap v $points {
    set v [vec2 sub $v $center]
    set v [vec2 rotate $v $angle]
    set v [vec2 add $v $center]
    set v
  }
}

proc getLineLength {code cursor} {
  set lines [split $code "\n"]
  set line [lindex $lines [lindex $cursor 1]]
  set ll [string length $line]
  return $ll
}

proc getLineShift {lines} {
  set longestLineLength 0
  foreach line [split $lines "\n"] {
    set lineLength [string length $line]
    if {$lineLength > $longestLineLength} {
      set longestLineLength $lineLength
    }
  }
  return [list [expr {$longestLineLength / 2}] [expr {[llength $lines] / 2}]]
}

proc debug {position color} {
  Display::circle {*}$position 5 2 $color true
}

proc drawCursor {cursorPosition lineShift region} {
  set anchor [region centroid $region]
  set angle [region angle $region]

  if {$::debug_cursor} {
    debug $anchor green
  }

  set cursorHeight 20
  set cursorWidth 9
  set shiftMultiplier [list 12 20]
  # set shiftMultiplier [list 14 25]
  # set shiftMultiplier [list 14 20]
  set cursorScale [list 14 25] ;# OLD
  # projectorToCamera????

  set lineShiftHalf [list [lindex $lineShift 0] 0]
  set multipliedShift [vec2::mult $shiftMultiplier $lineShift]
  # set adjustedShift [sub $multipliedShift $lineShiftHalf]
  set adjustedShift $multipliedShift
  set shiftedAnchor [sub $anchor $adjustedShift]
  if {$::debug_cursor} {
    debug [lindex [rotateStroke [list $shiftedAnchor] $anchor $angle] 0] white
  }
  # add (x * width) to the shiftedAnchor position from the beginning of the line ...
  set scaledCursor [vec2::mult $cursorScale $cursorPosition]

  set finalCursor [add $shiftedAnchor $scaledCursor]
  set rotatedFenalCursor [lindex [rotateStroke [list $finalCursor] $anchor $angle] 0]

  if {$::debug_cursor} {
    # This is where the cursor point is relative to.
    # cursor, green
    Display::stroke [rotateStroke \
        [list $finalCursor \
        [add $finalCursor [list 0 $cursorHeight]] \
      ] \
      $anchor $angle] 2 green  
    # vertical reticle line
    Display::stroke [rotateStroke \
        [list $finalCursor \
          [add $finalCursor [list 0 25]] \
          [add $finalCursor [list 0 -25]] \
      ] \
      $anchor $angle] 2 green

    # horizontal reticle line
    Display::stroke [rotateStroke \
        [list $finalCursor \
          [add $finalCursor [list 25 0]] \
          [add $finalCursor [list -25 0]] \
      ] \
      $anchor $angle] 2 green
  }
}

When $id has program code /code/ & the clock time is /t/ & the cursor is /cursor/ & $id has region /r/ {
  set intTime [expr {int($t * 10)}]
  drawText [insertCursor $code $cursor $intTime] $cursor $intTime $r

  set lineShift [getLineShift $code]
  drawCursor $cursor $lineShift $r

  if {$::debug_cursor} {
    # draw lines for every line of text
    set lineCount [llength [split $code "\n"]]
    set horizontalLines [list]
    set anchor [region centroid $r]
    set angle [region angle $r]

    set vertical_spacer 20
    for {set i -10} { $i < 10 } {incr i} {
      lappend verticalLines [add $anchor [list 0 [expr {$i * $vertical_spacer}]]]
      lappend verticalLines [add $anchor [list 100 [expr {$i * $vertical_spacer}]]]
      lappend verticalLines [add $anchor [list $vertical_spacer [expr {$i * $vertical_spacer}]]]
    }

    set horizontal_spacer 14
    for {set i -10} { $i < 10 } {incr i} {
      lappend horizontalLines [add $anchor [list [expr {$i * $horizontal_spacer}] 0]]
      lappend horizontalLines [add $anchor [list [expr {$i * $horizontal_spacer}] 100 ]]
      lappend horizontalLines [add $anchor [list [expr {$i * $horizontal_spacer}] $horizontal_spacer]]
    }
    Display::stroke [rotateStroke $verticalLines $anchor $angle] 2 green
    Display::stroke [rotateStroke $horizontalLines $anchor $angle] 2 white
  }
}

proc getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [lindex $cursor 1]]
  string length $currentLine
}

Every time keyboard claims key /currentCharacter/ is down with modifiers /modifier/ & the cursor is /cursor/ & $id has program code /code/ {
  Commit cursor {
    switch $currentCharacter {
      UP {
        set updatedCursor [updateCursor $cursor {y -1}]
        set currentLineLength  [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list [- $currentLineLength 1]  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      DOWN {
        set linecount [llength [split $code "\n"]]
        set updatedCursor [updateCursor $cursor {y 1}]
        set currentLineLength [getCurrentLineLength $code $updatedCursor]

        if {[lindex $updatedCursor 1] == $linecount} {
          Claim the cursor is $cursor
          return
        } elseif {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      RIGHT {
        set currentLineLength [getCurrentLineLength $code $cursor]
        # TODO: Check if the cursor is at the end of the line, if so cap it
        Claim the cursor is [updateCursor $cursor {x 1}]
      }
      LEFT { Claim the cursor is [updateCursor $cursor {x -1}] }
      BACKSPACE {
        # if cursor is at the beginning of the line, delete the newline
        if {[x $cursor] == 0} {
          set newCursor [updateCursor $cursor {y -1}]
          set previousLineLength  [getCurrentLineLength $code $newCursor]
          set newCursor [list $previousLineLength [y $newCursor]]
          Claim the cursor is $newCursor
        } else {
          Claim the cursor is [updateCursor $cursor {x -1}]
        }
        Commit code { Claim $id has program code [deleteCharacter $code $cursor] }
      }
      SPACE {
        Claim the cursor is [updateCursor $cursor {x 1}]
        Commit code { Claim $id has program code [insertCharacter $code " " $cursor] }
      }
      ENTER {
        set updatedCursor [updateCursor $cursor {y 1}]
        Claim the cursor is [list 0 [lindex $updatedCursor 1]]
        Commit code { Claim $id has program code [insertNewline $code $cursor] }
      }
      DELETE -
      INSERT -
      MUTE -
      VOLUMEUP -
      VOLUMEDOWN -
      LEFTSHIFT -
      RIGHTSHIFT -
      LEFTCTRL -
      RIGHTCTRL {
        # TODO: Implement DELETE, operates like BACKSPACE, but in the opposite direction
        # TODO: MUTE VOLUMEUP VOLUMEDOWN
        #       implement sound.folk that allows a system-wide 
        #       volume setting to be adjusted.
        #       Perhaps `Wish $system volume is 0.5` or something

        Claim the cursor is $cursor
      }
      default {
        if {$modifier == "ctrl" & $currentCharacter == "p"} {
          # TODO: Save time instead and prevent printing the same code within the same ... second?
          When $id has printed /lastPrintedCode/ {
            if {$lastPrintedCode == $code} {
              Claim the cursor is $cursor
              if {$::debug_print} {
                puts "Not printing the same code twice"
              }
              return
            }
          }
          When /nobody/ has printed /lastPrintedCode/ {
            if {$::debug_print} {
              puts "Printing $code"
            }
            Commit print { Claim $id has printed $code}
            Wish to print $code with job id [expr {rand()}]
            return
          }
          Commit code { Claim $id has program code $code}
          Claim the cursor is $cursor
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "r"} {
          Commit code { Claim $id has program code $baseCode }
          Claim the cursor is [list 0 0]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "a"} {
          Commit code { Claim $id has program code $code}
          lassign $cursor x y
          Claim the cursor is [list 0 $y]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "e"} {
          Commit code { Claim $id has program code $code}
          lassign $cursor x y
          Claim the cursor is [list [getLineLength $code $cursor] $y]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "u"} {
          # delete from cursor back to 0 and move cursor to 0
          Commit code { Claim $id has program code [deleteToBeginning $code $cursor]}
          lassign $cursor x y
          Claim the cursor is [list 0 $y]
          return
        }
        Claim the cursor is [updateCursor $cursor {x 1}]
        Commit code { Claim $id has program code [insertCharacter $code $currentCharacter $cursor] }
      }
    }
  }
}

Claim $this has demo {
  # Tape this program underneath the main keyboard of your system to try it out
  Claim $this is editor editor-1

  # Ideally:
  Claim $this is keyboard with path /dev/input/by-path/platform-i8042-serio-0-event-kbd
}