# TODO: Make this not-hard-coded
#       In fact, this shouldn't be "editor-1" at all but
#       probably should be the MAC address or some Bluetooth
#       thread ID?
set id "editor-1"

When /page/ is editor /n/ & /page/ has region /r/ {
    Wish $page is outlined gray
    Claim $id has region [region move $r up 450px]
}

proc updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
    lset newCursor 0 [expr {max(0, [dict get $updates x] + [lindex $oldCursor 0])}]
  }
  if {[dict exists $updates y]} {
    lset newCursor 1 [expr {max(0, [dict get $updates y] + [lindex $oldCursor 1])}]
  }
  return $newCursor
}

# NOTE: Should this go into a common-functions file?
proc x {vector} { lindex $vector 0 }
proc y {vector} { lindex $vector 1 }

# TODO: Scope to "When the editor is out" or something
Commit cursor { Claim the cursor is [list 0 0]}

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [expr {$x - 1}]
  set line [lindex $lines $y]
  set character [string cat [string index $line $x] $newCharacter]
  set line [string replace $line $x $x $character]
  lset lines $y $line
  return [join $lines "\n"]
}

proc swapCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set line [string replace $line $x $x $newCharacter]
  lset lines $y $line
  return [join $lines "\n"]
}

proc deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    # TODO:
    # - delete thisLine from the lines array
    # - move cursor to end of previous line
    lreplace lines $y $y
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]
    lset lines $y $line
  }
  return [join $lines "\n"]
}

proc insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
   if {$count % 2 == 0} {
     return [swapCharacter $code "_" $cursor]
   } else {
     return $code    
   }
}

proc newRegion {program x y w h} {
  set vertices [list [list [expr {$x+$w}] $y] \
              [list $x $y] \
              [list $x [expr {$y+$h}]] \
              [list [expr {$x+$w}] [expr {$y+$h}]]]
  set edges [list [list 0 1] [list 1 2] [list 2 3] [list 3 0]]
  Claim $program has region [region create $vertices $edges]
}

# NOTE: This is convenient for me debugging (gets triggered with Ctrl + R)
#       but should probably be "Claim this has halo message editor" or something
#       not as intrusive as outlining to start? Just a thought.
# set baseCode "Wish \$this is outlined gold"
set baseCode "Claim\nWish \$this is outlined gold\n";#Claim this is a very looooooong line\n";## Comment\nset lorem 0\nset ipsum 0"
Commit code { Claim $id has program code $baseCode }

proc drawText {text cursor count region} {
  set lineNumber 1
  set showCursor [expr {$count % 2 == 0}]
  # TODO: Make the font size change relative to `Wish $this is small|medium|large editor 1` (by default should use small, e.g. fontSize 1)
  Display::text {*}[region centroid $region] 1 $text [region angle $region]
}

########
# For reference, from folk/lib/math.tcl#L206:217
#######
# proc rotate {r angle} {
#     set theta [angle $r]
#     set c [centroid $r]
#     set r' [mapVertices v $r {
#         set v [vec2 sub $v $c]
#         set v [vec2 rotate $v $angle]
#         set v [vec2 add $v $c]
#         set v
#     }]
#     lset r' 2 [+ $theta $angle]
#     set r'
# }
#######################################
#
# In order to construct a cursor that's relative to the virtual keyboard you must
# know three things:
#   1. The center of the virtual region
#   2. The angle of the virtual region
#   3. The position of the cursor relative to the virtual region (this is rather involved because it requires calcualting from the center and then taking cursor units from that point)
#
#######################################

proc rotateStroke {points center angle} {
  lmap v $points {
    set v [vec2 sub $v $center]
    set v [vec2 rotate $v $angle]
    set v [vec2 add $v $center]
    set v
  }
}

proc getLineShift {lines} {
  set longestLineLength 0
  foreach line [split $lines "\n"] {
    set lineLength [string length $line]
    if {$lineLength > $longestLineLength} {
      set longestLineLength $lineLength
    }
  }
  return [list [expr {$longestLineLength / 2}] [expr {[llength $lines] / 2}]]
}

proc drawCursor {cursorPosition lineShift region} {
  set angle [region angle $region]
  set anchor [region centroid $region]
  # Need to figure out the formula for getting from (0, 0) [centeroid of the region] to the cursor position
  # - first translate the cursor position from the centroid to the top left of the text region
  # - then rotate the stroke to match the angle of its parent region
  set multipliedShift [vec2::mult [list 10 10] $lineShift]
  set shiftedAnchor [add $anchor $multipliedShift]
  set scaledCursor [vec2::mult [list -20 -10] $cursorPosition]

  set finalCursor [add $shiftedAnchor $scaledCursor]

  Display::circle {*}$shiftedAnchor 5 5 red
  Display::circle {*}$finalCursor 5 5 green
  puts "shiftedAnchor: $shiftedAnchor"

  set cursorMultiplierX -20
  set cursorMultiplierY -30
  set cursorMultiplier [list $cursorMultiplierX $cursorMultiplierY]

  set multipliedLineShift [list [* $cursorMultiplierX [lindex $lineShift 0]] [* $cursorMultiplierY [lindex $lineShift 1]]]
  set anchor [sub $anchor $multipliedLineShift]

  lassign $cursorPosition cursorX cursorY
  # set cursorMultiplied [list [* $cursorMultiplierX $cursorX] [* $cursorMultiplierY $cursorY]]
  set cursorMultiplied [vec2 mult $cursorMultiplier $cursorPosition]
  # Offset by one?
  set cursorMultiplied [add $cursorMultiplied $cursorMultiplier]

  set anchor [add $anchor $cursorMultiplied]

  set anchor_up [add $anchor [list 0 $cursorMultiplierY]]
  set anchor_right [sub $anchor [list $cursorMultiplierX 0]]
  set anchor_right_up [add $anchor_right [list 0 $cursorMultiplierY]]

  set cursorPoints [list $anchor_up $anchor $anchor_right $anchor_right_up $anchor_up]

  Display::stroke [rotateStroke $cursorPoints $anchor $angle] 1 green
}

When $id has program code /code/ & the clock time is /t/ & the cursor is /cursor/ & $id has region /r/ {
  # NOTE: This is a useful debugging line as it flashes
  #       the actual letter corresponding to the cursor
  #       position. The current virtual cursor ()
  set intTime [expr {int($t * 10)}]
  drawText [insertCursor $code $cursor $intTime] $cursor $intTime $r
  set lineShift [getLineShift $code]
  drawCursor $cursor $lineShift $r

  # DEBUG INFO
  When the cursor is /cursor/ {
    Wish $id has halo message "cursor: $cursor"
  }
}

proc getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [lindex $cursor 1]]
  string length $currentLine
}

# Must use `Every time` but it's incompatible with the keyboard claim or something, as written? Confer with Omar ...
Every time keyboard claims key /currentCharacter/ is down with modifiers /modifier/ & the cursor is /cursor/ & $id has program code /code/ {
  Commit cursor {
    switch $currentCharacter {
      UP {
        set updatedCursor [updateCursor $cursor {y -1}]
        set currentLineLength  [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      DOWN {
        set updatedCursor [updateCursor $cursor {y 1}]
        set currentLineLength [getCurrentLineLength $code $updatedCursor]
        if {[lindex $updatedCursor 0] > $currentLineLength} {
          Claim the cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
        } else {
          Claim the cursor is $updatedCursor
        }
      }
      RIGHT {
        set currentLineLength [getCurrentLineLength $code $cursor]
        # TODO: Check if the cursor is at the end of the line, if so cap it
        Claim the cursor is [updateCursor $cursor {x 1}]
      }
      LEFT { Claim the cursor is [updateCursor $cursor {x -1}] }
      BACKSPACE {
        Claim the cursor is [updateCursor $cursor {x -1}]
        Commit code { Claim $id has program code [deleteCharacter $code $cursor] }
      }
      SPACE {
        Claim the cursor is [updateCursor $cursor {x 1}]
        Commit code { Claim $id has program code [insertCharacter $code " " $cursor] }
      }
      ENTER {
        # Note: Still need to figure out the exact & text manipulation methods for all the
        #      different cases of enter. This is just a simple one for now.
        Claim the cursor is [updateCursor $cursor {x [expr {-1 * [x $cursor]}] y 1}]
        # Claim the cursor is [updateCursor $cursor {x 0 y 1}]
        # NOTE: Useful debugging print line, still figuring out the math.
        #       Unforuntately this doesn't have consistent cursor spacing as the
        #       X-coordinate increases.
        # puts "calc: [expr {-1 * [x $cursor]}]"
        Commit code { Claim $id has program code [insertNewline $code $cursor] }
      }
      LEFTSHIFT -
      RIGHTSHIFT -
      LEFTCTRL -
      RIGHTCTRL {
        Claim the cursor is $cursor
      }
      default {
        Claim the cursor is [updateCursor $cursor {x 1}]
        # Unneccessary b/c of properly handled stuff??
        # if {$modifier == "shift"} {
        #   set currentCharacter [string toupper $currentCharacter]
        # }
        if {$modifier == "ctrl" & $currentCharacter == "p"} {
          Wish to print $code with job id [expr {rand()}]
          return
        }
        if {$modifier == "ctrl" & $currentCharacter == "r"} {
          Commit code { Claim $id has program code $baseCode }
          Claim the cursor is [list 0 0]
          return
        }
        Commit code { Claim $id has program code [insertCharacter $code $currentCharacter $cursor] }
      }
    }
  }
}

Claim $this has demo {
  # Tape this program underneath the main keyboard of your system to try it out
  Claim $this is editor editor-1
}