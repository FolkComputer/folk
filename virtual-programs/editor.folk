set ::debug_print false
set baseCode "Wish \$this is outlined green"

When /page/ is a keyboard with path /kbPath/ & /page/ has region /r/ {
  set id "$page$kbPath"
  Wish $page is outlined gray
  Claim $id has region [region move $r up 450px]
  When /nobody/ claims $id has program code /c/ {
    Commit "code$kbPath" {
      Claim $id has program code $baseCode 
    }
  }
}

proc updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
    lset newCursor 0 [expr {max(0, [dict get $updates x] + [lindex $oldCursor 0])}]
  }
  if {[dict exists $updates y]} {
    lset newCursor 1 [expr {max(0, [dict get $updates y] + [lindex $oldCursor 1])}]
  }
  return $newCursor
}

# NOTE: Should this go into a common-functions file?
proc x {vector} { lindex $vector 0 }
proc y {vector} { lindex $vector 1 }

# TODO: Scope to "When the editor is out" or something
When /page/ is a keyboard with path /kbPath/ {
  Commit "cursor$kbPath" { Claim the $kbPath cursor is [list 0 0]}
}

proc insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [- $x 1]
  set line [lindex $lines $y]

  if {$x < 0} {
    lset lines $y [string cat $newCharacter $line]
    return [join $lines "\n"]
  } else {
    set character [string cat [string index $line $x] $newCharacter]
    set line [string replace $line $x $x $character]
    lset lines $y $line
    return [join $lines "\n"]
  }
}

proc swapCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set line [string replace $line $x $x $newCharacter]
  lset lines $y $line
  return [join $lines "\n"]
}

proc deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lset lines $y ""
    set newLines {}
    for {set i 0} {$i < [llength $lines]} {incr i} {
      if {$i != $y} {
        lappend newLines [lindex $lines $i]
      }
    }
    set lines $newLines
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]
    lset lines $y $line
  }
  return [join $lines "\n"]
}

proc deleteToBeginning {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set newLine [string range $line $x end]
  lset lines $y $newLine
  return [join $lines "\n"]
}


proc insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

proc insertCursor {code cursor count} {
   if {$count % 2 == 0} {
     return [swapCharacter $code "_" $cursor]
   } else {
     return $code    
   }
}

proc newRegion {program x y w h} {
  set vertices [list [list [expr {$x+$w}] $y] \
              [list $x $y] \
              [list $x [expr {$y+$h}]] \
              [list [expr {$x+$w}] [expr {$y+$h}]]]
  set edges [list [list 0 1] [list 1 2] [list 2 3] [list 3 0]]
  Claim $program has region [region create $vertices $edges]
}

proc rotateStroke {points center angle} {
  lmap v $points {
    set v [vec2 sub $v $center]
    set v [vec2 rotate $v $angle]
    set v [vec2 add $v $center]
    set v
  }
}

proc getLineLength {code cursor} {
  set lines [split $code "\n"]
  set line [lindex $lines [lindex $cursor 1]]
  set ll [string length $line]
  return $ll
}

proc getLineShift {lines} {
  set longestLineLength 0
  foreach line [split $lines "\n"] {
    set lineLength [string length $line]
    if {$lineLength > $longestLineLength} {
      set longestLineLength $lineLength
    }
  }
  return [list [expr {$longestLineLength / 2}] [expr {[llength $lines] / 2}]]
}

proc debug {position color} {
  Display::circle {*}$position 5 2 $color true
}

When /page/ is a keyboard with path /kbPath/ {
  set id "$page$kbPath"
  When $id has program code /code/ & the clock time is /t/ & the $kbPath cursor is /cursor/ & $id has region /r/ {
    set intTime [expr {int($t * 10)}]
    set scale 0.60

    lassign [region topleft $r] xstart ystart
    set em [expr {$scale * 25}]
    # From NeomatrixCode.csv
    set advance [expr {0.5859375 * $em}]
    set margin [expr {$advance * 3 + 10}]

    set p [region topleft [region move $r right ${margin}px down 10px]]
    set lp [region topleft [region move $r right 5px down 10px]]
    set height [expr {[region height $r] - 25}]
    set width [expr {[region width $r] - ($margin + 20)}]
    set radians [region angle $r]

    set curs [vec2 scale $cursor $advance $em]

    set x1 [vec2 sub $p $curs]
    set x2 [vec2 sub $x1 [list 0 [expr {$em + 4}]]]

    set theta [expr {$radians + 3.14159}]
    set x1 [vec2 add [vec2 rotate [vec2 sub $x1 $p] $theta] $p]
    set x2 [vec2 add [vec2 rotate [vec2 sub $x2 $p] $theta] $p]
    set s [expr {$scale * 4}]

    # Draw text
    Wish to draw text with position $p text $code scale $scale anchor topleft radians [region angle $r] font NeomatrixCode
    # Draw cursor
    Wish to draw a circle with center $x1 radius $s thickness 0 color green filled true
    Wish to draw a stroke with points [list $x1 $x2] width $s color green
  }
}

proc getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [lindex $cursor 1]]
  string length $currentLine
}

When /page/ is a keyboard with path /kbPath/ {
  set id "$page$kbPath"
  Every time keyboard $kbPath claims key /currentCharacter/ is down with modifiers /modifier/ & the $kbPath cursor is /cursor/ & $id has program code /code/ {
    Commit "cursor$kbPath" {
      switch $currentCharacter {
        UP {
          set updatedCursor [updateCursor $cursor {y -1}]
          set currentLineLength  [getCurrentLineLength $code $updatedCursor]
          if {[lindex $updatedCursor 0] > $currentLineLength} {
            Claim the $kbPath cursor is [list [- $currentLineLength 1]  [lindex $updatedCursor 1]]
          } else {
            Claim the $kbPath cursor is $updatedCursor
          }
        }
        DOWN {
          set linecount [llength [split $code "\n"]]
          set updatedCursor [updateCursor $cursor {y 1}]
          set currentLineLength [getCurrentLineLength $code $updatedCursor]

          if {[lindex $updatedCursor 1] == $linecount} {
            Claim the $kbPath cursor is $cursor
            return
          } elseif {[lindex $updatedCursor 0] > $currentLineLength} {
            Claim the $kbPath cursor is [list $currentLineLength  [lindex $updatedCursor 1]]
          } else {
            Claim the $kbPath cursor is $updatedCursor
          }
        }
        RIGHT {
          set currentLineLength [getCurrentLineLength $code $cursor]
          if {[lindex $cursor 0] == $currentLineLength} {
            Claim the $kbPath cursor is $cursor
          } else {
            Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
          }
        }
        LEFT { Claim the $kbPath cursor is [updateCursor $cursor {x -1}] }
        BACKSPACE {
          # if cursor is at the beginning of the line, delete the newline
          if {[x $cursor] == 0} {
            set newCursor [updateCursor $cursor {y -1}]
            set previousLineLength  [getCurrentLineLength $code $newCursor]
            set newCursor [list $previousLineLength [y $newCursor]]
            Claim the $kbPath cursor is $newCursor
          } else {
            Claim the $kbPath cursor is [updateCursor $cursor {x -1}]
          }
          Commit "code$kbPath" { Claim $id has program code [deleteCharacter $code $cursor] }
        }
        SPACE {
          Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
          Commit "code$kbPath" { Claim $id has program code [insertCharacter $code " " $cursor] }
        }
        ENTER {
          set updatedCursor [updateCursor $cursor {y 1}]
          Claim the $kbPath cursor is [list 0 [lindex $updatedCursor 1]]
          Commit "code$kbPath" { Claim $id has program code [insertNewline $code $cursor] }
        }
        DELETE -
        INSERT -
        MUTE -
        VOLUMEUP -
        VOLUMEDOWN -
        ESC -
        TAB -
        CAPSLOCK -
        LEFTSHIFT -
        RIGHTSHIFT -
        LEFTALT -
        RIGHTALT -
        LEFTCTRL -
        RIGHTCTRL {
          # TODO: Implement DELETE, operates like BACKSPACE, but in the opposite direction
          # TODO: MUTE VOLUMEUP VOLUMEDOWN
          #       implement sound.folk that allows a system-wide 
          #       volume setting to be adjusted.
          #       Perhaps `Wish $system volume is 0.5` or something

          Claim the $kbPath cursor is $cursor
        }
        default {
          if {$modifier == "ctrl" & $currentCharacter == "p"} {
            # TODO: Save time instead and prevent printing the same code within the same ... second?
            When $id has printed /lastPrintedCode/ {
              if {$lastPrintedCode == $code} {
                Claim the $kbPath cursor is $cursor
                if {$::debug_print} {
                  puts "Not printing the same code twice"
                }
                return
              }
            }
            When /nobody/ has printed /lastPrintedCode/ {
              if {$::debug_print} {
                puts "Printing $code"
              }
              Commit print { Claim $id has printed $code}
              Wish to print $code with job id [expr {rand()}]
              return
            }
            Commit "code$kbPath" { Claim $id has program code $code}
            Claim the $kbPath cursor is $cursor
            return
          }
          if {$modifier == "ctrl" & $currentCharacter == "r"} {
            Commit "code$kbPath" { Claim $id has program code $baseCode }
            Claim the $kbPath cursor is [list 0 0]
            return
          }
          if {$modifier == "ctrl" & $currentCharacter == "a"} {
            Commit "code$kbPath" { Claim $id has program code $code}
            lassign $cursor x y
            Claim the $kbPath cursor is [list 0 $y]
            return
          }
          if {$modifier == "ctrl" & $currentCharacter == "e"} {
            Commit "code$kbPath" { Claim $id has program code $code}
            lassign $cursor x y
            Claim the $kbPath cursor is [list [getLineLength $code $cursor] $y]
            return
          }
          if {$modifier == "ctrl" & $currentCharacter == "u"} {
            # delete from cursor back to 0 and move cursor to 0
            Commit "code$kbPath" { Claim $id has program code [deleteToBeginning $code $cursor]}
            lassign $cursor x y
            Claim the $kbPath cursor is [list 0 $y]
            return
          }
          Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
          Commit "code$kbPath" { Claim $id has program code [insertCharacter $code $currentCharacter $cursor] }
        }
      }
    }
  }
}

Claim $this has demo {
  # Find your keyboard path with the script in this guide: https://folk.computer/guides/keyboard
  Claim $this is a keyboard with path /dev/input/by-path/pci-0000:02:00.0-usb-0:2:1.2-event-mouse
}
