set baseCode "Wish \$this is outlined green"

# This makes all keyboards into editors automatically, so a keyboard
# doesn't need an extra printed claim to be an editor. May choose to
# change later, or exclude keyboards that opt out.
When /page/ is a keyboard with /...opts/ {
    dict set opts locale [dict getdef $opts locale us]
    if {[dict exists $opts path]} {
        Wish (keep 100ms) $page is an editor with {*}$opts
    }
}

# HACK: This is so that the wish can cycle in and out but the identity
# of the inner claim is retained, so the editor doesn't reboot.
When /someone/ wishes /page/ is an editor with /...opts/ {
    Claim $page is an editor with {*}$opts
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  Wish tag $page is stabilized

  set id [list editing $page $kbPath]

  set writableImageId [list $id writable image]
  Wish (keep 100ms) the GPU creates writable image $writableImageId with width 1024 height 1024
  Claim $id has writable image $writableImageId
  When $page has resolved geometry /geom/ {
      Claim $id has resolved geometry $geom
  }
  When $page has writable image projection /proj/ {
      Claim $id has writable image projection $proj
  }
  When the quad library is /quadLib/ & $page has quad /q/ {
      Claim $id has quad [$quadLib move $q up 210%]
  }

  if {[llength [Query! /someone/ claims $id has program code /c/]] == 0} {
      Hold! "code$kbPath" {
          Claim $id has program code $baseCode
          Claim $id has editor code $baseCode
      }
  }

  if {[llength [Query! /someone/ claims $id has start time /startTime/]] == 0} {
      set t [expr {[clock milliseconds] / 1000.0}]
      Hold! [list $id start-time] {
          Claim $id has start time $t
      }
      Hold! [list $id most-recent-time] {
          Claim $id has most recent time $t
      }
  }
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  On unmatch {
      Hold! [list $id start-time] {}
  }
}

fn x {vector} { lindex $vector 0 }
fn y {vector} { lindex $vector 1 }

fn updateCursor {oldCursor updates} {
  set newCursor $oldCursor
  if {[dict exists $updates x]} {
      lset newCursor 0 [::math::max 0 $([dict get $updates x] + [x $oldCursor])]
  }
  if {[dict exists $updates y]} {
      lset newCursor 1 [::math::max 0 $([dict get $updates y] + [y $oldCursor])]
  }
  return $newCursor
}

When /page/ is an editor with path /kbPath/ /...anything/ {
  set id [list editing $page $kbPath]
  if {[llength [Query! /someone/ claims the $kbPath cursor is /anything/]] == 0} {
    Hold! "cursor$kbPath" {
      Claim the $kbPath cursor is [list 0 0]
    }
  }
}

fn insertCharacter {code newCharacter cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set x [- $x 1]
  set line [lindex $lines $y]

  if {$x < 0} {
    if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
    lset lines $y [string cat $newCharacter $line]
    return [join $lines "\n"]
  } else {
    set character [string cat [string index $line $x] $newCharacter]
    set line [string replace $line $x $x $character]
    lset lines $y $line
    return [join $lines "\n"]
  }
}

fn deleteCharacter {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  if {$x == 0 && $y > 0} {
    set previousLine [lindex $lines [expr {$y - 1}]]
    set thisLine [lindex $lines $y]
    set mergedLine [string cat $previousLine $thisLine]
    lset lines [expr {$y - 1}] $mergedLine
    lset lines $y ""
    set newLines {}
    for {set i 0} {$i < [llength $lines]} {incr i} {
      if {$i != $y} {
        lappend newLines [lindex $lines $i]
      }
    }
    set lines $newLines
  } else {
    set line [lindex $lines $y]
    set line [string replace $line [expr {$x - 1}] [expr {$x - 1}] ""]

    if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
    lset lines $y $line
  }
  return [join $lines "\n"]
}

fn deleteToBeginning {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set newLine [string range $line $x end]
  lset lines $y $newLine
  return [join $lines "\n"]
}

fn insertNewline {code cursor} {
  set lines [split $code "\n"]
  lassign $cursor x y
  set line [lindex $lines $y]
  set beforeCursor [string range $line 0 [expr {$x - 1}]]
  set afterCursor [string range $line $x end]
  set newLines [list $beforeCursor $afterCursor]

  if {[llength $lines] == 0 && $y == 0} { set lines [list {}] }
  lset lines $y [join $newLines "\n"]
  return [join $lines "\n"]
}

fn getLineLength {code cursor} {
  set lines [split $code "\n"]
  set line [lindex $lines [lindex $cursor 1]]
  set ll [string length $line]
  return $ll
}

fn lineNumberView {ystart linecount} {
  set yend [expr {$ystart + $linecount}]
  set numbers [list]
  for {set i [expr {$ystart + 1}]} {$i <= $yend} {incr i} {
    lappend numbers $i
  }
  join $numbers "\n"
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

    # Construct the editor window $id':
    set writableImageId [list $id' writable image]
    Wish (keep 100ms) the GPU creates writable image $writableImageId with width 1024 height 1024
    Claim $id' has writable image $writableImageId
    When $page has resolved geometry /geom/ {
        Claim $id' has resolved geometry $geom
    }
    When $page has writable image projection /proj/ {
        Claim $id' has writable image projection $proj
    }

    When the quad library is /quadLib/ & $id has quad /q/ {
        Claim $id' has quad [$quadLib move $q down 105%]
    }

    set scale 0.01
    Wish $id' is outlined white

    When $id has program code /code/ & $id has editor code /editorCode/ {
        set p [list 0.02 0.01]
        Wish to draw text onto $id' with \
            position $p text $editorCode \
            scale $scale anchor topleft font NeomatrixCode

        # Draw line numbers
        set lp [list 0.005 0.01]
        set linecount [llength [split $editorCode "\n"]]
        set linenumbers [lineNumberView 0 $linecount]
        Wish to draw text onto $id' with \
            position $lp text $linenumbers \
            scale $scale anchor topleft font NeomatrixCode

        When the $kbPath cursor is /cursor/ {
            set em [expr {$scale * 1}]
            # From NeomatrixCode.csv
            set advance [expr {0.5859375 * $scale}]

            # Draw cursor
            set curs [vec2 scale $cursor $advance $em]

            set x1 [vec2 add $p $curs]
            set x2 [vec2 add $x1 [list 0 [expr {$em + 0.004}]]]

            set s [expr {$scale / 6}]
            Wish to draw a circle onto $id' with center $x1 radius $s thickness 0 color green filled true
            Wish to draw a line onto $id' with points [list $x1 $x2] width $s color green
        }
    }
}

fn getCurrentLineLength {lines cursor} {
  set splitLines [split $lines "\n"]
  set currentLine [lindex $splitLines [y $cursor]]
  string length $currentLine
}

# OK, what's next?

# - figure out how to speed up Hold serialization when you edit the code (cache the outgoing env? share env values instead of whole env?)
# - figure out how to KEEP PRESENTATION VISUALS so the page doesn't vanish but NOT MATCH ON DATA QUERY so you don't get weird behavior when editing the code
#   - maybe you can set a query policy?

When /page/ is printing /jobid/ & /page/ has region /r/ {
  set r [region move $r left 50px]
  lassign [region left $r] x y
  set angle [region angle $r]
  Wish to draw text with x $x y $y text  "Printing (jobid: $jobid)" radians [+ $angle 1.55] font NeomatrixCode
}

When /page/ is an editor with path /kbPath/ /...anything/ {
    set id [list editing $page $kbPath]

  # Desired behavior: query all the other stuff every time you hit a
  # key, then destroy the when (don't want _any_ reaction after the
  # original firing, and don't want to keep the match around).
  Every time keyboard $kbPath claims key /key/ is /keyState/ with /...options/ &\
             the $kbPath cursor is /cursor/ &\
             $id has program code /code/ &\
             $id has editor code /editorCode/ &\
             $id has start time /startTime/ &\
             $id has most recent time /mostRecentTime/ {

    set timestamp [dict get $options timestamp]
    if {$timestamp < $mostRecentTime} {
        puts stderr "editor: Warning: Dropping '$key' ($keyState)"
        return
    }

    HoldStatement! [list $id most-recent-time] \
        [list $this claims $id has most recent time $timestamp]

    if {$timestamp > $startTime && ($keyState == "down" || $keyState == "repeat")} {
      if {[dict exists $options printable]} {
        Hold! "cursor$kbPath" {
          Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
          Hold! (keep 12ms) "code$kbPath" {
            Claim $id has program code $code
            Claim $id has editor code [insertCharacter $editorCode [dict get $options printable] $cursor]
          }
        }
      } else {
        Hold! "cursor$kbPath" {
          switch $key {
            Up {
              set updatedCursor [updateCursor $cursor {y -1}]
              set currentLineLength  [getCurrentLineLength $editorCode $updatedCursor]
              if {[x $updatedCursor] > $currentLineLength} {
                Claim the $kbPath cursor is [list $currentLineLength  [y $updatedCursor]]
              } else {
                Claim the $kbPath cursor is $updatedCursor
              }
            }
            Down {
              set linecount [llength [split $editorCode "\n"]]
              set updatedCursor [updateCursor $cursor {y 1}]
              set currentLineLength [getCurrentLineLength $editorCode $updatedCursor]

              if {[y $updatedCursor] == $linecount} {
                Claim the $kbPath cursor is $cursor
                return
              } elseif {[x $updatedCursor] > $currentLineLength} {
                Claim the $kbPath cursor is [list $currentLineLength  [y $updatedCursor]]
              } else {
                Claim the $kbPath cursor is $updatedCursor
              }
            }
            Right {
              set currentLineLength [getCurrentLineLength $editorCode $cursor]
              if {[x $cursor] == $currentLineLength} {
                if {[y $cursor] == [expr {[llength [split $editorCode "\n"]] - 1}]} {
                  Claim the $kbPath cursor is $cursor
                } else {
                  set newCursor [updateCursor $cursor {y 1}]
                  Claim the $kbPath cursor is [list 0 [y $newCursor]]
                }
              } else {
                Claim the $kbPath cursor is [updateCursor $cursor {x 1}]
              }
            }
            Left {
              if {[x $cursor] == 0 && [y $cursor] == 0} {
                Claim the $kbPath cursor is $cursor
              } elseif {[x $cursor] == 0} {
                set newCursor [updateCursor $cursor {y -1}]
                set previousLineLength  [getCurrentLineLength $editorCode $newCursor]
                set newCursor [list $previousLineLength [y $newCursor]]
                Claim the $kbPath cursor is $newCursor
              } else {
                Claim the $kbPath cursor is [updateCursor $cursor {x -1}]
              }
            }
            Delete {
              # if cursor is at the beginning of the line, delete the newline
              if {[x $cursor] == 0 && [y $cursor] > 0} {
                set newCursor [updateCursor $cursor {y -1}]
                set previousLineLength  [getCurrentLineLength $editorCode $newCursor]
                set newCursor [list $previousLineLength [y $newCursor]]
                Claim the $kbPath cursor is $newCursor
              } else {
                Claim the $kbPath cursor is [updateCursor $cursor {x -1}]
              }
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code [deleteCharacter $editorCode $cursor]
              }
            }
            Remove {
              Claim the $kbPath cursor is $cursor
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code [deleteCharacter $editorCode [updateCursor $cursor {x 1}]]
              }
            }
            Return {
              set updatedCursor [updateCursor $cursor {y 1}]
              Claim the $kbPath cursor is [list 0 [y $updatedCursor]]
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code [insertNewline $editorCode $cursor]
              }
            }
            Control_p {
              # TODO: Implement DELETE, operates like BACKSPACE, but in the opposite direction
              # TODO: MUTE VOLUMEUP VOLUMEDOWN
              #       implement sound.folk that allows a system-wide
              #       volume setting to be adjusted.
              #       Perhaps `Wish $system volume is 0.5` or something
              When $id has printed /lastPrintedCode/ at /previousTime/ {
                if {($timestamp - $previousTime) < 1000} {
                  Hold! (keep 12ms) "code$kbPath" {
                    Claim $id has program code $code
                    Claim $id has editor code $editorCode
                  }
                  Claim the $kbPath cursor is $cursor
                }
              }

              Hold! print { Claim $id has printed $code at $timestamp}
              set jobid [expr {rand()}]
              Wish to print $code with job-id $jobid
              Hold! print-${jobid} {
                Claim $id' is printing $jobid
              }
              After 2000 milliseconds {
                Hold! print-${jobid} {}
              }

              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code $editorCode
              }
              Claim the $kbPath cursor is $cursor
            }
            Control_r {
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $baseCode
                Claim $id has editor code $baseCode
              }
              Claim the $kbPath cursor is [list 0 0]
            }
            Control_s {
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $editorCode
                Claim $id has editor code $editorCode
              }
              Claim the $kbPath cursor is $cursor
            }
            Control_a {
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code $editorCode
              }
              lassign $cursor x y
              Claim the $kbPath cursor is [list 0 $y]
            }
            Control_e {
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code $editorCode
              }
              lassign $cursor x y
              Claim the $kbPath cursor is [list [getLineLength $editorCode $cursor] $y]
            }
            Control_u {
              # delete from cursor back to 0 and move cursor to 0
              Hold! (keep 12ms) "code$kbPath" {
                Claim $id has program code $code
                Claim $id has editor code [deleteToBeginning $editorCode $cursor]
              }
              lassign $cursor x y
              Claim the $kbPath cursor is [list 0 $y]
            }
            default {
              Claim the $kbPath cursor is $cursor
            }
          }
        }
      }
    }
  }
}

Claim $this has demo {
  # Find your keyboard path with the script in this guide: https://folk.computer/guides/keyboard
  Claim $this is a keyboard with path /dev/input/by-path/pci-0000:02:00.0-usb-0:2:1.2-event-mouse locale us
  Claim $this is an editor
}
