set baseCode "Wish \$this is outlined green"

# This makes all keyboards into editors automatically, so a keyboard
# doesn't need an extra printed claim to be an editor. May choose to
# change later, or exclude keyboards that opt out.
When /page/ is a keyboard with path /...anything/ &\
     /nobody/ claims /page/ is not an editor {
    Claim $page is an editor
}

When /page/ is a keyboard with path /kbPath/ /...anything/ &\
  /page/ is an editor &\
  /page/ has region /r/ &\
  the clock time is /t/ {
  Wish tag $page is stabilized
  set id "$page$kbPath"
  Claim $id has region [region move $r up 210%]
  When /nobody/ claims $id has program code /c/ {
    Hold "code$kbPath" {
      Claim $id has program code $baseCode
      Claim $id has editor code $baseCode
    }
  }

  When /nobody/ claims $id has start time /startTime/ {
    Hold "time$kbPath" {
      Claim $id has start time $t
    }
  }
}

When /page/ is a keyboard with path /kbPath/ /...anything/ {
  On unmatch {
    Hold "time$kbPath" {}
  }
}

When /page/ is a keyboard with path /kbPath/ /...anything/ & /page/ is an editor {
  set id "$page$kbPath"
  When /nobody/ claims $id has program code /c/ {
    Hold "cursor$kbPath" {
      Claim the $kbPath cursor is 0
      Claim the $kbPath max cursor x is 0
    }
  }
}

proc lineNumberView {ystart linecount} {
  set yend [expr {$ystart + $linecount}]
  set numbers [list]
  for {set i [expr {$ystart + 1}]} {$i <= $yend} {incr i} {
    lappend numbers $i
  }
  join $numbers "\n"
}

proc debug {position color} {
  Display::circle {*}$position 5 2 $color true
}

When /page/ is a keyboard with path /kbPath/ /...anything/ & /page/ is an editor {
  set id "$page$kbPath"
  When $id has program code /code/ & $id has editor code /editorCode/ & the clock time is /t/ & the $kbPath cursor is /cursor/ & $id has region /r/ {
    set intTime [expr {int($t * 10)}]
    set scale 0.60

    set relativeRegion [region move $r down 105%]
    Claim $id' has region $relativeRegion
    Wish $id' is outlined white
    lassign [region topleft $r] xstart ystart
    set em [expr {$scale * 25}]
    # From NeomatrixCode.csv
    set advance [expr {0.5859375 * $em}]
    set margin [expr {$advance * 3 + 10}]

    set p [region topleft [region move $relativeRegion right ${margin}px down 10px]]
    set lp [region topleft [region move $relativeRegion right 5px down 10px]]
    set height [expr {[region height $relativeRegion] - 25}]
    set width [expr {[region width $relativeRegion] - ($margin + 20)}]
    set radians [region angle $relativeRegion]

    set cursorVec [editor::cursorToXy $editorCode $cursor]
    set curs [vec2 scale $cursorVec $advance $em]

    set x1 [vec2 sub $p $curs]
    set x2 [vec2 sub $x1 [list 0 [expr {$em + 4}]]]

    set theta [expr {$radians + 3.14159}]
    set x1 [vec2 add [vec2 rotate [vec2 sub $x1 $p] $theta] $p]
    set x2 [vec2 add [vec2 rotate [vec2 sub $x2 $p] $theta] $p]
    set s [expr {$scale * 4}]

    # Draw text
    Wish to draw text with position $p text $editorCode scale $scale anchor topleft radians [region angle $relativeRegion] font NeomatrixCode

    # Draw line numbers
    set linecount [llength [split $editorCode "\n"]]
    set linenumbers [lineNumberView 0 $linecount]
    Wish to draw text with position $lp text $linenumbers scale $scale anchor topleft radians $radians font NeomatrixCode

    # Draw cursor
    Wish to draw a circle with center $x1 radius $s thickness 0 color green filled true
    Wish to draw a stroke with points [list $x1 $x2] width $s color green
  }
}

When /page/ is printing /jobid/ & /page/ has region /r/ {
  set r [region move $r left 50px]
  lassign [region left $r] x y
  set angle [region angle $r]
  Wish to draw text with x $x y $y text  "Printing (jobid: $jobid)" radians [+ $angle 1.55] font NeomatrixCode
}

When /page/ is a keyboard with path /kbPath/ /...anything/ & /page/ is an editor {
  set id "$page$kbPath"

  Every time keyboard $kbPath claims key /key/ is /keyState/ with /...options/ &\
             the $kbPath cursor is /cursor/ &\
             the $kbPath max cursor x is /maxCursorX/ &\
             $id has program code /programCode/ &\
             $id has editor code /editorCode/ &\
             $id has start time /startTime/ {
    set timestamp [dict get $options timestamp]

    if {$timestamp > ($startTime * 1000) && ($keyState == "down" || $keyState == "repeat")} {
      Hold "cursor$kbPath" {
        if {[dict exists $options printable]} {
          set editorCode [editor::insertText $editorCode $cursor [dict get $options printable]]

          incr cursor
          incr maxCursorX
        } else {
          lassign [editor::handleNavigation $key $editorCode $cursor $maxCursorX] cursor maxCursorX
          lassign [editor::handleRemovalAndReturn $key $editorCode $cursor $maxCursorX] editorCode cursor maxCursorX

          switch $key {
            Control_p {
              # TODO: MUTE VOLUMEUP VOLUMEDOWN
              #       implement sound.folk that allows a system-wide
              #       volume setting to be adjusted.
              #       Perhaps `Wish $system volume is 0.5` or something
              When $id has printed /lastPrintedCode/ at /previousTime/ {
                if {($timestamp - $previousTime) < 1000} {
                  return;
                }
              }

              Hold print-time {
                Claim $id has printed $programCode at $timestamp
              }

              set jobid [expr {rand()}]
              Wish to print $programCode with job-id $jobid
              Hold print-${jobid} {
                Claim $id' is printing $jobid
              }
              After 2000 milliseconds {
                Hold print-${jobid} {}
              }
            }
            Control_r {
              set editorCode $baseCode
              set programCode $editorCode

              set cursor 0
            }
            Control_s {
              set programCode $editorCode
            }
          }
        }

        Hold "code$kbPath" {
          Claim $id has program code $programCode
          Claim $id has editor code $editorCode
        }

        Claim the $kbPath cursor is $cursor
        Claim the $kbPath max cursor x is $maxCursorX
      }
    }
  }
}

Claim $this has demo {
  # Find your keyboard path with the script in this guide: https://folk.computer/guides/keyboard
  Claim $this is a keyboard with path /dev/input/by-path/pci-0000:02:00.0-usb-0:2:1.2-event-mouse locale us
  Claim $this is an editor
}
