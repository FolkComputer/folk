source "pi/cUtils.tcl"

set cc [c create]
$cc cflags -I$::env(HOME)/apriltag -Wall -Werror $::env(HOME)/apriltag/libapriltag.a
c loadlib $::env(HOME)/apriltag/libapriltag.so

$cc code {
    #include <apriltag.h>
    #include <tagStandard52h13.h>
    apriltag_family_t *tf = NULL;

    #define emit(...) i += sprintf(&ret[i], __VA_ARGS__)
}
$cc proc ::tagImageForId {int id} char* {
    if (tf == NULL) tf = tagStandard52h13_create();

    image_u8_t* image = apriltag_to_image(tf, id);

    char* ret = Tcl_Alloc(10000);
    int i = 0;
    emit("gsave\n");
    emit("0 1 translate\n");
    emit("%f %f scale\n", 1.0/image->width, -1.0/image->height);
    for (int row = 0; row < image->height; row++) {
        for (int col = 0; col < image->width; col++) {
            uint8_t pixel = image->buf[(row * image->stride) + col];
            emit("%d setgray ", pixel != 0);
            emit("newpath ");
            emit("%d %d moveto ", col, row); // bottom-left
            emit("%d %d lineto ", col + 1, row); // bottom-right
            emit("%d %d lineto ", col + 1, row + 1); // top-right
            emit("%d %d lineto ", col, row + 1); // top-left
            emit("closepath fill ");
        }
        emit("\n");
    }
    emit("grestore\n");
    ret[i++] = '\0';
    image_u8_destroy(image);
    return ret;
}
$cc compile

proc ::programToPs {id text {format "letter"} {side "front"} {fontsize 12} {tagsize 150}} {
    set margin 36
    set PageWidth 612; set PageHeight 792

    if {$format eq "indexcard"} {
        # front in portrait, back in landscape
        set tagsize 150
        set fontsize 8; set lineheight [expr $fontsize*1.5]
        set margin 36
        if {$side eq "front"} {
            set image [::tagImageForId $id]
            return [subst {
                %!PS
                << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

                90 rotate

                gsave
                [expr $PageHeight-$tagsize-$margin] [expr -$margin-$tagsize] translate
                $tagsize $tagsize scale
                $image
                grestore

                /Helvetica-Narrow findfont
                10 scalefont
                setfont
                newpath
                [expr $PageHeight-$tagsize-$margin] [expr -$margin-$tagsize-16] moveto
                ($id ([clock format [clock seconds] -timezone :America/New_York -format "%a, %d %b %Y, %r"])) show

            }]
        } elseif {$side eq "back"} {
            set linenum 1
            return [subst {
                %!PS
                << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

                /Courier findfont
                $fontsize scalefont
                setfont
                newpath
                [join [lmap line [split $text "\n"] {
                    set line [string map {"\\" "\\\\"} $line]
                    set ret "$margin [expr $PageHeight-$margin-$linenum*$lineheight] moveto ($line) show"
                    incr linenum
                    set ret
                }] "\n"]
            }]
        }
    }

    # tag each line with its 1-indexed line number
    set lines [split $text "\n"]
    for {set i 0} {$i < [llength $lines]} {incr i} {
        lset lines $i [list [expr {$i+1}] [lindex $lines $i]]
    }

    set fontwidth [expr $fontsize * 0.8]
    set lineheight [expr $fontsize * 1.5]

    # Constants for line-breaking
    set numlineshort [expr {int(ceil($tagsize / $lineheight) + 1)}]
    set numcharshort [expr {int(($PageWidth - $tagsize) / $fontwidth)}]
    set numcharlong [expr {int($PageWidth / $fontwidth)}]

    # Hard-wrap lines
    for {set i 0} {$i < [llength $lines]} {incr i} {
        lassign [lindex $lines $i] linenum line

   	if {$i < $numlineshort && [string length $line] > $numcharshort} {
            lset lines $i 1 [string range $line 0 $numcharshort]
            set lines [linsert $lines $i+1 [list "" [string range $line [+ $numcharshort 1] end]]]

	} elseif {[string length $line] > $numcharlong} {
            lset lines $i 1 [string range $line 0 $numcharlong]
            set lines [linsert $lines $i+1 [list "" [string range $line [+ $numcharlong 1] end]]]
	}
    }

    set image [::tagImageForId $id]

    set lineidx 0
    subst {
        %!PS
        << /PageSize \[$PageWidth $PageHeight\] >> setpagedevice

        /settextcolor {[expr { $side eq "back" ? { 0.4 setgray } : { 0 setgray } }]} def

        /Courier findfont
        $fontsize scalefont
        setfont
        newpath
        [join [lmap lineinfo $lines {
            lassign $lineinfo linenum line
            set line [string map {"\\" "\\\\" ")" "\\)" "(" "\\("} $line]
            incr lineidx
            subst {
                $margin [expr $PageHeight-$margin-$lineidx*$lineheight] moveto
                0.4 setgray ([format "%- 3s" $linenum]) show settextcolor ($line) show
            }
        }] "\n"]

        [expr { $side eq "back" ? {} : [subst {
          gsave
          [expr $PageWidth-$tagsize-$margin] [expr $PageHeight-$tagsize-$margin] translate
          $tagsize $tagsize scale
          $image
          grestore
        }] }]

        /Helvetica-Narrow findfont
        10 scalefont
        setfont
        newpath
        [expr $PageWidth-$tagsize-$margin] [expr $PageHeight-$tagsize-16-$margin] moveto
        ($id ([clock format [clock seconds] -timezone :America/New_York -format "%a, %d %b %Y, %r"])) show
    }
}

if {$::isLaptop} { return }

exec mkdir -p "$::env(HOME)/folk-printed-programs"
proc nextId {} {
    try {
        set fp [open "$::env(HOME)/folk-printed-programs/next-id.txt" r]
        set id [string trim [read $fp]]
        close $fp
    } trap {POSIX ENOENT} {} {
        set id 0
    }

    while {[file exists "$::env(HOME)/folk-printed-programs/$id.folk"]} {
        incr id
    }

    set fp [open "$::env(HOME)/folk-printed-programs/next-id.txt" w]
    puts $fp [expr {$id + 1}]
    close $fp

    set id
}

proc remotePrintRequest {remoteNode clause} {
    ::websocket::open "ws://$remoteNode.local:4273/ws" [list apply {{clause sock type msg} {
        if {$type eq "connect"} {
            ::websocket::send $sock text [list apply {{clause} {
                Assert {*}$clause
                after 5000 [list Retract {*}$clause]
                Step
            }} $clause]
            after 10000 [list ::websocket::close $sock]
        }
    }} $clause]
}

if {![info exists ::printjobs]} {set ::printjobs [dict create]}

When /someone/ wishes to print program /p/ with code /code/ with job id /jobid/ & \
  the collected matches for [list /someone/ wishes /p/ prints with fontsize /s/] are /fontsizes/ & \
  the collected matches for [list /someone/ wishes /p/ prints with tagsize /s/] are /tagsizes/ \
{
    if {$::thisNode eq "folk-beads" || $::thisNode eq "folk-convivial"} {
        # HACK: Forward the print request to folk0.
        remotePrintRequest "folk0" [list $::thisNode wishes to print program $p with code $code with job id $jobid]
        return
    }

    puts "Wish to print jobid $jobid"
    if {[dict exists $::printjobs $jobid]} {return}

    set id [nextId]
    dict set ::printjobs $jobid [list $id $code]

    set format "letter"
    if {[string first {Wish $this prints on an index card} $code] != -1} {
       set format "indexcard"
    }

    set fontsize 12
    if {[llength $fontsizes] > 0} {
        set fontsize [dict get [lindex $fontsizes 0] s]
    }

    set tagsize 150
    if {[llength $tagsizes] > 0} {
        set tagsize [dict get [lindex $tagsizes 0] s]
    }

    set ps [programToPs $id $code $format front $fontsize $tagsize]

    # save code and ps to disk
    if {[file exists "$::env(HOME)/folk-printed-programs/$id.folk"]} {
        error "Program $id already exists on disk. Aborting print."
    }
    set fp [open "$::env(HOME)/folk-printed-programs/$id.folk" w]
    puts $fp $code
    close $fp

    set fp [open "$::env(HOME)/folk-printed-programs/$id.ps" w]
    puts $fp $ps
    close $fp

    exec ps2pdf $::env(HOME)/folk-printed-programs/$id.ps $::env(HOME)/folk-printed-programs/$id.pdf
    exec lpr $::env(HOME)/folk-printed-programs/$id.pdf
}

# NB: does not allocate a new program.
When /someone/ wishes to reprint program /id/ with code /code/ with job id /jobid/ {
    if {$::thisNode eq "folk-beads" || $::thisNode eq "folk-convivial"} {
        # HACK: Forward the print request to folk0.
        remotePrintRequest "folk0" [list $::thisNode wishes to print program $id with code $code with job id $jobid]
        return
    }

    puts "Wish to print jobid $jobid"
    if {[dict exists $::printjobs $jobid]} {return}

    dict set ::printjobs $jobid [list $id $code]

    set format "letter"
    if {[string first {Wish $this prints on an index card} $code] != -1} {
       set format "indexcard"
    }

    set ps [programToPs $id $code $format front]

    set fp [open "$::env(HOME)/folk-printed-programs/$id.ps" w]
    puts $fp $ps
    close $fp

    exec ps2pdf $::env(HOME)/folk-printed-programs/$id.ps $::env(HOME)/folk-printed-programs/$id.pdf
    exec lpr $::env(HOME)/folk-printed-programs/$id.pdf
}

When /someone/ wishes to print the back of job id /jobid/ {
    lassign [dict get $::printjobs $jobid] id code

    set format "letter"
    if {[string first {Wish $this prints on an index card} $code] != -1} {
       set format "indexcard"
    }

    set ps [programToPs $id $code $format back]
    set fp [open "$::env(HOME)/folk-printed-programs/$id-back.ps" w]
    puts $fp $ps
    close $fp

    exec ps2pdf $::env(HOME)/folk-printed-programs/$id-back.ps $::env(HOME)/folk-printed-programs/$id-back.pdf
    exec lpr $::env(HOME)/folk-printed-programs/$id-back.pdf
}
