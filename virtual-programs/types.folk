set isNumberVerifier {{x} { string is double -strict $x }}

# start of scientific types
Claim type mm exists
Claim type mm has verifier $isNumberVerifier
Claim type mm converts to cm with {{mm} {
    return [/ $mm 10]
}}

Claim type cm exists
Claim type cm has verifier $isNumberVerifier
Claim type cm converts to m with {{cm} {
    return [/ $mm 100]
}}
Claim type cm converts to mm with {{cm} {
    return [* $cm 10]
}}

Claim type m exists
Claim type m has verifier $isNumberVerifier
Claim type m has description "Meter, standard SI unit"

Claim type velocity exists
Claim type velocity has verifier $isNumberVerifier
Claim type velocity has inline representation distance/time

Claim type acceleration exists
Claim type acceleration has verifier $isNumberVerifier
Claim type acceleration has inline representation distance/time^2

# start of code
set typesLib [library create typesLib {
    proc regexEscape {str} {
        regsub -all {\W} $str {\\&}
    }

    proc convertInlineRepToRegex {inlineRep} {
        # escape all regex symbols
        set inlineRep [regexEscape $inlineRep]
        set regex "^[regsub -nocase -all {[a-z]+} $inlineRep {([a-z]+)}]$"
    }

    # This is a bit tricky to explain the reason for, but let me give some example inputs:
    # `{10 mm}`: enters the first branch, `[llength $varName] > 1`
    # `10mm`: this hits the second branch. The numerical part is the type value,
    #         while everything after is the type name
    # So, this generates code that accounts for both the single-item and normal representation
    proc generateTypeNameAndValueParser {varName} {
        set varName "\$$varName"

        return [subst {
    if {\[llength $varName\] > 1} {
        set typeName \[lindex $varName 1 0\]
        set typeValue \[lindex $varName 0\]
    } else {
        set result \[regexp {(\[0-9.\]+)(.*)} $varName -> typeValue typeName\]
        if {!\$result} {
            error "Could not parse $varName"
        }
    }}]

    }
}]

When type /typeName/ exists {
    puts "Type: $typeName"
    When the collected results for [list /someone/ claims type $typeName /...rest/] are /results/ {
        # the properties of this type
        set type [dict create]

        foreach result $results {
            set rest [dict get $result rest]

            if {[lrange $rest 0 1] == "a program"} {
                continue
            }

            # if there's only one item, then the key must be the first item, with no value
            if {[llength $rest] == 1} {
                set key $rest
            } else {
                set key [lrange $rest 0 end-1]
                set value [lindex $rest end]
            }

            switch $key {
                "exists" {
                    # already handled
                }
                "has verifier" {
                    dict set type verifier $value
                }
                "has inline representation" {
                    dict set type inlineRep $value
                    dict set type inlineRegex [$typesLib convertInlineRepToRegex $value]
                }
                "has description" {
                    dict set type description $value
                }
            }
        }

        # now we'll create a library for each of the type operations: unbox, box, check, and description
        ## unbox ##
        set lines [list]

        lappend lines "proc unbox {toUnbox} {"
        lappend lines "    # this procedure is auto-generated in types.folk"
        # this line adds code that sets typeName and typeValue
        lappend lines [$typesLib generateTypeNameAndValueParser "toUnbox"]
        lappend lines "    "


        # First possibility: check if type name is correct
        lappend lines "    if \{\$typeName == \"$typeName\"\} \{"
        lappend lines "    \}"

        # Second possibility: maybe it's an inline type name?
        if {[dict exists $type inlineRep]} {
            set inlineRegex [dict get $type inlineRegex]
            lset lines end "[lindex $lines end] elseif \{\[regexp [list $inlineRegex] \$typeName\]\} \{"
            lappend lines "    \}"
        }

        # else throw an error
        lset lines end "[lindex $lines end] else \{"
        lappend lines "        error \"Type name was '\$typeName', but was expecting $typeName.\""
        lappend lines "    \}"
        lappend lines "    "


        # only insert the verifier if it exists
        if {[dict exists $type verifier]} {
            set verifier [dict get $type verifier]
            lappend lines "    set verificationResult \[apply [list $verifier] \$typeValue\]"
            lappend lines "    "
            lappend lines "    if \{!\$verificationResult\} \{"
            lappend lines "        error \"Validation failed for $typeName. Value passed in: '\$toUnbox'\""
            lappend lines "    \}"
            lappend lines "    "
        }

        lappend lines "    return \$typeValue"
        lappend lines "\}"

        set unboxProc [join $lines "\n"]


        ## box ##
        set lines [list]

        lappend lines "proc box \{args\} \{"
        lappend lines "    # this procedure is auto-generated in types.folk"
        lappend lines "    set typeName [list $typeName]"
        lappend lines "    set value \[lindex \$args 0\]"
        lappend lines "    "
        lappend lines "    if {\[llength \$args\] > 1} {"
        lappend lines "        set typeName \[list \$typeName {*}\[lrange \$args 1 end\]\]"
        lappend lines "    }"
        lappend lines "    "
        lappend lines "    return \[list \$value \$typeName\]"
        lappend lines "}"

        set boxProc [join $lines "\n"]


        ## check ##
        set lines [list]

        lappend lines "proc check \{toValidate\} \{"
        lappend lines "    # this procedure is auto-generated in types.folk"
        # this line adds code that sets typeName and typeValue
        lappend lines [$typesLib generateTypeNameAndValueParser "toValidate"]
        lappend lines "    "


        # check if type name iscorrect
        lappend lines "    if \{\$typeName == \"$typeName\"\} \{"
        lappend lines "    \}"

        # maybe it's an inline type name?
        if {[dict exists $type inlineRep]} {
            set inlineRegex [dict get $type inlineRegex]
            lset lines end "[lindex $lines end] elseif \{\[regexp [list $inlineRegex] \$typeName\]\} \{"
            lappend lines "    \}"
        }

        # else return that it's not this type
        lset lines end "[lindex $lines end] else \{"
        lappend lines "        return false"
        lappend lines "    \}"
        lappend lines "    "


        # only insert the verifier if it exists
        if {[dict exists $type verifier]} {
            set verifier [dict get $type verifier]
            lappend lines "    set verificationResult \[apply [list $verifier] \$typeValue\]"
            lappend lines "    return \$verificationResult"
        }

        lappend lines "\}"

        set checkProc [join $lines "\n"]

        # description
        set description "No description provided."
        if {[dict exists $type description]} {
            set description [dict get $type description]
        }

        set lines [list]

        lappend lines "proc description \{\} \{"
        lappend lines "    # this procedure is auto-generated in types.folk"
        lappend lines "    return [list $description]"
        lappend lines "\}"

        set descriptionProc [join $lines "\n"]


        # finally, create a library for all the procedures
        set allFunctions [join [list $unboxProc $boxProc $checkProc $descriptionProc] "\n\n"]
        set typeLib [library create typeLibFor_$typeName $allFunctions]

        Claim type library for $typeName is $typeLib

        puts "type library for $typeName is $typeLib"
    }
}


When the collected results for {/someone/ claims type /type/ /...rest/} are /matches/ {
    set types [dict create]

    # first, enumerate all the types
    foreach match $matches {
        set type [dict get $match type]
        set rest [dict get $match rest]

        if {$type == "library"} {
            continue
        }

        if {[lrange $rest 0 1] == "a program"} {
            continue
        }

        # if there's only one item, then the key must be the first item
        if {[llength $rest] == 1} {
            set key $rest
        } else {
            set key [lrange $rest 0 end-1]
            set value [lindex $rest end]
        }

        switch $key {
            "exists" {
                if {![dict exists $types $type]} {
                    dict set types $type [dict create]
                }
            }
            "has verifier" {
                dict set types $type verifier $value
            }
            "has inline representation" {
                dict set types $type inlineRep $value
                dict set types $type inlineRegex [$typesLib convertInlineRepToRegex $value]
            }
        }
    }

    # typeof
    set typeofMapping [dict create]
    set typeofRegexes [dict create]

    dict for {typeName props} $types {
        # Right now this is a simple one-to-one mapping, but we may add
        # more information later.
        dict set typeofMapping $typeName $typeName

        if {[dict exists $props inlineRep]} {
            # how's regex as a key, eh?
            dict set typeofRegexes [dict get $props inlineRegex] $typeName
        }
    }

    set typeLib [library create typeofLib {typeofMapping typeofRegexes} {
        proc of {instance} {
            variable typeofMapping
            variable typeofRegexes

            # copied from generateTypeNameAndValueParser
            if {[llength $instance] > 1} {
                set typeName [lindex $instance 1 0]
                set typeValue [lindex $instance 0]
            } else {
                set result [regexp {([0-9.]+)(.*)} $instance -> typeValue typeName]
                if {!$result} {
                    error "Could not parse $instance"
                }
            }

            # Does it exist as a type name?
            if {[dict exists $typeofMapping $typeName]} {
                return [dict get $typeofMapping $typeName]
            }

            # Else, run through the inline regexes to see if any match
            dict for {regex matchingTypeName} $typeofRegexes {
                if {[regexp $regex $typeName]} {
                    return $matchingTypeName
                }
            }

            return ""
        }

        proc params {instance} {
            set typeName [lindex $instance 1]

            if {[llength $typeName] > 1} {
                return [lrange $typeName 1 end]
            } else {
                return [regexp -inline -nocase -all {[a-z]+} [lindex $typeName 0]]
            }
        }
    }]

    Claim the type library is $typeLib
}

When the type library is /type/ &\
     type library for millimeter is /mm/ &\
     type library for velocity is /vel/ {
    return

    puts "\n--- type testing ---"

    set distance "10 mm"
    puts "distance: $distance"
    puts "unboxed: [$mm unbox $distance]"
    puts "is distance? [$mm check $distance]"
    puts "is velocity? [$vel check $distance]"
    puts "--"

    set distance "20mm"
    puts "distance: $distance"
    puts "unboxed: [$mm unbox $distance]"
    puts "is distance? [$mm check $distance]"
    puts "is velocity? [$vel check $distance]"
    puts "--"

    set speed "20 mm/s"
    puts "speed: $speed"
    puts "type of 'speed': [$type of $speed]"
    set unboxed [$vel unbox $speed]
    puts "unboxed: $unboxed"
    puts "type params: [$type params $speed]"
    set reboxed [$vel box $unboxed {*}[$type params $speed]]
    puts "reboxed: $reboxed"
    puts "unreboxed: [$vel unbox $reboxed]"
    puts "is distance? [$mm check $speed]"
    puts "is velocity? [$vel check $speed]"
}
