set ::debug_keyboard true

proc udevadmProperties {device} {
    return [exec udevadm info --query=property --name=$device]
}

proc establishKeyPressListener {keyboard} {
    set kb [open $keyboard r]
    fconfigure $kb -translation binary
    return $kb
}

# Function to check if the device is a keyboard
proc isKeyboard {device} {
    set properties [udevadmProperties $device]
    if {$properties eq ""} {
        return false
    }
    set isKeyboard [string match *ID_INPUT_KEYBOARD=1* $properties]
    return $isKeyboard
    # TODO: Excluding mice would nice to keey the list of keyboard devices short
    #       Alas, including mice is necessary for the Logitech K400R keyboard
    # set isMouse [string match *ID_INPUT_MOUSE=1* $properties]
    # return [expr {$isKeyboard && !$isMouse}]
}

####
# /dev/input/event* addresses are the ground truth for keyboard devices
#
# This function goes through each of them and checks if they are keyboards
proc walkInputEventPaths {} {
    # set allDevices [glob -nocomplain "/dev/input/event*"]
    set allDevices [glob -nocomplain "/dev/input/by-path/*"]
    set keyboards [list]
    foreach device $allDevices {
        if {[isKeyboard $device]} {
            if {[file readable $device] == 0} {
                puts "Device $device is not readable. Attempting to change permissions."
                # Attempt to change permissions so that the file can be read
                exec sudo chmod +r $device
            }
            lappend keyboards $device
        }
    }
    return $keyboards
}

set keyboardDevices [walkInputEventPaths]

# go through each keyboard device and start a process that 
foreach keyboard $keyboardDevices {
    Claim keyboards are $keyboardDevices
    Start process "keyboard-$keyboard" {
        source "pi/KeyCodes.tcl"
        set KEY_STATES [list up down repeat]

        Wish $::thisProcess shares statements like \
            [list keyboard /kb/ claims key /k/ is /t/ with modifiers /m/ with rand /r/]
        variable evtBytes 16
        variable evtFormat iissi
        if {[exec getconf LONG_BIT] == 64} {
            set evtBytes 24
            set evtFormat wwssi
        }
        set keyboardSpecifier $keyboard

        variable keyboardChannel [open $keyboard r]
        chan configure $keyboardChannel -translation binary

        set modifiers [dict create \
            shift 0 \
            ctrl 0 \
            alt 0 \
        ]
        while 1 {
            binary scan [read $keyboardChannel $evtBytes] $evtFormat tvSec tvUsec type code value
            if {$type == 0x01} { ;# EV_KEY
                set shift [dict get $modifiers shift]
                set key [keyFromCode $code $shift]
                set keyState [lindex $KEY_STATES $value]

                set isDown [expr {$keyState != "up"}]
                if {[string match *SHIFT $key]} {
                    dict set modifiers shift $isDown
                }
                if {[string match *CTRL $key]} {
                    dict set modifiers ctrl $isDown
                }
                if {[string match *ALT $key]} {
                    dict set modifiers alt $isDown
                }

                set heldModifiers [dict keys [dict filter $modifiers value 1]]
                Retract keyboard $keyboardSpecifier claims key /k/ is /t/ with modifiers /m/ with rand /r/
                Assert keyboard $keyboardSpecifier claims key $key is $keyState with modifiers $heldModifiers with rand [rand]
                Step
            }
        }
    }
}
