if {$::isLaptop} return

namespace eval ::Display {
    variable WIDTH
    variable HEIGHT
    variable LAYER 0
    regexp {mode "(\d+)x(\d+)"} [exec fbset] -> WIDTH HEIGHT

    proc drawOnTop {func args} {
        set ::Display::LAYER 1
        uplevel [list $func {*}$args]
        set ::Display::LAYER 0
    }

    proc stroke {points width color} {
        uplevel [list Wish display runs [list Display::stroke $points $width $color] on layer $::Display::LAYER]
    }

    proc circle {x y radius thickness color} {
        uplevel [list Wish display runs [list Display::circle $x $y $radius $thickness $color] on layer $::Display::LAYER]
    }

    proc text args {
        uplevel [list Wish display runs [list Display::text {*}$args] on layer $::Display::LAYER]
    }

    proc fillTriangle args {
        uplevel [list Wish display runs [list Display::fillTriangle {*}$args] on layer $::Display::LAYER]
    }

    proc fillQuad args {
        uplevel [list Wish display runs [list Display::fillQuad {*}$args] on layer $::Display::LAYER]
    }

    proc fillPolygon args {
        uplevel [list Wish display runs [list Display::fillPolygon {*}$args] on layer $::Display::LAYER]
    }
}

On process {
    source pi/Gpu.tcl
    Gpu::init
    Gpu::ImageManager::imageManagerInit

    namespace eval Display {
        variable line [Gpu::pipeline {vec2 from vec2 to float thickness} {
            float l = length(to - from);
            vec2 d = (to - from) / l;
            vec2 q = (gl_FragCoord.xy - (from + to)*0.5);
            q = mat2(d.x, -d.y, d.y, d.x) * q;
            q = abs(q) - vec2(l, thickness)*0.5;
            float dist = length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);

            return dist < 0.0 ? vec4(1, 0, 1, 1) : vec4(0, 0, 0, 0);
        }]

        proc start {} { Gpu::drawStart }

        proc stroke {points width color} {
            variable line
            for {set i 0} {$i < [expr {[llength $points] - 1}]} {incr i} {
                set from [lindex $points $i]
                set to [lindex $points [expr $i+1]]
                Gpu::draw $line $from $to $width
            }
        }
        proc circle {x y radius thickness color} {}
        proc text {x y scale text radians} {}
        proc fillTriangle {args} {}
        proc fillQuad {args} {}
        proc fillPolygon {args} {}
        proc image {x y im radians {scale 1.0}} {}

        proc end {} { Gpu::drawEnd }
    }

    puts "Display tid: [getTid]"

    # TODO: Clean this up. We retract these so that we don't bounce
    # statements back to the main Folk process that it sends us.
    Retract /anyone/ wishes $::thisProcess shares all wishes
    Retract /anyone/ wishes $::thisProcess shares all claims
    Wish $::thisProcess shares statements like \
        [list /someone/ wishes /process/ receives statements like /pattern/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims $::thisProcess has pid /pid/]
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes display runs /command/ on layer /layer/]
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes display runs /command/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims the display time is /displayTime/]

    while true {
        set displayList [list]
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/ on layer /layer/}] {
            lappend displayList [list [dict get $match layer] [dict get $match command]]
        }
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/}] {
            lappend displayList [list 0 [dict get $match command]]
        }

        proc lcomp {a b} {
            set layerA [lindex $a 0]
            set layerB [lindex $b 0]
            if {$layerA == $layerB} {
                expr {[lindex $a 1 0] == "Display::text"}
            } else {
                expr {$layerA - $layerB}
            }
        }

        set displayCommands [lmap sublist [lsort -command lcomp $displayList] {lindex $sublist 1}]
        set renderTime [baretime {
            Display::start
            foreach command $displayCommands { {*}$command }
            Display::end
        }]

        Commit { Claim the display time is "render $renderTime us ($::stepTime)" }
        Step
    }
}

set ::Display::displayTime none
set ::displayTime none
When the display time is /displayTime/ {
    set ::Display::displayTime $displayTime
    set ::displayTime $displayTime
}
