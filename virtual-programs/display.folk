namespace eval ::Display {
    variable WIDTH
    variable HEIGHT
    variable LAYER 0
    if {$::isLaptop} {
        set WIDTH 640; set HEIGHT 480
    } else {
        regexp {mode "(\d+)x(\d+)"} [exec fbset] -> WIDTH HEIGHT
    }

    proc drawOnTop {func args} {
        set ::Display::LAYER 1
        uplevel [list $func {*}$args]
        set ::Display::LAYER 0
    }

    # Create proxy versions of drawing primitives for the main Folk
    # process (that will forward those draw commands to the display
    # subprocess).
    foreach func {stroke circle text fillTriangle fillQuad fillPolygon} {
        proc $func args {
            set func [lindex [info level 0] 0]
            uplevel [list Wish display runs [list $func {*}$args] on layer $::Display::LAYER]
        }
    }
}

On process {
    source pi/Gpu.tcl
    Gpu::init
    Gpu::ImageManager::imageManagerInit

    namespace eval Display {
        variable cross2d [Gpu::fn {vec2 a vec2 b} float {
            return a.x*b.y - a.y*b.x;
        }]
        variable invBilinear [Gpu::fn {vec2 p vec2 a vec2 b vec2 c vec2 d} {cross2d} vec2 {
            vec2 res = vec2(-1.0);

            vec2 e = b-a;
            vec2 f = d-a;
            vec2 g = a-b+c-d;
            vec2 h = p-a;
            
            float k2 = cross2d( g, f );
            float k1 = cross2d( e, f ) + cross2d( h, g );
            float k0 = cross2d( h, e );

            // if edges are parallel, this is a linear equation
            if( abs(k2)<0.001 )
            {
                res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );
            }
            // otherwise, it's a quadratic
            else
            {
                float w = k1*k1 - 4.0*k0*k2;
                if( w<0.0 ) return vec2(-1.0);
                w = sqrt( w );

                float ik2 = 0.5/k2;
                float v = (-k1 - w)*ik2;
                float u = (h.x - f.x*v)/(e.x + g.x*v);
                
                if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )
                {
                    v = (-k1 + w)*ik2;
                    u = (h.x - f.x*v)/(e.x + g.x*v);
                }
                res = vec2( u, v );
            }
            return res;
        }]

        namespace eval font {
            proc load {name} {
                set csvFd [open "vendor/fonts/$name.csv" r]; set csv [read $csvFd]; close $csvFd
                set glyphInfos [dict create]
                foreach line [split $csv "\n"] {
                set info [lassign [split $line ,] glyph]
                lassign $info advance \
                    planeLeft planeBottom planeRight planeTop \
                    atlasLeft atlasBottom atlasRight atlasTop
                dict set glyphInfos $glyph \
                    [list $advance \
                         [list $planeLeft $planeBottom $planeRight $planeTop] \
                         [list $atlasLeft $atlasBottom $atlasRight $atlasTop]]
                }

                set im [image load "[pwd]/vendor/fonts/$name.png"]
                set gim [Gpu::ImageManager::copyImageToGpu [image rechannel $im 4]]

                return [list $glyphInfos $im $gim]
            }
            proc glyphInfo {font char} { dict get [lindex $font 0] $char }
            proc atlasImage {font} { lindex $font 1 }
            proc gpuAtlasImage {font} { lindex $font 2 }

            namespace export *
            namespace ensemble create
        }
        variable font [font load "PTSans-Regular"]
        variable glyphMsd [Gpu::fn {sampler2D atlas vec4 atlasGlyphBounds vec2 glyphUv} vec4 {
            vec2 atlasUv = mix(atlasGlyphBounds.xw, atlasGlyphBounds.zy, glyphUv);
            return texture(atlas,  vec2(atlasUv.x, 1.0-atlasUv.y));
        }]
        variable median [Gpu::fn {float r float g float b} float {
            return max(min(r, g), min(max(r, g), b));
        }]
        variable glyph [Gpu::pipeline {sampler2D atlas vec2 atlasSize
                                       vec4 atlasGlyphBounds
                                       vec2 a vec2 b vec2 c vec2 d} {
            vec2 vertices[4] = vec2[4](a, b, c, d);
            vec2 v = (2.0*vertices[gl_VertexIndex] - _resolution)/_resolution;
            return vec4(v, 0.0, 1.0);
        } {invBilinear glyphMsd median} {
            vec2 glyphUv = invBilinear(gl_FragCoord.xy, a, b, c, d);
            if( max( abs(glyphUv.x-0.5), abs(glyphUv.y-0.5))>=0.5 ) {
                return vec4(0, 0, 0, 0);
            }
            vec3 msd = glyphMsd(samplers[atlas], atlasGlyphBounds/atlasSize.xyxy, glyphUv).rgb;
            float sd = median(msd.r, msd.g, msd.b);
            float screenPxDistance = 4.5*(sd - 0.5);
            float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
            return mix(vec4(0, 0, 0, 1), vec4(1, 1, 1, 1), opacity);
        }]

        variable line [Gpu::pipeline {vec2 from vec2 to float thickness} {
            vec2 vertices[4] = vec2[4](from - thickness, vec2(from.x - thickness, to.y + thickness), vec2(to.x + thickness, from.y - thickness), to + thickness);
            vec2 v = (2.0*vertices[gl_VertexIndex] - _resolution)/_resolution;
            return vec4(v, 0.0, 1.0);
        } {
            float l = length(to - from);
            vec2 d = (to - from) / l;
            vec2 q = (gl_FragCoord.xy - (from + to)*0.5);
            q = mat2(d.x, -d.y, d.y, d.x) * q;
            q = abs(q) - vec2(l, thickness)*0.5;
            float dist = length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);

            return dist < 0.0 ? vec4(1, 0, 1, 1) : vec4(0, 0, 0, 0);
        }]

        proc start {} { Gpu::drawStart }

        proc stroke {points width color} {
            variable line
            for {set i 0} {$i < [expr {[llength $points] - 1}]} {incr i} {
                set from [lindex $points $i]
                set to [lindex $points [expr $i+1]]
                Gpu::draw $line $from $to $width
            }
        }
        proc circle {x y radius thickness color} {}
        proc text {x0 y0 scale text radians} {
            variable font
            variable glyph
            set fontAtlas [font gpuAtlasImage $font]
            set fontAtlasSize [list [::image width [font atlasImage $font]] \
                                   [::image height [font atlasImage $font]]]
            set em [* $scale 40.0]
            set x $x0; set y $y0
            for {set i 0} {$i < [string length $text]} {incr i} {
                set char [string index $text $i]
                if {$char eq "\n"} {
                    set y [+ $y $em]; set x $x0; continue
                }
                try {
                    set glyphInfo [font glyphInfo $font [scan $char %c]]
                    lassign $glyphInfo advance planeBounds atlasBounds
                    if {$char ne " "} {
                        lassign [lmap v $planeBounds {* $v $em}] left bottom right top
                        set quad [list \
                                      [list [+ $x $left] [- $y $top]] \
                                      [list [+ $x $right] [- $y $top]] \
                                      [list [+ $x $right] [- $y $bottom]] \
                                      [list [+ $x $left] [- $y $bottom]]]
                        # stroke $quad 10 red
                        Gpu::draw $glyph $fontAtlas $fontAtlasSize \
                            $atlasBounds {*}$quad
                    }
                    set x [+ $x [* $advance $em]]
                } on error e { puts stderr $e }
            }
        }
        proc fillTriangle {args} {}
        proc fillQuad {args} {}
        proc fillPolygon {args} {}
        proc image {x y im radians {scale 1.0}} {}

        proc end {} { Gpu::drawEnd; Gpu::poll }
    }

    puts "Display pid: [pid]"

    # TODO: Clean this up. We retract these so that we don't bounce
    # statements back to the main Folk process that it sends us.
    Retract /anyone/ wishes $::thisProcess shares all wishes
    Retract /anyone/ wishes $::thisProcess shares all claims
    Wish $::thisProcess shares statements like \
        [list /someone/ wishes /process/ receives statements like /pattern/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims $::thisProcess has pid /pid/]
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes display runs /command/ on layer /layer/]
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes display runs /command/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims the display time is /displayTime/]

    while true {
        set displayList [list]
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/ on layer /layer/}] {
            lappend displayList [list [dict get $match layer] [dict get $match command]]
        }
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/}] {
            lappend displayList [list 0 [dict get $match command]]
        }

        proc lcomp {a b} {
            set layerA [lindex $a 0]
            set layerB [lindex $b 0]
            if {$layerA == $layerB} {
                expr {[lindex $a 1 0] == "Display::text"}
            } else {
                expr {$layerA - $layerB}
            }
        }

        set displayCommands [lmap sublist [lsort -command lcomp $displayList] {lindex $sublist 1}]
        set renderTime [baretime {
            Display::start
            Display::text 100 100 1.0 "Hello, pworld!" 0
            # Display::stroke {{100 100} {400 100}} 4 red
            foreach command $displayCommands { {*}$command }
            Display::end
        }]

        Commit { Claim the display time is "render $renderTime us ($::stepTime)" }
        Step
    }
}

set ::Display::displayTime none
set ::displayTime none
When the display time is /displayTime/ {
    set ::Display::displayTime $displayTime
    set ::displayTime $displayTime
}
