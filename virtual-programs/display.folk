namespace eval ::Display {
    variable WIDTH
    variable HEIGHT
    variable LAYER 0
    if {$::isLaptop} {
        set WIDTH 640; set HEIGHT 480
    } else {
        regexp {mode "(\d+)x(\d+)"} [exec fbset] -> WIDTH HEIGHT
    }

    proc drawOnTop {func args} {
        set ::Display::LAYER 1
        uplevel [list $func {*}$args]
        set ::Display::LAYER 0
    }

    # Create proxy versions of drawing primitives for the main Folk
    # process (that will forward those draw commands to the display
    # subprocess).
    foreach func {stroke circle text fillTriangle fillQuad fillPolygon} {
        proc $func args {
            set func [lindex [info level 0] 0]
            uplevel [list Wish display runs [list $func {*}$args] on layer $::Display::LAYER]
        }
    }
}

On process Display {
    puts "Display pid: [pid]"

    source pi/Gpu.tcl
    Gpu::init
    Gpu::ImageManager::imageManagerInit

    # TODO: Clean this up. We retract these so that we don't bounce
    # statements back to the main Folk process that it sends us.
    Retract /anyone/ wishes $::thisProcess shares all wishes
    Retract /anyone/ wishes $::thisProcess shares all claims
    Wish $::thisProcess shares statements like \
        [list /someone/ wishes /process/ receives statements like /pattern/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims $::thisProcess has pid /pid/]
    Wish $::thisProcess receives statements like \
        [list /someone/ wishes the display draws /a/ /thing/ with /...options/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims the display time is /displayTime/]

    while true {
        set displayList [list]
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/ on layer /layer/}] {
            lappend displayList [list [dict get $match layer] [dict get $match command]]
        }
        foreach match [Statements::findMatches {/someone/ wishes display runs /command/}] {
            lappend displayList [list 0 [dict get $match command]]
        }

        proc lcomp {a b} {
            set layerA [lindex $a 0]
            set layerB [lindex $b 0]
            if {$layerA == $layerB} {
                expr {[lindex $a 1 0] == "Display::text"}
            } else {
                expr {$layerA - $layerB}
            }
        }

        set displayCommands [lmap sublist [lsort -command lcomp $displayList] {lindex $sublist 1}]
        set renderTime [baretime {
            Gpu::drawStart
            foreach command $displayCommands { {*}$command }
            Gpu::drawEnd
        }]

        Commit { Claim the display time is "render $renderTime us ($::stepTime)" }
        Step
    }
}

set ::Display::displayTime none
set ::displayTime none
When the display time is /displayTime/ {
    set ::Display::displayTime $displayTime
    set ::displayTime $displayTime
}
