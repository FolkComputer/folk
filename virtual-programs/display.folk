namespace eval ::Display {
    variable WIDTH
    variable HEIGHT
    variable LAYER 0
    if {$::isLaptop} {
        set WIDTH 640; set HEIGHT 480
    } else {
        regexp {mode "(\d+)x(\d+)"} [exec fbset] -> WIDTH HEIGHT
    }

    # Create proxy versions of drawing primitives for the main Folk
    # process (that will forward those draw commands to the display
    # subprocess).
    foreach func {stroke circle text fillTriangle fillQuad fillPolygon image} {
        proc $func args {
            set func [lindex [info level 0] 0]
            error "$func has been removed; use GPU wishes/shaders"
        }
    }
}


namespace eval Colors { source "pi/Colors.tcl" }
proc ::getColor {color} {
    if {[info exists Colors::$color]} { return [set Colors::$color] } \
        else { return $Colors::white }
}

Start process "display" {
    puts "Display pid: [pid]"

    source pi/Gpu.tcl
    Gpu::init
    Gpu::ImageManager::imageManagerInit

    # TODO: Share these functions through the database somehow,
    # instead of keeping them in globals.

    set ::rotate [Gpu::fn {vec2 v float a} vec2 {
        float s = sin(a);
        float c = cos(a);
        mat2 m = mat2(c, s, -s, c);
        return m * v;
    }]
    set ::cross2d [Gpu::fn {vec2 a vec2 b} float {
        return a.x*b.y - a.y*b.x;
    }]
    # See https://www.shadertoy.com/view/lsBSDm
    set ::invBilinear [Gpu::fn {vec2 p vec2 a vec2 b vec2 c vec2 d fn ::cross2d} vec2 {
        vec2 res = vec2(-1.0);

        vec2 e = b-a;
        vec2 f = d-a;
        vec2 g = a-b+c-d;
        vec2 h = p-a;

        float k2 = cross2d( g, f );
        float k1 = cross2d( e, f ) + cross2d( h, g );
        float k0 = cross2d( h, e );

        // if edges are parallel, this is a linear equation
        k2 /= k0; k1 /= k0; k0 = 1.0;
        if(  abs(k2)<0.001*abs(k0) )
        {
            res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );
        }
        // otherwise, it's a quadratic
        else
        {
            float w = k1*k1 - 4.0*k0*k2;
            if( w<0.0 ) return vec2(-1.0);
            w = sqrt( w );

            float ik2 = 0.5/k2;
            float v = (-k1 - w)*ik2;
            float u = (h.x - f.x*v)/(e.x + g.x*v);

            if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )
            {
                v = (-k1 + w)*ik2;
                u = (h.x - f.x*v)/(e.x + g.x*v);
            }
            res = vec2( u, v );
        }
        return res;
    }]

    namespace eval Colors { source "pi/Colors.tcl" }
    proc ::getColor {color} {
        if {[info exists Colors::$color]} { return [set Colors::$color] } \
            else { return $Colors::white }
    }

    Wish $::thisProcess receives statements like \
        [list /someone/ wishes the GPU /...anything/]
    Wish $::thisProcess shares statements like \
        [list /someone/ claims the display time is /displayTime/]
    Wish $::thisProcess shares statements like \
        [list /someone/ has error /err/ with info /errorInfo/]

    set ::pipelines [dict create]
    When /wisher/ wishes the GPU compiles pipeline /name/ /source/ {
        try {
            dict set ::pipelines $name [Gpu::pipeline {*}$source]
        } on error e {
            puts stderr $::errorInfo
            Say $wisher has error $e with info $::errorInfo
        }
    }

    while true {
        set ::displayList [dict create] ;# Keys are layer numbers; values are lists of commands
        Step
        foreach match [Statements::findMatches {/someone/ wishes the GPU draws pipeline /name/ with arguments /args/}] {
            dict lappend ::displayList 0 [list Gpu::draw [dict get $::pipelines [dict get $match name]] {*}[dict get $match args]]
        }
        foreach match [Statements::findMatches {/someone/ wishes the GPU draws pipeline /name/ with arguments /args/ layer /layer/}] {
            dict lappend ::displayList [dict get $match layer] \
                [list Gpu::draw [dict get $::pipelines [dict get $match name]] {*}[dict get $match args]]
        }
        foreach match [Statements::findMatches {/someone/ wishes the GPU draws pipeline /name/ with instances /instances/}] {
            set pipeline [dict get $::pipelines [dict get $match name]]
            foreach instance [dict get $match instances] {
                dict lappend ::displayList 0 [list Gpu::draw $pipeline {*}$instance]
            }
        }
        foreach match [Statements::findMatches {/someone/ wishes the GPU draws pipeline /name/ with instances /instances/ layer /layer/}] {
            set layer [dict get $match layer]
            set pipeline [dict get $::pipelines [dict get $match name]]
            foreach instance [dict get $match instances] {
                dict lappend ::displayList $layer [list Gpu::draw $pipeline {*}$instance]
            }
        }

        set renderTime [baretime {
            Gpu::drawStart
            foreach layer [lsort -real [dict keys $::displayList]] {
                set layerDisplayList [dict get $::displayList $layer]
                foreach displayCommand $layerDisplayList {
                    try { {*}$displayCommand } \
                        on error e { puts stderr $::errorInfo }
                }
            }
            Gpu::drawEnd
        }]

        Commit { Claim the display time is "render $renderTime us ($::stepTime)" }
    }
}

set ::Display::displayTime none
set ::displayTime none
When the display time is /displayTime/ {
    set ::Display::displayTime $displayTime
    set ::displayTime $displayTime
}
