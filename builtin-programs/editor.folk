# This makes all keyboards into editors automatically, so a keyboard
# doesn't need to point at a real editor. May choose to change later, or
# exclude keyboards that opt out.
When /k/ is a keyboard with /...opts/ &\
     /nobody/ wishes /k/ does not create an editor {

    Wish tag $k is stabilized

    # Create a synthetic editor above the keyboard page.
    set editor [list $k editor]
    Claim $editor is an editor
    Wish $editor has a canvas
    When $k has resolved geometry /geom/ {
        Claim $editor has resolved geometry $geom
    }
    When the quad library is /quadLib/ & $k has quad /q/ {
        Claim $editor has quad [$quadLib move $q up 105%]
    }
    Claim $k has created editor $editor
    Claim $k is typing into $editor
}
When /k/ is a keyboard with /...opts/ &\
     /nobody/ claims /k/ has created editor /any/ &\
     /k/ points up at /editor/ & /editor/ is an editor with /...opts/ {

    Claim $k is typing into $editor
}

When the program save directory is /programDir/ &\
     the editor utils library is /utils/ {

# TODO: also don't hardcode this?
set margin [list 0.02 0.01]
set defaults { textScale 0.01 }

set codeViewLib [library create codeViewLib {margin defaults} {
    proc getEmAndAdvance {textScale} {
        set em [expr {$textScale * 1}]
        # From NeomatrixCode.csv
        set advance [expr {0.5859375 * $em}]

        return [list $em $advance]
    }

    proc widthAndHeight {resolvedGeom} {
        set tagSize [dict get $resolvedGeom tagSize]
        set left [dict get $resolvedGeom left]
        set right [dict get $resolvedGeom right]
        set top [dict get $resolvedGeom top]
        set bottom [dict get $resolvedGeom bottom]

        set width [expr {$left + $tagSize + $right}]
        set height [expr {$top + $tagSize + $bottom}]

        return [list $width $height]
    }

    # given program and the editor options, figure out how many characters can
    # fit in this editor
    proc viewCharacterSize {resolvedGeom options} {
        variable margin

        set textScale [dict get $options textScale]
        lassign [getEmAndAdvance $textScale] em advance

        lassign [widthAndHeight $resolvedGeom] width height
        set width [expr {$width - [lindex $margin 0]}]
        set height [expr {$height - [lindex $margin 1]}]

        set widthInCharacters [expr {int($width / $advance)}]
        set heightInCharacters [expr {int($height / $em)}]

        return [list $widthInCharacters $heightInCharacters]
    }
}]

When /someone/ claims /view/ is an editor {
    Claim $view is an editor with {*}$defaults
}

# initial setup
When /view/ is an editor with /...options/ {
    # HACK: because we partial match
    if {![info exists options]} { return }

    set options [dict merge $defaults $options]

    # select which program the view is viewing
    When $view points up with length 0.3 at /program/ {
        Hold! -key selected-program:$view \
            Claim $view has selected program $program
    }

    # reset selected program when it's not pointing at anything
    When /nobody/ claims $view points up at /anything/ {
        Hold! -key selected-program:$view {}
    }

    # Load initial text settings if not set
    When /nobody/ claims $view has text settings /...anything/ {
        set textScale [dict get $options textScale]

        Hold! -save -key text-params-of:$view \
            Claim $view has text settings with scale $textScale
    }

    # load in defaults for the view if it hasn't been initialized
    set results [Query! /somebody/ claims $view has cursor /anything/]
    if {[llength $results] == 0} {
        # We need the view's region in geometry to get its size.
        # We then use its size to figure out how many characters we can fit in it,
        # width-wise and height-wise
        When $view has resolved geometry /geom/ {
            Hold! -key view-state-of:$view {
                lassign [$codeViewLib viewCharacterSize $geom $options] widthInCharacters heightInCharacters

                Claim $view has view dimensions [list 0 0 $widthInCharacters $heightInCharacters]
                Claim $view has cursor 0
                Claim $view has max cursor x 0
            }
        }
    }

    # load in initial program code
    When $view has selected program /program/ &\
         /program/ has program code /programCode/ {
        set results [Query! view code for $program is /anything/]
        if {[llength $results] == 0} {
            Hold! -save -key code-for:$program \
                Claim view code for $program is $programCode
        }
    }

    # feedback: show that the editor is not active
    When /nobody/ wishes $view is outlined green {
        Wish $view is outlined blue
    }

    Wish tag $view is stabilized
}

Subscribe: keyboard /keyboard/ claims key /key/ is /keyState/ with /...options/ {
    if {$keyState == "down" && $key == "Control_b"} {
        Notify: print code "# blank"
    }
} 

When /keyboard/ is a keyboard with path /kbPath/ /...anything/ &\
     /keyboard/ is typing into /view/ &\
     /view/ is an editor with /...anything/ &\
     /view/ has selected program /program/ {
    Wish $view is outlined green

    Subscribe: keyboard $kbPath claims key /key/ is /keyState/ with /...options/ {
        ForEach! $view has view dimensions /dims/ &\
                 view code for $program is /code/ &\
                 $view has max cursor x /maxCursorX/ &\
                 $view has cursor /cursor/ &\
                 $view has text settings with /...textOptions/ {
            lassign $dims vpX vpY vpWidth vpHeight

            if {$keyState == "up"} { return }

            # if this is true, the code will remove the hold for program code
            # (triggering a reinitialization)
            set resetCode false

            if {[dict exists $options printable]} {
                lassign [$utils insertText $code $cursor [dict get $options printable]] code cursor maxCursorX
            } else {
                # general editor functionality
                lassign [$utils handleNavigation $key $code $cursor $maxCursorX] cursor maxCursorX
                lassign [$utils handleRemovalAndReturn $key $code $cursor $maxCursorX] code cursor maxCursorX

                # specific editor functionality
                switch $key {
                    Control_r {
                        set resetCode true
                    }
                    Control_s {
                        Notify: save code on view $view
                    }
                    Control_p {
                        Notify: print code $code

                        # Give the user some feedback
                        Hold! -key printed-alert:$view \
                            Wish $view is labelled "Printed!"
                        sleep 0.25
                        Hold! -key printed-alert:$view {}
                    }
                    Control_t {
                        # remove the edited code to restore the program to its original code
                        Hold! -on builtin-programs/programs.folk -key new-code-for:$program {}
                        set resetCode true
                        file delete "$programDir/$program.folk.edited"
                    }
                    Control_underscore {
                        # ctrl and - (zoom out)
                        set geom [dict get [QueryOne! $view has resolved geometry /geom/] geom]

                        set textScale [dict get $textOptions scale]
                        set textScale [/ $textScale 1.1]

                        Hold! -save -key text-params-of:$view \
                            Claim $view has text settings with scale $textScale

                        # overwrite vpWidth and vpHeight as it's used later when updating the viewport
                        set codeViewOptions [dict create textScale $textScale]
                        lassign [$codeViewLib viewCharacterSize $geom $codeViewOptions] vpWidth vpHeight
                    }
                    equal {
                        # Dunno why it registers as equal instead of Control_equal? It works regardless, lol
                        # ctrl and + (zoom in)
                        set geom [dict get [QueryOne! $view has resolved geometry /geom/] geom]

                        set textScale [dict get $textOptions scale]
                        set textScale [* $textScale 1.1]

                        Hold! -save -key text-params-of:$view \
                            Claim $view has text settings with scale $textScale

                        # overwrite vpWidth and vpHeight as it's used later when updating the viewport
                        set codeViewOptions [dict create textScale $textScale]
                        lassign [$codeViewLib viewCharacterSize $geom $codeViewOptions] vpWidth vpHeight
                    }
                }
            }

            if {$resetCode} {
                set cursor 0
                set maxCursorX 0

                # remove the edited code to restore the program to its original code
                Hold! -on builtin-programs/programs.folk -key new-code-for:$program {}
                file delete "$programDir/$program.folk.edited"

                Hold! -keep 12ms -save -key code-for:$program {
                    When $program has program code /originalCode/ {
                        Claim view code for $program is $originalCode
                    }
                }
            } else {
                Hold! -keep 12ms -save -key code-for:$program \
                    Claim view code for $program is $code
            }

            lassign [$utils cursorToXy $code $cursor] cursorX cursorY
            if {$cursorX < $vpX} { set vpX $cursorX }
            if {$cursorX >= $vpX + $vpWidth} {
                set vpX [expr {$cursorX - $vpWidth}]
            }
            if {$cursorY < $vpY} { set vpY $cursorY }
            if {$cursorY >= $vpY + $vpHeight - 1} {
                set vpY [expr {$cursorY - $vpHeight + 1}]
            }

            Hold! -key view-state-of:$view {
                Claim $view has view dimensions [list $vpX $vpY $vpWidth $vpHeight]
                Claim $view has cursor $cursor
                Claim $view has max cursor x $maxCursorX
            }
        }
    }
}

Subscribe: save code on view /view/ {
    ForEach! /view/ has selected program /program/ &\
             view code for /program/ is /programCode/ {
        Hold! -on builtin-programs/programs.folk -key new-code-for:$program \
            Wish program $program is replaced with \
            code $programCode editedTime [clock seconds]

        set fp [open "$programDir/[set program].folk.edited" w]
        puts -nonewline $fp $programCode
        close $fp

        # Give the user some feedback
        Hold! -key saved-alert:$view \
            Wish $view is labelled "Saved!"
        sleep 0.25
        Hold! -key saved-alert:$view {}
    }
}

# calculate cursor position
When /view/ is an editor with /...anything/ &\
     /view/ has cursor /cursor/ &\
     /view/ has selected program /program/ &\
     view code for /program/ is /code/ &\
     /view/ has view dimensions /dims/ &\
     /view/ has text settings with /...textOptions/ {
    lassign $dims vpX vpY vpWidth vpHeight

    lassign [$utils cursorToXy $code $cursor] cursorX cursorY

    set textScale [dict get $textOptions scale]
    lassign [$codeViewLib getEmAndAdvance $textScale] em advance

    set offsetX [expr {($cursorX - $vpX) * $advance}]
    set offsetY [expr {($cursorY - $vpY) * $em}]

    Claim $view has cursor position [list $offsetX $offsetY]
}

# Draw text and cursor
When /view/ is an editor with /...anything/ &\
     /view/ has view dimensions /dims/ &\
     /view/ has resolved geometry /geom/ &\
     /view/ has text settings with /...textOptions/ {
    # vp = viewport
    lassign $dims vpX vpY vpWidth vpHeight

    set textScale [dict get $textOptions scale]
    lassign [$codeViewLib getEmAndAdvance $textScale] em advance

    When $view has selected program /program/ &\
         view code for /program/ is /code/ &\
         $view has cursor position /cursorPos/ {
        set lineCount [- [llength [split $code "\n"]] $vpY]
        set lineNumbers [$utils lineNumberView $vpY $lineCount]
        Wish to draw text onto $view with \
            position [vec2 sub $margin [list [* $em 1.8] 0.0]] \
            text $lineNumbers \
            scale $textScale anchor topleft font NeomatrixCode

        set text [$utils applyTextViewport $code $vpX $vpY $vpWidth $vpHeight]
        set pos $margin
        Wish to draw text onto $view with \
            position $pos text $text \
            scale $textScale anchor topleft font NeomatrixCode

        set p1 [vec2 add $cursorPos $pos]
        set p2 [vec2 add $p1 [list 0 [expr {$em * 1.2}]]]
        set s [expr {$textScale / 6}]
        Wish to draw a circle onto $view with center $p1 radius $s thickness 0 color green filled true
        Wish to draw a line onto $view with points [list $p1 $p2] width $s color green
    }
}


# end of library code
}
