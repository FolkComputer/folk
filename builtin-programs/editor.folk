# This makes all keyboards into editors automatically, so a keyboard
# doesn't need to point at a real editor. May choose to change later, or
# exclude keyboards that opt out.
When /k/ is a keyboard with /...opts/ &\
     /nobody/ wishes /k/ does not create an editor {

    Wish tag $k is stabilized

    # Create a synthetic editor above the keyboard page.
    set editor [list $k editor]
    Claim $editor is an editor
    Wish $editor has a canvas
    When $k has resolved geometry /geom/ {
        Claim $editor has resolved geometry $geom
    }
    When the quad library is /quadLib/ & $k has quad /q/ {
        Claim $editor has quad [$quadLib move $q up 105%]
    }
    Claim $k has created editor $editor
    Claim $k is typing into $editor
}
When /k/ is a keyboard with /...opts/ &\
     /nobody/ claims /k/ has created editor /any/ &\
     /k/ points up at /editor/ & /editor/ is an editor with /...opts/ {

    Claim $k is typing into $editor
}

When the program save directory is /programDir/ &\
     the editor utils library is /utils/ {

# TODO: also don't hardcode this?
set margin [list 0.01 0.01 0.01 0.02] ;# CSS order (top, right, bottom, left)
set defaults { textScale 0.01 }

set editorLib [library create editorLib {margin defaults} {
    proc getAdvance {em} {
        # From NeomatrixCode.csv
        return $(0.5859375 * $em)
    }

    proc widthAndHeight {resolvedGeom} {
        set tagSize [dict get $resolvedGeom tagSize]
        set left [dict get $resolvedGeom left]
        set right [dict get $resolvedGeom right]
        set top [dict get $resolvedGeom top]
        set bottom [dict get $resolvedGeom bottom]

        set width $($left + $tagSize + $right)
        set height $($top + $tagSize + $bottom)

        return [list $width $height]
    }

    # given program and the editor options, figure out how many characters can
    # fit in this editor
    proc editorSizeInCharacters {resolvedGeom options} {
        variable margin

        set textScale [dict get $options scale]
        set advance [getAdvance $textScale]

        lassign [widthAndHeight $resolvedGeom] width height
        set width $($width - [lindex $margin 3] - [lindex $margin 1])
        set height $($height - [lindex $margin 0] - [lindex $margin 2])

        set widthInCharacters $(int($width / $advance))
        set heightInCharacters $(int($height / $textScale))

        return [list $widthInCharacters $heightInCharacters]
    }
}]

When /someone/ claims /editor/ is an editor {
    Claim $editor is an editor with {*}$defaults
}

When /editor/ is an editor with /...options/ {
    # HACK: because we partial match
    if {![info exists options]} { return }

    set options [dict merge $defaults $options]

    Wish tag $editor is stabilized

    # Select which program the editor is viewing
    When $editor points up with length 0.3 at /program/ {
        Claim editor $editor has selected program $program
    }

    # Initial setup
    # Load initial text settings if not set
    When /nobody/ claims editor $editor has font options /...anything/ {
        set textScale [dict get $options textScale]
        # Don't `Hold! -save` here, so if previous options were saved, they'll load correctly.
        Claim editor $editor has font options with scale $textScale
    }

    # We need the editor's resolved geometry to get its size.
    # We then use its size to figure out how many characters we can fit in it,
    # width-wise and height-wise.
    When $editor has resolved geometry /geom/ &\
         editor $editor has font options with /...options/  {
        Claim editor $editor has viewport size [$editorLib editorSizeInCharacters $geom $options]
    }

    # Load in defaults for the editor if it hasn't been initialized
    set results [Query! /somebody/ claims editor $editor has cursor /anything/]
    if {[llength $results] == 0} {
        Hold! -key editor-state-of:$editor {
            Claim editor $editor has cursor 0
            Claim editor $editor has max cursor x 0
            Claim editor $editor has viewport position [list 0 0]
        }
    }

    # Load in initial program code (note, this buffer is shared between
    # all editor instances)
    When $editor has selected program /program/ &\
         /program/ has program code /programCode/ {
        set results [Query! editor buffer for $program is /anything/]
        if {[llength $results] == 0} {
            Hold! -save -key buffer-for:$program \
                Claim editor buffer for $program is $programCode
        }
    }

    # Feedback: show that the editor is not active
    When /nobody/ wishes $editor is outlined green {
        Wish $editor is outlined blue
    }
}

Subscribe: keyboard /keyboard/ claims key Control_b is down with /...options/ {
    Notify: print code "# blank"
}

When /keyboard/ is a keyboard with path /kbPath/ /...anything/ &\
     /keyboard/ is typing into /editor/ &\
     /editor/ is an editor with /...anything/ &\
     editor /editor/ has selected program /program/ {
    Wish $editor is outlined green

    Subscribe: keyboard $kbPath claims key /key/ is /keyState/ with /...options/ {
        ForEach! editor $editor has viewport position /vpPos/ &\
                 editor /editor/ has viewport size /vpSize/ &\
                 editor buffer for $program is /code/ &\
                 editor $editor has max cursor x /maxCursorX/ &\
                 editor $editor has cursor /cursor/ &\
                 editor $editor has font options with /...textOptions/ {
            lassign $vpPos vpX vpY
            lassign $vpSize vpWidth vpHeight

            if {$keyState == "up"} { return }

            # if this is true, the buffer will remove the hold for program code
            # (triggering a reinitialization)
            set resetBuffer false

            if {[dict exists $options printable]} {
                lassign [$utils insertText $code $cursor [dict get $options printable]] code cursor maxCursorX
            } else {
                # general editor functionality
                lassign [$utils handleNavigation $key $code $cursor $maxCursorX] cursor maxCursorX
                lassign [$utils handleRemovalAndReturn $key $code $cursor $maxCursorX] code cursor maxCursorX

                # specific editor functionality
                switch $key {
                    Control_r {
                        set resetBuffer true
                    }
                    Control_s {
                        Notify: save code on editor $editor
                    }
                    Control_p {
                        Notify: print code $code

                        # Give the user some feedback
                        Hold! -key printed-alert:$editor \
                            Wish $editor is labelled "Printed!"
                        sleep 0.25
                        Hold! -key printed-alert:$editor {}
                    }
                    Control_underscore {
                        # ctrl and - (zoom out)
                        set textScale [dict get $textOptions scale]
                        set textScale [/ $textScale 1.1]

                        Hold! -save -key font-options-of:$editor \
                            Claim editor $editor has font options with scale $textScale
                    }
                    equal {
                        # Dunno why it registers as equal instead of Control_equal? It works regardless, lol
                        # ctrl and + (zoom in)
                        set textScale [dict get $textOptions scale]
                        set textScale [* $textScale 1.1]

                        Hold! -save -key font-options-of:$editor \
                            Claim editor $editor has font options with scale $textScale
                    }
                }
            }

            if {$resetBuffer} {
                set cursor 0
                set maxCursorX 0

                # remove the edited code to restore the program to its original code
                Hold! -on builtin-programs/programs.folk -key new-code-for:$program {}
                file delete "$programDir/$program.folk.edited"

                Hold! -keep 12ms -save -key buffer-for:$program {
                    When $program has program code /originalCode/ {
                        Claim editor buffer for $program is $originalCode
                    }
                }
            } else {
                Hold! -keep 12ms -save -key buffer-for:$program \
                    Claim editor buffer for $program is $code
            }

            lassign [$utils cursorToXy $code $cursor] cursorX cursorY
            # Be sure to have at least two characters on the left, so we can
            # see what we're removing.
            if {[- $cursorX 2] < $vpX} {
                set vpX [max 0 [- $cursorX 2]]
            }
            if {$cursorX >= $vpX + $vpWidth} {
                set vpX $($cursorX - $vpWidth)
            }
            if {$cursorY < $vpY} { set vpY $cursorY }
            if {$cursorY >= $vpY + $vpHeight - 1} {
                set vpY $($cursorY - $vpHeight + 1)
            }

            Hold! -keep 12ms -key editor-state-of:$editor {
                Claim editor $editor has viewport position [list $vpX $vpY]
                Claim editor $editor has cursor $cursor
                Claim editor $editor has max cursor x $maxCursorX
            }
        }
    }
}

Subscribe: save code on editor /editor/ {
    ForEach! editor $editor has selected program /program/ &\
             editor buffer for /program/ is /programCode/ {
        Hold! -on builtin-programs/programs.folk -key new-code-for:$program \
            Wish program $program is replaced with \
            code $programCode editedTime [clock seconds]

        set fp [open "$programDir/[set program].folk.edited" w]
        puts -nonewline $fp $programCode
        close $fp

        # Give the user some feedback
        Hold! -key saved-alert:$editor \
            Wish $editor is labelled "Saved!"
        sleep 0.25
        Hold! -key saved-alert:$editor {}
    }
}

# calculate cursor position
When /editor/ is an editor with /...anything/ &\
     editor /editor/ has cursor /cursor/ &\
     editor /editor/ has selected program /program/ &\
     editor buffer for /program/ is /code/ &\
     editor /editor/ has viewport position /vpPos/ &\
     editor /editor/ has font options with /...textOptions/ {
    lassign $vpPos vpX vpY

    lassign [$utils cursorToXy $code $cursor] cursorX cursorY

    set textScale [dict get $textOptions scale]
    set advance [$editorLib getAdvance $textScale]

    set offsetX $(($cursorX - $vpX) * $advance)
    set offsetY $(($cursorY - $vpY) * $textScale)

    Claim editor $editor has cursor position [list $offsetX $offsetY]
}

# Draw text and cursor
When /editor/ is an editor with /...anything/ &\
     editor /editor/ has viewport position /vpPos/ &\
     editor /editor/ has viewport size /vpSize/ &\
     editor /editor/ has font options with /...fontOptions/ {
    lassign $vpPos vpX vpY
    lassign $vpSize vpWidth vpHeight

    set textScale [dict get $fontOptions scale]
    set advance [$editorLib getAdvance $textScale]

    When editor $editor has selected program /program/ &\
         editor buffer for /program/ is /code/ &\
         editor $editor has cursor position /cursorPos/ {
        set lineCount [- [llength [split $code "\n"]] $vpY]
        set lineNumbers [$utils lineNumberView $vpY $lineCount]

        set marginLeft [lindex $margin 3]
        set numberX [- $marginLeft [min [* $textScale 1.2] [* $marginLeft 0.7]]]
        Wish to draw text onto $editor with \
            position [list $numberX [lindex $margin 0]] \
            text $lineNumbers \
            scale $textScale anchor topleft font NeomatrixCode

        set text [$utils applyTextViewport $code $vpX $vpY $vpWidth $vpHeight]
        set pos [list [lindex $margin 3] [lindex $margin 0]]
        Wish to draw text onto $editor with \
            position $pos text $text \
            scale $textScale anchor topleft font NeomatrixCode

        set p1 [vec2 add $cursorPos $pos]
        set p2 [vec2 add $p1 [list 0 $($textScale * 1.2)]]
        set s [/ $textScale 6]
        Wish to draw a circle onto $editor with center $p1 radius $s thickness 0 color green filled true
        Wish to draw a line onto $editor with points [list $p1 $p2] width $s color green
    }
}


# end of library code
}
