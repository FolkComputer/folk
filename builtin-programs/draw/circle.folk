Wish the GPU compiles pipeline "circle" {
    {vec2 viewport mat3 surfaceToClip
     vec2 center float radius float thickness vec4 color int filled} {
        float r = radius + thickness;
        vec2 vertices[6] = vec2[6](
            center - r,
            vec2(center.x + r, center.y - r),
            vec2(center.x - r, center.y + r),

            vec2(center.x + r, center.y - r),
            center + r,
            vec2(center.x - r, center.y + r)
        );
        vec3 v = surfaceToClip * vec3(vertices[gl_VertexIndex], 1.0);
        return vec4(v.xy/v.z, 0.0, 1.0);
    } {
        vec2 clipXy = (gl_FragCoord.xy / viewport) * 2.0 - 1.0;
        vec3 surfaceXy = inverse(surfaceToClip) * vec3(clipXy, 1.0);
        surfaceXy /= surfaceXy.z;

        float dist = length(surfaceXy.xy - center) - radius;
        if (filled == 1) {
            return (dist < thickness) ? color : vec4(0, 0, 0, 0);
        } else {
            return (dist < thickness && dist > 0.0) ? color : vec4(0, 0, 0, 0);
        }
    }
}

When the color map is /colorMap/ &\
     /p/ has canvas /id/ with /...wiOptions/ &\
     /p/ has canvas projection /surfaceToClip/ &\
     /someone/ wishes to draw a circle onto /p/ with \
         radius /radius/ thickness /thickness/ color /color/ \
         center /center?/ x /x?/ y /y?/ filled /filled?/ {

    if {![info exists center]} { set center [list $x $y] }
    set color [dict getdef $colorMap $color $color]
    if {![info exists filled]} { set filled false }

    set wiResolution [list [dict get $wiOptions width] [dict get $wiOptions height]]
    Wish the GPU draws pipeline "circle" onto canvas $id with arguments \
        [list $wiResolution $surfaceToClip \
             $center $radius $thickness $color [expr {$filled eq false ? 0 : 1}]]
}
