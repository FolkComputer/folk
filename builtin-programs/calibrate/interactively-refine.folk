# interactively-refine.folk --
#
#     Implements table-oriented projector-camera end-to-end
#     calibration step.
#

When the pose library is /poseLib/ {

set cc [C]
$cc extend $poseLib

$cc cflags -I./vendor/apriltag
$cc endcflags ./vendor/apriltag/build/libapriltag.so

$cc include <apriltag_pose.h>
$cc include <common/homography.h>
$cc include <common/matd.h>

# From https://courses.cs.duke.edu/cps274/fall13/notes/rodrigues.pdf:
fn rotationMatrixToRotationVector {R} {
    set A [scale 0.5 [sub $R [transpose $R]]]
    set rho [list [getelem $A 2 1] \
                 [getelem $A 0 2] \
                 [getelem $A 1 0]]
    set s [norm $rho]
    set c [expr {([getelem $R 0 0] + [getelem $R 1 1] + [getelem $R 2 2] - 1) / 2}]

    # If s = 0 and c = 1:
    if {abs($s) < 0.0001 && abs($c - 1) < 0.0001} {
        return {0 0 0}
    }
    # If s = 0 and c = -1:
    if {abs($s) < 0.0001 && abs($c - (-1)) < 0.0001} {
        # let v = a nonzero column of R + I
        set v [getcol [add $R [mkIdentity 3]] 0]
        set u [scale [/ 1.0 [norm $v]] $v]
        set r [scale 3.14159 $u]
        if {abs([norm $r] - 3.14159) < 0.0001 &&
            ((abs([getelem $r 0]) < 0.0001 &&
              abs([getelem $r 1]) < 0.0001 &&
              [getelem $r 2] < 0) ||
             (abs([getelem $r 0]) < 0.0001 &&
              [getelem $r 1] < 0) ||
             ([getelem $r 0] < 0))} {
            return [scale -1 $r]
        } else {
            return $r
        }
    }

    set u [scale [/ 1.0 $s] $rho]
    set theta $(atan2($s, $c))
    return [scale $theta $u]
}

fn rotationVectorToRotationMatrix {r} {
    set theta [norm $r]
    if {abs($theta) < 0.0001} {
        return [mkIdentity 3]
    }
    set u [scale [/ 1.0 $theta] $r]
    set ux [list [list 0                       [* -1.0 [getelem $u 2]] [getelem $u 1]] \
                 [list [getelem $u 2]          0                       [* -1.0 [getelem $u 0]]] \
                 [list [* -1.0 [getelem $u 1]] [getelem $u 0]          0]]
    return [add [scale $(cos($theta)) [mkIdentity 3]] \
                [add [scale [expr {1.0 - cos($theta)}] \
                          [matmul $u [transpose $u]]] \
                     [scale $(sin($theta)) $ux]]]
}

# Used to generate the initial guess in estimateBoardPose. Kind of
# misuses the AprilTag pose estimation code to do an entire-board
# estimate (which includes multiple tags).
$cc proc baseEstimateBoardPose {Intrinsics cameraIntrinsics
                                double cameraWidth double cameraHeight
                                double[][2] modelTagCorners double[][2] detectedTagCorners
                                int cornersCount} TagPose {
    // We'll fill this in with a .H that represents all the corners.
    apriltag_detection_t det;

    // The normal tag .H homography goes from (+/-1, +/-1) to the
    // camera-detected tag corners.  We will instead create a
    // board-wide homography from board meters position to the
    // camera-detected tag corners.
    float correspondences[cornersCount][4];
    for (int i = 0; i < cornersCount; i++) {
        correspondences[i][0] = modelTagCorners[i][0];
        correspondences[i][1] = modelTagCorners[i][1];

        double undistortedDetectedTagCorners[2];
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            detectedTagCorners[i],
                            undistortedDetectedTagCorners);
        correspondences[i][2] = undistortedDetectedTagCorners[0];
        correspondences[i][3] = undistortedDetectedTagCorners[1];
    }
    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]), .size = cornersCount, .alloc = cornersCount,
        .data = (char*) correspondences
    };
    det.H = homography_compute(&correspondencesArr,
                               HOMOGRAPHY_COMPUTE_FLAG_SVD);
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = 2.0, // scale factor = 1.0
        .fx = cameraIntrinsics.fx, .fy = cameraIntrinsics.fy,
        .cx = cameraIntrinsics.cx, .cy = cameraIntrinsics.cy
    };
    apriltag_pose_t pose;
    estimate_pose_for_tag_homography(&info, &pose);

    matd_destroy(det.H);

    TagPose ret;
    memcpy(ret.R, pose.R->data, sizeof(ret.R));
    memcpy(ret.t, pose.t->data, sizeof(ret.t));

    matd_destroy(pose.R);
    matd_destroy(pose.t);
    return ret;
}
$cc proc estimateBoardPose {Intrinsics cameraIntrinsics
                            double cameraWidth double cameraHeight
                            double[][2] modelTagCorners double[][2] detectedTagCorners
                            int cornersCount} TagPose {
    TagPose baseBoardPose =
        baseEstimateBoardPose(cameraIntrinsics, cameraWidth, cameraHeight,
                              modelTagCorners, detectedTagCorners, cornersCount);

    double wX[cornersCount][3];
    double x[cornersCount][2];
    for (int i = 0; i < cornersCount; i++) {
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            detectedTagCorners[i],
                            x[i]);
        // Apply intrinsics to go from pixel coordinates to normalized
        // image-plane coordinates:
        x[i][0] = (x[i][0] - cameraIntrinsics.cx) / cameraIntrinsics.fx;
        x[i][1] = (x[i][1] - cameraIntrinsics.cy) / cameraIntrinsics.fy;

        wX[i][0] = modelTagCorners[i][0];
        wX[i][1] = modelTagCorners[i][1];
        wX[i][2] = 0;
    }

    matd_t* cRw = matd_create_data(3, 3, (double*) baseBoardPose.R);
    matd_t* ctw = matd_create_data(3, 1, (double*) baseBoardPose.t);

    poseGaussNewton(wX, x, cornersCount, &cRw, &ctw);

    TagPose ret;
    memcpy(ret.R, cRw->data, sizeof(ret.R));
    memcpy(ret.t, ctw->data, sizeof(ret.t));

    matd_destroy(cRw);
    matd_destroy(ctw);
    return ret;
}

$cc cflags -I./vendor/cmpfit
$cc include "mpfit.h"
$cc include "mpfit.c"
$cc proc funct {int m int n double* x
                double* fvec double** dvec
                void* userdata} int {
    Jim_Obj* jimFunct = (Jim_Obj*) userdata;

    // Build xList from x[0..n-1].
    Jim_Obj* xList = Jim_NewListObj(interp, NULL, 0);
    for (int i = 0; i < n; i++) {
        Jim_ListAppendElement(interp, xList, Jim_NewDoubleObj(interp, x[i]));
    }

    // Expand jimFunct (already an arg list) and append xList, then eval.
    int prefixLen = Jim_ListLength(interp, jimFunct);
    Jim_Obj* objv[prefixLen + 1];
    for (int i = 0; i < prefixLen; i++) {
        __ENSURE_OK(Jim_ListIndex(interp, jimFunct, i, &objv[i], JIM_NONE));
    }
    objv[prefixLen] = xList;
    __ENSURE_OK(Jim_EvalObjVector(interp, prefixLen + 1, objv));

    // Unpack result list into fvec[0..m-1].
    Jim_Obj* result = Jim_GetResult(interp);
    FOLK_ENSURE(Jim_ListLength(interp, result) == m);
    for (int i = 0; i < m; i++) {
        Jim_Obj* elem;
        __ENSURE_OK(Jim_ListIndex(interp, result, i, &elem, JIM_NONE));
        __ENSURE_OK(Jim_GetDouble(interp, elem, &fvec[i]));
    }
    return 0;
}
$cc proc fit {int m int n double[] x Jim_Obj* jimFunct} Jim_Obj* {
    mp_result result = {0};

    mp_par pars[18];  // One for each parameter
    memset(pars, 0, sizeof(pars));
    // Set larger relative step sizes
    for (int i = 0; i < 18; i++) {
        pars[i].relstep = 1e-3;  // Default is ~1e-7, try 1e-3 to 1e-2
    }

    mpfit(funct,
          m, // Number of residuals.
          n, x, // Parameters to optimize.
          pars, NULL, (void*) jimFunct, &result);
    fprintf(stderr, "next niter=%d, nfev=%d, status=%d, pid=%d ;\n    orignorm=%f, bestnorm=%f\n", result.niter, result.nfev, result.status, gettid(),
            result.orignorm, result.bestnorm);

    Jim_Obj* xList = Jim_NewListObj(interp, NULL, 0);
    for (int i = 0; i < n; i++) {
        Jim_ListAppendElement(interp, xList, Jim_NewDoubleObj(interp, x[i]));
    }
    return xList;
}

set boardLib [$cc compile]

When the AprilTag detector maker is /makeAprilTagDetector/ &\
     the calibration model library is /modelLib/ &\
     the calibration matrix library is /matLib/ &\
     the printed calibration tag size is /printedSideLengthMm/ mm &\
     camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     /someone/ wishes to interactively refine calibration {

    When /someone/ wishes to draw refining model /model/ onto detected tags /tags/ \
                             using calibration /calibration/ &\
         the collected results for [list /someone/ wishes to draw refining label /label/] \
             are /labels/ {
        package require linalg
        namespace import ::math::linearalgebra::matmul \
            ::math::linearalgebra::add

        set cameraIntrinsics [dict get $calibration camera intrinsics]
        set displayIntrinsics [dict get $calibration projector intrinsics]

        set modelPrintedTagCorners [list]
        set detectedPrintedTagCorners [list]
        dict for {id tag} $tags {
            if {![$modelLib isPrintedTag $id]} { continue }

            lappend modelPrintedTagCorners {*}[dict get $model $id p]
            lappend detectedPrintedTagCorners {*}[dict get $tag p]
        }
        if {[llength $detectedPrintedTagCorners] < 4} { return }

        # Do a single board-wide pose estimate.
        set pose [$boardLib estimateBoardPose $cameraIntrinsics \
                      $cameraWidth $cameraHeight \
                      $modelPrintedTagCorners $detectedPrintedTagCorners \
                      [llength $detectedPrintedTagCorners]]
        set R_boardToCamera [dict get $pose R]
        set t_boardToCamera [dict get $pose t]

        set R_cameraToDisplay [dict get $calibration R_cameraToProjector]
        set t_cameraToDisplay [dict get $calibration t_cameraToProjector]

        # Compute model-to-display homography from pose via correspondences
        # of the detected printed tag corners:
        set correspondences [lmap mc $modelPrintedTagCorners {
            set v [list {*}$mc 0]
            set camPt [add [matmul $R_boardToCamera $v] $t_boardToCamera]
            set dispPt [add [matmul $R_cameraToDisplay $camPt] $t_cameraToDisplay]
            set dp [$poseLib project $displayIntrinsics \
                        $displayWidth $displayHeight $dispPt]
            list {*}$mc {*}$dp
        }]
        set H_modelToDisplay [$matLib estimateHomography $correspondences]

        Wish to draw calibration model $model \
            using model-to-display homography $H_modelToDisplay \
            with message [join [lmap r $labels {dict get $r label}] " "]
    }

    fn AwaitNextCameraFrame! {frameTimestampVar} {
        upvar $frameTimestampVar frameTimestamp
        set prevFrameTimestamp $frameTimestamp
        while {$frameTimestamp <= $prevFrameTimestamp} {
            after 8

            set frames [Query! camera $camera has frame /frame/ at timestamp /frameTimestamp/]
            if {[llength $frames] < 1} { continue }
            set frameResult [lindex $frames end]
            set frameTimestamp $frameResult(frameTimestamp)
        }
        return $frameResult(frame)
    }

    set intrNames {fx cx fy cy k1 k2}
    # Calibration -> flat list of 18 parameters `x`.
    fn unravel {calibration} {
        list \
            {*}[lmap n $intrNames { dict get $calibration camera intrinsics $n }] \
            {*}[lmap n $intrNames { dict get $calibration projector intrinsics $n }] \
            {*}[rotationMatrixToRotationVector [dict get $calibration R_cameraToProjector]] \
            {*}[dict get $calibration t_cameraToProjector]
    }
    # Flat list of 18 parameters `x` -> update calibration.
    fn ravelInto {calibrationVar x} {
        upvar $calibrationVar calibration
        foreach n $intrNames v [lrange $x 0 5] {
            dict set calibration camera intrinsics $n $v
        }
        foreach n $intrNames v [lrange $x 6 11] {
            dict set calibration projector intrinsics $n $v
        }
        dict set calibration R_cameraToProjector \
            [rotationVectorToRotationMatrix [lrange $x 12 14]]
        dict set calibration t_cameraToProjector [lrange $x 15 17]
    }

    fn makeAprilTagDetector
    set tagDetector [makeAprilTagDetector "tagStandard52h13" 2.0 3]

    package require linalg
    namespace import ::math::linearalgebra::scale \
        ::math::linearalgebra::sub ::math::linearalgebra::add \
        ::math::linearalgebra::transpose ::math::linearalgebra::getelem \
        ::math::linearalgebra::norm ::math::linearalgebra::getcol \
        ::math::linearalgebra::mkIdentity ::math::linearalgebra::matmul

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    set model0 [$modelLib scaleModel [$modelLib unitModel] \
                    $printedSideLengthM]

    set calibration [dict get [QueryOne! the calibration is /calibration/] calibration]
    # The actual refinement process. We will have the user hold up the
    # board in a sequence of whatever poses they want. When the board
    # is stable for a couple seconds, we say that's a pose, and we
    # start refinement with respect to that pose.
    #
    # Once the calibration is refined with respect to the pose, the
    # user can move the board to a different pose. They can stop
    # whenever they want.
    set poses [list]
    set frameTimestamp 0
    while true {
        set frame [AwaitNextCameraFrame! frameTimestamp]
        set aprilTime [time {
            set detectedTags0 [dict create]
            foreach tag [$tagDetector detect $frame] {
                dict set detectedTags0 $tag(id) $tag
            }
        }]
        if {[dict size $detectedTags0] < 8} {
            puts stderr "Not enough tags: [dict size $detectedTags0]"
            continue
        }

        # Do our best (given current calibration) to draw projected
        # tags on the board to match the printed tags. We wouldn't
        # really need this, I guess, except this is also what'll
        # display the label (set next).
        Hold! -keep 32ms Wish to draw refining model $model0 \
            onto detected tags $detectedTags0 \
            using calibration $calibration

        # We don't want to start a new pose right on top of a pose we
        # just recorded. The user should have to move the board a bit.
        if {[llength $poses] > 0} {
            # Are the seen $tags far enough from previous pose's
            # $tags?
            set lastPose [lindex $poses end]
            if {[$modelLib meanTagsDifference $detectedTags0 $lastPose(detectedTags0)] < 50} {
                # Not far enough from previous pose.
                Hold! -key label Wish to draw refining label "Move board farther!"
                continue
            }
        }

        # We want the user to keep the board still, so don't start
        # refining over a pose until it's been stable for a few
        # seconds.
        if {![info exists prevDetectedTags0] ||
            [set diff [$modelLib meanTagsDifference $detectedTags0 $prevDetectedTags0]] > 5} {
            # Not close enough to previous frame for us to trust
            # that the board is held still. Reset.
            set prevDetectedTags0 $detectedTags0
            set prevDetectedTags0Timestamp $frameTimestamp

            set diffLabel ""
            if {[info exists diff]} { set diffLabel "(moved $diff pixels)" }
            Hold! -key label Wish to draw refining label \
                "Keep still! $diffLabel"
            continue
        } elseif {$frameTimestamp - $prevDetectedTags0Timestamp < 4} {
            set timeSincePrevDetectedTags0 $($frameTimestamp - $prevDetectedTags0Timestamp)
            Hold! -key label Wish to draw refining label \
                "Keep still for $(round((4.0 - $timeSincePrevDetectedTags0))) sec"
            continue
        }
        Hold! -key label Wish to draw refining label \
            "Keep still. Refining..."

        set idealCameraCorners [apply {{} {
            upvar modelLib modelLib; upvar matLib matLib
            upvar model0 model0
            upvar detectedTags0 detectedTags0

            # Collect correspondences: list of {x0 y0 x1 y1}, pairs of
            # detected model corner & camera corner for all printed
            # tags seen this frame.
            set printedCorrespondences [list]
            dict for {id tag} $detectedTags0 {
                if {![$modelLib isPrintedTag $id]} { continue }
                foreach modelCorner [dict get $model0 $id p] \
                        camCorner [dict get $tag p] {
                    lappend printedCorrespondences \
                        [list {*}$modelCorner {*}$camCorner]
                }
            }
            if {[llength $printedCorrespondences] < 4} { continue }

            # H_mc: homography from model xy to camera xy.
            # Used to find ideal camera positions for projected tags.
            set H_mc [$matLib estimateHomography $printedCorrespondences]

            # idealCameraCorners: tag id -> list of 4 {x y}.
            set idealCameraCorners [dict create]
            dict for {id modelTag} $model0 {
                if {![$modelLib isProjectedTag $id]} { continue }
                dict set idealCameraCorners $id \
                    [lmap modelCorner $modelTag(p) {
                        $matLib applyHomography $H_mc $modelCorner
                    }]
            }
            return $idealCameraCorners
        }}]

        set pose [dict create detectedTags0 $detectedTags0 \
                      idealCameraCorners $idealCameraCorners]

        # 2 residuals (dx, dy) per projected tag corner.
        set projectedTagsCount [$modelLib countProjectedTags $model0]
        set m [expr {$projectedTagsCount * 4 * 2}]

        # Refine the parameters with respect to this pose. This will
        # block for a while and run the interior function a lot (10
        # times? 100 times?).
        set version 0
        set x0 [unravel $calibration]
        puts stderr "x0=($x0)"
        set x [$boardLib fit $m [llength $x0] $x0 [fn funct {x} {
            # This block gets run on each iteration of the
            # Levenberg-Marquardt optimization loop.

            puts stderr "ITER ------"
            puts stderr "Test x=($x)"

            ravelInto calibration $x
            incr version
            set model [$modelLib updateModelVersion $model0 $version]

            # This will cause the new model version to be rendered by
            # the other process. Note that this assumes that the user
            # hasn't moved the calibration board from the pose $tags0.
            Hold! Wish to draw refining model $model \
                onto detected tags $detectedTags0 \
                using calibration $calibration

            # Loop until we see the version we just wished to draw.
            set expectedVersion [expr {$version % 4}]
            set detectedVersion {}
            set missedFrames 0
            while {$detectedVersion != $expectedVersion} {
                incr missedFrames
                if {$missedFrames > 120} {
                    puts stderr "Failure -- TODO: revert to older model"
                }

                set frame [AwaitNextCameraFrame! frameTimestamp]
                set detectedTags [$tagDetector detect $frame]

                set detectedProjectedTagsCount [llength [$modelLib filterProjectedTagsInDetectedTags $detectedTags]]
                if {$detectedProjectedTagsCount < $projectedTagsCount / 2} {
                    puts stderr "Failure: Only seeing $detectedProjectedTagsCount of $projectedTagsCount projected tags"
                    continue
                } else {
                    puts stderr "Success: Seeing $detectedProjectedTagsCount of $projectedTagsCount projected tags"
                }
                set detectedVersion [$modelLib detectVersionFromDetectedTags $detectedTags]
            }

            # Compute residuals: detected position - ideal position for
            # each projected tag corner.

            # H_mp: model xy -> projector xy.
            # Used to infill projected tags that we didn't detect this frame.
            set projCorrespondences [list]
            foreach tag $detectedTags {
                if {![$modelLib isProjectedTag $tag(id)]} { continue }
                foreach modelCorner [dict get $model $tag(id) p] \
                        projCorner [dict get $tag p] {
                    lappend projCorrespondences \
                        [list {*}$modelCorner {*}$projCorner]
                }
            }
            set H_mp [$matLib estimateHomography $projCorrespondences]

            set detectedCornersById [dict create]
            foreach tag $detectedTags {
                dict set detectedById $tag(id) $tag(p)
            }

            set residuals [list]
            dict for {id modelTag} $model {
                if {![$modelLib isProjectedTag $id]} { continue }
                set nCorners [llength [dict get $modelTag p]]
                for {set i 0} {$i < $nCorners} {incr i} {
                    set idealIdx [expr {[$modelLib isVersionTag $id] ? ($i + $version) % 4 : $i}]
                    set ideal [lindex [dict get $idealCameraCorners $id] $idealIdx]
                    if {[dict exists $detectedCornersById $id]} {
                        set det [lindex $detectedCornersById($id) $i]
                    } else {
                        set det [$matLib applyHomography $H_mp \
                                     [lindex [dict get $modelTag p] $i]]
                    }
                    lappend residuals \
                        [- [lindex $det 0] [lindex $ideal 0]] \
                        [- [lindex $det 1] [lindex $ideal 1]]
                }
            }
            puts stderr "Residuals: ($residuals)"
            return $residuals
        }]]
        puts stderr "Old x: ($x0)"
        puts stderr "New x: ($x)"
        ravelInto calibration $x

        Hold! -save -on calibration -key calibration \
            Claim the calibration is $calibration

        break
    }
}

}
