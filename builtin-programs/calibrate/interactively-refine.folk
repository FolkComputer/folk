# interactively-refine.folk --
#
#     Implements table-oriented projector-camera end-to-end
#     calibration step.
#

When the pose library is /poseLib/ {

set cc [C]
$cc extend $poseLib

$cc cflags -I./vendor/apriltag
$cc endcflags ./vendor/apriltag/build/libapriltag.so

$cc include <apriltag_pose.h>
$cc include <common/homography.h>
$cc include <common/matd.h>

# Used to generate the initial guess in estimateBoardPose. Kind of
# misuses the AprilTag pose estimation code to do an entire-board
# estimate (which includes multiple tags).
$cc proc baseEstimateBoardPose {Intrinsics cameraIntrinsics
                                double cameraWidth double cameraHeight
                                double[][2] modelTagCorners double[][2] detectedTagCorners
                                int cornersCount} TagPose {
    // We'll fill this in with a .H that represents all the corners.
    apriltag_detection_t det;

    // The normal tag .H homography goes from (+/-1, +/-1) to the
    // camera-detected tag corners.  We will instead create a
    // board-wide homography from board meters position to the
    // camera-detected tag corners.
    float correspondences[cornersCount][4];
    for (int i = 0; i < cornersCount; i++) {
        correspondences[i][0] = modelTagCorners[i][0];
        correspondences[i][1] = modelTagCorners[i][1];

        double undistortedDetectedTagCorners[2];
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            detectedTagCorners[i],
                            undistortedDetectedTagCorners);
        correspondences[i][2] = undistortedDetectedTagCorners[0];
        correspondences[i][3] = undistortedDetectedTagCorners[1];
    }
    zarray_t correspondencesArr = {
        .el_sz = sizeof(float[4]), .size = cornersCount, .alloc = cornersCount,
        .data = (char*) correspondences
    };
    det.H = homography_compute(&correspondencesArr,
                               HOMOGRAPHY_COMPUTE_FLAG_SVD);
    apriltag_detection_info_t info = {
        .det = &det,
        .tagsize = 2.0, // scale factor = 1.0
        .fx = cameraIntrinsics.fx, .fy = cameraIntrinsics.fy,
        .cx = cameraIntrinsics.cx, .cy = cameraIntrinsics.cy
    };
    apriltag_pose_t pose;
    estimate_pose_for_tag_homography(&info, &pose);

    matd_destroy(det.H);

    TagPose ret;
    memcpy(ret.R, pose.R->data, sizeof(ret.R));
    memcpy(ret.t, pose.t->data, sizeof(ret.t));

    matd_destroy(pose.R);
    matd_destroy(pose.t);
    return ret;
}
$cc proc estimateBoardPose {Intrinsics cameraIntrinsics
                            double cameraWidth double cameraHeight
                            double[][2] modelTagCorners double[][2] detectedTagCorners
                            int cornersCount} TagPose {
    TagPose baseBoardPose =
        baseEstimateBoardPose(cameraIntrinsics, cameraWidth, cameraHeight,
                              modelTagCorners, detectedTagCorners, cornersCount);

    double wX[cornersCount][3];
    double x[cornersCount][2];
    for (int i = 0; i < cornersCount; i++) {
        rescaleAndUndistort(cameraIntrinsics, cameraWidth, cameraHeight,
                            detectedTagCorners[i],
                            x[i]);
        // Apply intrinsics to go from pixel coordinates to normalized
        // image-plane coordinates:
        x[i][0] = (x[i][0] - cameraIntrinsics.cx) / cameraIntrinsics.fx;
        x[i][1] = (x[i][1] - cameraIntrinsics.cy) / cameraIntrinsics.fy;

        wX[i][0] = modelTagCorners[i][0];
        wX[i][1] = modelTagCorners[i][1];
        wX[i][2] = 0;
    }

    matd_t* cRw = matd_create_data(3, 3, (double*) baseBoardPose.R);
    matd_t* ctw = matd_create_data(3, 1, (double*) baseBoardPose.t);

    poseGaussNewton(wX, x, cornersCount, &cRw, &ctw);

    TagPose ret;
    memcpy(ret.R, cRw->data, sizeof(ret.R));
    memcpy(ret.t, ctw->data, sizeof(ret.t));

    matd_destroy(cRw);
    matd_destroy(ctw);
    return ret;
}

$cc cflags -I./vendor/cmpfit
$cc include "mpfit.h"
$cc include "mpfit.c"
$cc proc funct {int m int n double* x
                double* fvec double** dvec
                void* userdata} void {
    Jim_Obj* jimFunct = (Jim_Obj*) userdata;
    // FIXME: Not sure how to call jimFunct (it's an object like
    // `apply {{x} { ...}}` and we want to call it with $x). Set the m
    // values of fvec to the list returned by JimEvalObj.
    fvec = Jim_EvalObj(interp, jimFunct, x);
}
$cc proc fit {int m double[12] x Jim_Obj* jimFunct} void {
    mpfit(funct,
          m, // Number of example point pairs
          // Number of parameters to optimize:
          12, x,
          NULL, jimFunct, NULL, &result);
}

set boardLib [$cc compile]

When the AprilTag detector maker is /makeAprilTagDetector/ &\
     the calibration model library is /modelLib/ &\
     the calibration estimateHomography is /estimateHomography/ &\
     the printed calibration tag size is /printedSideLengthMm/ mm &\
     camera /camera/ has width /cameraWidth/ height /cameraHeight/ &\
     display /display/ has width /displayWidth/ height /displayHeight/ &\
     /someone/ wishes to do interactive refinement {

    fn makeAprilTagDetector
    fn estimateHomography
    set tagDetector [makeAprilTagDetector "tagStandard52h13" 2.0 3]

    package require linalg
    namespace import ::math::linearalgebra::scale \
        ::math::linearalgebra::sub ::math::linearalgebra::add

    set printedSideLengthM [/ $printedSideLengthMm 1000.0]
    set model0 [$modelLib scaleModel [$modelLib unitModel] \
                    $printedSideLengthM]

    When /someone/ wishes to display refining model /model/ using calibration /calibration/ {
        package require linalg
        namespace import ::math::linearalgebra::matmul

        set modelPrintedTagCorners [list]
        set detectedPrintedTagCorners [list]
        foreach tag $tags {
            set id [dict get $tag id]
            if {![$modelLib isPrintedTag $id]} { continue }

            lappend modelPrintedTagCorners {*}[dict get $model $id p]
            lappend detectedPrintedTagCorners {*}[dict get $tag p]
        }
        if {[llength $detectedPrintedTagCorners] < 4} { return }

        # Do a single board-wide pose estimate.
        set pose [$boardLib estimateBoardPose $cameraIntrinsics \
                      $cameraWidth $cameraHeight \
                      $modelPrintedTagCorners $detectedPrintedTagCorners \
                      [llength $detectedPrintedTagCorners]]
        set R_boardToCamera [dict get $pose R]
        set t_boardToCamera [dict get $pose t]

        set R_cameraToDisplay [dict get $calibration R_cameraToProjector]
        set t_cameraToDisplay [dict get $calibration t_cameraToProjector]

        # Compute model-to-display homography from pose via correspondences
        # of the detected printed tag corners:
        set correspondences [lmap mc $modelPrintedTagCorners {
            set v [list {*}$mc 0]
            set camPt [add [matmul $R_boardToCamera $v] $t_boardToCamera]
            set dispPt [add [matmul $R_cameraToDisplay $camPt] $t_cameraToDisplay]
            set dp [$poseLib project $displayIntrinsics \
                        $displayWidth $displayHeight $dispPt]
            list {*}$mc {*}$dp
        }]
        set H_modelToDisplay [estimateHomography $correspondences]

        Wish to draw calibration model $model \
            using model-to-display homography $H_modelToDisplay
    }

    fn AwaitNextCameraFrame! {frameTimestampVar} {
        upvar $frameTimestampVar frameTimestamp
        set prevFrameTimestamp $frameTimestamp

        do {
            after 8

            set frames [Query! camera $camera has frame /frame/ at timestamp /frameTimestamp/]
            if {[llength $frames] < 1} { continue }
            set frameResult [lindex $frames end]
            dict with frameResult {}
        } while {$frameTimestamp <= $prevFrameTimestamp}

        return $frame
    }

    # The actual refinement process. We will have the user hold up the
    # board in a sequence of whatever poses they want. When the board
    # is stable for a couple seconds, we say that's a pose, and we
    # start refinement with respect to that pose.
    #
    # Once the calibration is refined with respect to the pose, the
    # user can move the board to a different pose. They can stop
    # whenever they want.
    set poses [list]
    while true {
        set frame [AwaitNextCameraFrame! frameTimestamp]
        set aprilTime [time {
            set tags [$tagDetector detect $frame]
        }]

        # Record all the printed tags seen by the camera in $tags.
        
        # FIXME: Do we have a valid new pose: are the seen $tags far
        # enough from previous pose's $tags, and have the $tags been
        # stable for a while?

        # TODO: Compute homography; use it to predict projected tag
        # positions.

        # If so, then refine the parameters around this pose. This
        # will block for a while and run the interior function a lot
        # (10 times? 100 times?).
        set version 0
        set x [unravel $calibration]
        set x [$boardLib fit $x [list apply {x} {
            upvar version version
            # This is the function that gets evaluated on each
            # iteration of the Levenberg-Marquardt optimization loop.

            set calibration [ravel $x]
            set model [$modelLib updateModelVersion $model $version]
            # This will cause the tags to be rendered by the other
            # process.
            Hold! Wish to display refining model $model using calibration $calibration

            # Loop until we see the version we just rendered.
            do {
                AwaitNextCameraFrame! frameTimestamp
                set tags [$tagDetector detect $frame]

                # FIXME: Check the version.
            } while {}

            # TODO: Need to check that the user has kept the board 'still
            # enough' to the original `frame` that kicked off this
            # pose refinement. If not, then abort.

            # FIXME: Compute residuals for each tag. (how far away is
            # the tag from where we'd expect it to be from the
            # homography?) Return that list of residuals.
        }]]
        set calibration [ravel $x]
    }
}

}
