When the collected results for [list /someone/ wishes the web server handles route /route/ with /...options/] are /handlers/ {
    # Generate navigation from all route handlers.
    set navLinks [list]
    foreach handler $handlers {
      set route $handler(route)
      if {[dict getdef $handler(options) hidden false]} { continue }
      if {$route eq "/"} { continue }

      # Filter out routes with non-optional capture groups.
      # Check if route has capturing groups (not non-capturing (?:...)).
      set hasCapturingGroup [regexp {\([^?]} $route]
      # Check if ANY group is non-optional (has ) not followed by ?).
      set hasNonOptionalGroup [regexp {\)[^?]} $route]
      if {$hasCapturingGroup && $hasNonOptionalGroup} { continue }

      # Remove all regex patterns and capture groups for the href and
      # display name.
      set route [regsub -all {\([^)]*\)} $route ""]
      set route [regsub -all {\[[^\]]*\]} $route ""]
      # Convert escaped dots to plain dots first
      set route [regsub -all {\\.} $route "."]
      # Remove wildcard patterns like .* and .+
      set route [regsub -all {\.\*} $route ""]
      set route [regsub -all {\.\+} $route ""]
      # Remove other regex metacharacters (but not .)
      set route [regsub -all {[\\?*+^]} $route ""]
      set route [regsub {\$$} $route ""]
      set route [regsub {\$\s*$} $route ""]

      # Create a nice display name from the route.
      set displayName [string trim $route "/"]
      set displayName [string map {"-" " " ".pdf" "" "_" " "} $displayName]
      set displayName [string totitle $displayName]

      set nav [dict getdef $handler(options) nav $displayName]
      lappend navLinks "<a href=\"$route\">$nav</a>"
    }

    Claim the web navigation HTML is [subst {
      <nav>
        [join $navLinks "\n          "]
      </nav>
    }]
}

Wish the web server handles route "/" with handler {
    fn emitHtmlForProgramList {programList label} {
        set prettyLabel [string map {- " "} $label]
        set prettyLabel [string totitle $prettyLabel]:
        set returnList [list "<details data-label='$label' data-count='[llength $programList]'><summary>$prettyLabel ([llength $programList])</summary>"]
        lappend returnList "<ul>"
        foreach item $programList {
            lappend returnList [subst {
                <li id="program-[string map {{ } -} $item(programName)]"><details>
                  <summary>$item(programName)</summary>
                  <pre><code>[htmlEscape $item(programCode)]</code></pre>
                </details></li>
            }]
        }
        lappend returnList "</ul>"
        lappend returnList "</details>"
        join $returnList
    }

    fn emitHtmlForPrograms {programs} {
        set vp [list]; # builtin programs
        set cp [list]; # local programs
        set wp [list]; # web programs
        set rp [list]; # real programs

        foreach match $programs {
            set programName [dict get $match programName]
            switch -glob $programName {
                "builtin-programs/*" {
                    lappend vp $match
                }
                "/home/*" {
                    lappend cp $match
                }
                "/Users/*" {
                    lappend cp $match
                }
                "web-program-*" {
                    lappend wp $match
                }
                default {
                    lappend rp $match
                }
            }
        }

        return [join [list \
            [emitHtmlForProgramList $rp "real-programs"] \
            [emitHtmlForProgramList $wp "web-programs"] \
            [emitHtmlForProgramList $vp "builtin-programs"] \
            [emitHtmlForProgramList $cp "local-programs"]]]
    }

    html [subst {
        <html>
        <head>
            <title>Folk: Running programs</title>
            <link rel="stylesheet" href="/style.css">
            <style>
                body {
                    font-family: math;
                }
                summary {
                    font-family: monospace;
                }
                details ul {
                    margin-block: 0;
                    list-style-type: none;
                }
            </style>
            <script src="/lib/folk.js"></script>
            <script src="/vendor/idiomorph.js"></script>
            <script>
              const folk = new FolkWS();
            </script>
        </head>
        <body>
        [dict get [QueryOne! the web navigation HTML is /nav/] nav]
        [HtmlWhen the collected results for [list /programName/ has program code /programCode/] \
                  are /programs/ {
            emitHtmlForPrograms $programs

        } -beforeAttributeUpdated {(attributeName, node, mutationType) => {
            if (attributeName === "open") { return false; }
        }}]
        </body>
        </html>
    }]
}
