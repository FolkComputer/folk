# Manage stdout for Folk.

$::realStdout puts "Folk Computer (pid [pid])"
$::realStdout puts ""

# TODO: Don't print the below if we're not literally at a terminal (if
# we're running on systemd, for instance.)

set termRows 24
catch { set termRows [lindex [exec stty size] 0] }
set maxLines [expr {$termRows - 4}]

# Save cursor position at the start of the program list area.
$::realStdout puts -nonewline "\033\[s"

while true {
    after 30 ;# Wake up every 30ms.

    set results [lsort -command {apply {{a b} {
        string compare [dict get $a program] [dict get $b program]
    }}} [Query! /program/ has program code /programCode/]]

    # Build groups: dict mapping dirname -> list of {status basename}
    set groups [dict create]
    set groupOrder {}
    foreach result $results {
        set program [dict get $result program]
        set programCode [dict get $result programCode]

        set runners [Query! when $programCode with environment [list [list this $program]]]
        if {[llength $runners] != 1} { continue }
        set runner [lindex $runners 0]
        set incompleteCount [__statementIncompleteChildMatchesCount [dict get $runner __ref]]

        set errors [Query! $program has error /err/ with info /info/]

        set dir [file dirname $program]
        set base [file rootname [file tail $program]]

        if {[llength $errors] > 0} {
            set status "\033\[31m!\033\[0m"
            set coloredBase "\033\[31m$base\033\[0m"
        } elseif {$incompleteCount == 0} {
            set status "\033\[32mâœ“\033\[0m"
            set coloredBase "\033\[32m$base\033\[0m"
        } else {
            set spinIdx [expr {([clock milliseconds] / 100) % 4}]
            set status "\033\[33m[lindex {| / - \\} $spinIdx]\033\[0m"
            set coloredBase "\033\[33m$base\033\[0m"
        }

        if {![dict exists $groups $dir]} {
            lappend groupOrder $dir
        }
        dict lappend groups $dir [list $status $coloredBase]
    }

    # Collapse groups with multiple members onto one line.
    set lines {}
    foreach dir $groupOrder {
        set members [dict get $groups $dir]
        set parts {}
        foreach member $members {
            lassign $member status base
            lappend parts "${status} $base"
        }
        lappend lines "$dir/  [join $parts {  }]"
    }

    if {[llength $lines] > $maxLines} {
        set lines [lrange $lines 0 [expr {$maxLines - 1}]]
    }

    $::realStdout puts -nonewline "\033\[u"
    foreach line $lines {
        $::realStdout puts -nonewline "$line\033\[K\n"
    }
    $::realStdout puts -nonewline "\033\[J"
}
