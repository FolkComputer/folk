When the GPU Vulkan handle type definer is /defineVulkanHandleType/ {

fn defineVulkanHandleType

# VMA (Vulkan Memory Allocator) module:
set vmac [C++]
$vmac cflags -I./vendor \
    -Wno-nullability-completeness -Wno-unused-private-field \
    -Wno-unused-variable
$vmac code {
    #define VOLK_IMPLEMENTATION
    #include "volk/volk.h"

    #define VMA_IMPLEMENTATION
    #define VMA_STATIC_VULKAN_FUNCTIONS 0
    #define VMA_DYNAMIC_VULKAN_FUNCTIONS 1
    #include "vk_mem_alloc.h"

    VmaAllocator allocator = VK_NULL_HANDLE;
}
defineVulkanHandleType $vmac VkInstance
defineVulkanHandleType $vmac VkPhysicalDevice
defineVulkanHandleType $vmac VkDevice
$vmac proc vmaInit {VkInstance instance VkPhysicalDevice physicalDevice VkDevice device} void {
    volkInitialize();
    volkLoadInstanceOnly(instance);
    volkLoadDevice(device);

    VmaAllocatorCreateInfo allocatorInfo = {0};
    allocatorInfo.vulkanApiVersion = VK_API_VERSION_1_0;
    allocatorInfo.physicalDevice = physicalDevice;
    allocatorInfo.device = device;
    allocatorInfo.instance = instance;

    VmaVulkanFunctions vulkanFunctions;
    VkResult res = vmaImportVulkanFunctionsFromVolk(&allocatorInfo, &vulkanFunctions);
    if (res != VK_SUCCESS) {
        fprintf(stderr, "Failed to import Vulkan functions from volk: %d\\n", res);
        exit(1);
    }
    allocatorInfo.pVulkanFunctions = &vulkanFunctions;

    res = vmaCreateAllocator(&allocatorInfo, &allocator);
    if (res != VK_SUCCESS) {
        fprintf(stderr, "Failed to create VMA allocator: %d\\n", res);
        exit(1);
    }
}
$vmac proc vmaGetAllocator {} VmaAllocator* {
    return &allocator;
}

Claim the GPU VMA library is [$vmac compile]

}
