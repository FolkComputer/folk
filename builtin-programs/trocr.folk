# Need uv installed:
#  $ curl -LsSf https://astral.sh/uv/install.sh | sh

file delete /tmp/trocr.sock

set cc [C]
$cc include <stdint.h>
$cc include <stdio.h>
$cc include <string.h>
$cc include <unistd.h>
$cc include <pthread.h>
$cc include <sys/socket.h>
$cc include <sys/un.h>

$cc struct Image {
    uint32_t width;
    uint32_t height;
    int components;
    uint32_t bytesPerRow;
    uint64_t uniq;
    uint8_t* data;
}

$cc code {
    #define SOCKET_PATH "/tmp/trocr.sock"

    static ssize_t send_all(int sock, const void* buf, size_t len) {
        size_t sent = 0;
        while (sent < len) {
            ssize_t n = send(sock, (const char*)buf + sent, len - sent, 0);
            if (n <= 0) return -1;
            sent += n;
        }
        return sent;
    }

    static ssize_t recv_all(int sock, void* buf, size_t len) {
        size_t received = 0;
        while (received < len) {
            ssize_t n = recv(sock, (char*)buf + received, len - received, 0);
            if (n <= 0) return -1;
            received += n;
        }
        return received;
    }
}

$cc proc ocrImage {Image im} char* {
    // Create socket and connect
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock < 0) {
        fprintf(stderr, "ocrImage: Failed to create socket\n");
        return strdup("");
    }

    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        fprintf(stderr, "ocrImage: Failed to connect to socket\n");
        close(sock);
        return strdup("");
    }

    // Send header: width, height, components
    uint32_t header[3] = {im.width, im.height, (uint32_t)im.components};
    if (send_all(sock, header, sizeof(uint32_t)*3) < 0) {
        fprintf(stderr, "ocrImage: Failed to send header\n");
        close(sock);
        return strdup("");
    }

    // Send pixel data
    uint32_t rowSize = im.width * im.components;
    if (im.bytesPerRow == rowSize) {
        // Contiguous data
        if (send_all(sock, im.data, rowSize * im.height) < 0) {
            fprintf(stderr, "ocrImage: Failed to send image data\n");
            close(sock);
            return strdup("");
        }
    } else {
        // Send row by row
        for (uint32_t y = 0; y < im.height; y++) {
            if (send_all(sock, im.data + y * im.bytesPerRow, rowSize) < 0) {
                fprintf(stderr, "ocrImage: Failed to send row\n");
                close(sock);
                return strdup("");
            }
        }
    }

    // Read response length
    uint32_t length;
    if (recv_all(sock, &length, sizeof(uint32_t)) < 0) {
        fprintf(stderr, "ocrImage: Failed to receive length\n");
        close(sock);
        return strdup("");
    }

    // Read response text
    char* buffer = malloc(length + 1);
    if (recv_all(sock, buffer, length) < 0) {
        fprintf(stderr, "ocrImage: Failed to receive text\n");
        free(buffer);
        close(sock);
        return strdup("");
    }
    buffer[length] = '\0';

    close(sock);
    return buffer;
}

set trocrLib [$cc compile]

set UVX "$::env(HOME)/.local/bin/uvx"
if {![file exists $UVX]} { set UVX "uvx" }

set deps [list --with transformers --with requests --with pillow --with torch \
              --with protobuf --with opencv-python-headless \
              --with "git+https://github.com/osnr/craft-text-detector.git"]
set cmd [list $UVX {*}$deps python -u -c {
try:
    from transformers import TrOCRProcessor, VisionEncoderDecoderModel
    import os
    import sys
    import struct
    import socket
    from PIL import Image
    import torch
    from craft_text_detector import Craft
    import numpy as np

    SOCKET_PATH = "/tmp/trocr.sock"

    # Determine device
    device = "cuda" if torch.cuda.is_available() else "cpu"
    use_cuda = device == "cuda"

    # Initialize CRAFT text detector
    print("trocr: Loading CRAFT text detector...", file=sys.stderr, flush=True)
    craft = Craft(output_dir=None, crop_type="box", cuda=use_cuda)
    print("trocr: CRAFT loaded.", file=sys.stderr, flush=True)

    # Load TrOCR model
    TROCR_PATH = os.path.expanduser("~/folk-data/trocr")
    try:
        processor = TrOCRProcessor.from_pretrained(TROCR_PATH)
        model = VisionEncoderDecoderModel.from_pretrained(TROCR_PATH)
        print("trocr: Loaded TrOCR model from disk.", file=sys.stderr, flush=True)
    except Exception:
        print("trocr: Model not saved; loading from Internet.", file=sys.stderr, flush=True)
        processor = TrOCRProcessor.from_pretrained("microsoft/trocr-base-handwritten")
        processor.save_pretrained(TROCR_PATH)
        model = VisionEncoderDecoderModel.from_pretrained("microsoft/trocr-base-handwritten")
        model.save_pretrained(TROCR_PATH)
        print("trocr: Loaded TrOCR model from Internet.", file=sys.stderr, flush=True)

    model.to(device)
    print(f"trocr: Using device: {device}", file=sys.stderr, flush=True)

    # Create Unix domain socket
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(SOCKET_PATH)
    sock.listen(5)

    print("READY", flush=True)

    # Accept connections and process one image per connection
    while True:
        conn, _ = sock.accept()
        try:
            # Read header (12 bytes)
            header = conn.recv(12)
            if len(header) < 12:
                print("trocr: Invalid header", file=sys.stderr, flush=True)
                conn.close()
                continue

            width, height, components = struct.unpack('<III', header)
            print(f"trocr: Received {width}x{height}x{components}", file=sys.stderr, flush=True)

            # Read pixel data
            data_length = width * height * components
            pixel_data = b''
            while len(pixel_data) < data_length:
                chunk = conn.recv(min(65536, data_length - len(pixel_data)))
                if not chunk:
                    break
                pixel_data += chunk

            if len(pixel_data) < data_length:
                print(f"trocr: Incomplete data", file=sys.stderr, flush=True)
                conn.close()
                continue

            # Process image
            if components == 1:
                mode = 'L'
            elif components == 3:
                mode = 'RGB'
            else:
                raise ValueError(f"Unsupported components: {components}")

            image = Image.frombytes(mode, (width, height), pixel_data).convert("RGB")

            # Convert PIL image to numpy array for CRAFT
            image_np = np.array(image)

            # Detect text boxes with CRAFT
            result = craft.detect_text(image_np)
            boxes = result["boxes"]

            print(f"trocr: Detected {len(boxes)} text boxes", file=sys.stderr, flush=True)

            # OCR each detected box
            texts = []
            for i, box in enumerate(boxes):
                # Crop the box from the image
                x1, y1 = int(box[0][0]), int(box[0][1])
                x2, y2 = int(box[2][0]), int(box[2][1])

                # Ensure coordinates are within image bounds
                x1, y1 = max(0, x1), max(0, y1)
                x2, y2 = min(width, x2), min(height, y2)

                if x2 <= x1 or y2 <= y1:
                    continue

                crop = image.crop([x1, y1, x2, y2])

                # Run TrOCR on the crop
                with torch.no_grad():
                    pixel_values = processor(crop, return_tensors="pt").pixel_values.to(device)
                    generated_ids = model.generate(pixel_values)
                    text = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
                    texts.append(text)
                    print(f"trocr: Box {i}: {text}", file=sys.stderr, flush=True)

            # Join all texts with spaces
            generated_text = " ".join(texts) if texts else ""

            print(f"trocr: Final result: {generated_text}", file=sys.stderr, flush=True)

            # Send response
            text_bytes = generated_text.encode('utf-8')
            conn.sendall(struct.pack('<I', len(text_bytes)))
            conn.sendall(text_bytes)

        except Exception as e:
            print(f"trocr: ERROR: {e}", file=sys.stderr, flush=True)
        finally:
            conn.close()

except Exception as e:
    print(f"trocr: FATAL: {e}", file=sys.stderr, flush=True)
    raise e
}]

# Start Python subprocess
exec {*}$cmd 2>@stderr &

# Wait for READY
set ready 0
set timeout [expr {[clock milliseconds] + 60000}]
while {!$ready && [clock milliseconds] < $timeout} {
    if {[file exists /tmp/trocr.sock]} {
        set ready 1
    } else {
        sleep 0.1
    }
}

if {!$ready} {
    error "trocr: Subprocess failed to create socket"
}

sleep 0.5

fn TrOCR {im} {
    return [$trocrLib ocrImage $im]
}

Claim the TrOCR function is [fn TrOCR]
