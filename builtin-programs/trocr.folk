# Need uv installed:
#  $ curl -LsSf https://astral.sh/uv/install.sh | sh

set cc [C]
$cc include <stdint.h>
$cc include <stdio.h>
$cc include <string.h>
$cc include <unistd.h>

$cc struct Image {
    uint32_t width;
    uint32_t height;
    int components;
    uint32_t bytesPerRow;
    uint64_t uniq;
    uint8_t* data;
}

$cc proc ocrImage {Image im int writerFd int readerFd} char* {
    // Send header: width, height, components (12 bytes, little-endian)
    uint32_t header[3] = {im.width, im.height, (uint32_t)im.components};
    write(writerFd, header, sizeof(uint32_t)*3);

    // Send raw pixel data
    uint32_t rowSize = im.width * im.components;
    if (im.bytesPerRow == rowSize) {
        // Data is contiguous, send directly
        write(writerFd, im.data, rowSize * im.height);
    } else {
        // Need to send row by row
        for (uint32_t y = 0; y < im.height; y++) {
            write(writerFd, im.data + y * im.bytesPerRow, rowSize);
        }
    }

    // Read length prefix (4 bytes)
    uint32_t length;
    if (read(readerFd, &length, sizeof(uint32_t)) != sizeof(uint32_t)) {
        return strdup("");
    }

    // Read text data
    char* buffer = malloc(length + 1);
    size_t totalRead = 0;
    while (totalRead < length) {
        ssize_t n = read(readerFd, buffer + totalRead, length - totalRead);
        if (n <= 0) break;
        totalRead += n;
    }
    buffer[totalRead] = '\0';
    return buffer;
}

set trocrLib [$cc compile]

set deps [list --with transformers --with requests --with pillow --with torch --with protobuf]
set cmd [list $::env(HOME)/.local/bin/uvx {*}$deps python -u -c {
try:
    from transformers import TrOCRProcessor, VisionEncoderDecoderModel
    import os
    import sys
    import struct
    from PIL import Image

    TROCR_PATH = os.path.expanduser("~/folk-data/trocr")
    try:
        processor = TrOCRProcessor.from_pretrained(TROCR_PATH)
        model = VisionEncoderDecoderModel.from_pretrained(TROCR_PATH)
        print("trocr: Loaded model from disk.", file=sys.stderr, flush=True)
    except Exception:
        print("trocr: Model not saved; loading from Internet.", file=sys.stderr, flush=True)
        processor = TrOCRProcessor.from_pretrained("microsoft/trocr-base-handwritten")
        processor.save_pretrained(TROCR_PATH)
        model = VisionEncoderDecoderModel.from_pretrained("microsoft/trocr-base-handwritten")
        model.save_pretrained(TROCR_PATH)
        print("trocr: Loaded model from Internet.", file=sys.stderr, flush=True)

    print("READY", flush=True)

    # Read images from stdin in binary protocol
    # Protocol: width (4 bytes) + height (4 bytes) + components (4 bytes) + raw pixel data
    while True:
        print(f"trocr: Awaiting image.", file=sys.stderr, flush=True)

        # Read width, height, components
        header = sys.stdin.buffer.read(12)
        if len(header) < 12:
            print(f"trocr: Invalid image.", file=sys.stderr, flush=True)
            break

        width, height, components = struct.unpack('<III', header)
        print(f"trocr: Received image: {width}x{height}x{components}", file=sys.stderr, flush=True)

        # Read raw pixel data
        data_length = width * height * components
        pixel_data = sys.stdin.buffer.read(data_length)
        if len(pixel_data) < data_length:
            print(f"trocr: ERROR: Expected {data_length} bytes, got {len(pixel_data)}", file=sys.stderr, flush=True)
            break

        try:
            # Convert raw data to PIL Image
            if components == 1:
                mode = 'L'
            elif components == 3:
                mode = 'RGB'
            else:
                raise ValueError(f"Unsupported components: {components}")

            image = Image.frombytes(mode, (width, height), pixel_data).convert("RGB")

            pixel_values = processor(image, return_tensors="pt").pixel_values
            generated_ids = model.generate(pixel_values)
            generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]

            print(f"trocr: Found: {generated_text}", file=sys.stderr, flush=True)

            # Send length-prefixed result
            text_bytes = generated_text.encode('utf-8')
            length = len(text_bytes)
            sys.stdout.buffer.write(struct.pack('<I', length))
            sys.stdout.buffer.write(text_bytes)
            sys.stdout.buffer.flush()
        except Exception as e:
            print(f"trocr: ERROR: {e}", file=sys.stderr, flush=True)

except Exception as e:
    print(f"trocr: FATAL: {e}", file=sys.stderr, flush=True)
    raise e
}]

lassign [pipe] stdinRead stdinWrite
set stdinReadFd [$stdinRead getfd]
set stdinWriteFd [$stdinWrite getfd]

lassign [pipe] stdoutRead stdoutWrite
set stdoutReadFd [$stdoutRead getfd]
set stdoutWriteFd [$stdoutWrite getfd]

exec {*}$cmd <@$stdinRead >@$stdoutWrite 2>@stderr &
close $stdinRead; close $stdoutWrite

fconfigure $stdinWrite -buffering none -blocking 1
fconfigure $stdoutRead -buffering none -blocking 1
# Block until subprocess is ready
while {[gets $stdoutRead line] >= 0} {
    if {[string match "READY" $line]} { break }
}

fn TrOCR {im} {
    return [$trocrLib ocrImage $im $stdinWriteFd $stdoutReadFd]
}
Claim the TrOCR function is [fn TrOCR]
