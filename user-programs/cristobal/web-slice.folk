#
#
# Web-slice
# --------------------------------------------
# Serves slice at host:4273/web-slice/$x-$y
#
#

Wish $this is outlined white

set cc [c create]
$cc cflags -L[lindex [exec /usr/sbin/ldconfig -p | grep libjpeg] end]

# TODO: get C-structs to work
# $cc struct image_t {
#   uint32_t width;
#   uint32_t height;
#   int components;
#   uint32_t bytesPerRow;
#   uint8_t* data;
# }

$cc code {
    typedef struct {
        uint32_t width;
        uint32_t height;
        int components;
        uint32_t bytesPerRow;
        uint8_t *data;
    } image_t;
}

$cc argtype image_t {
  image_t $argname;
  sscanf(
    Tcl_GetString($obj),
    "width %u height %u components %d bytesPerRow %u data 0x%p",
    &$argname.width, &$argname.height, &$argname.components, &$argname.bytesPerRow, &$argname.data
  );
}

$cc rtype image_t {
  $robj = Tcl_ObjPrintf(
      "width %u height %u components %d bytesPerRow %u data 0x%" PRIxPTR,
      $rvalue.width, $rvalue.height, $rvalue.components, $rvalue.bytesPerRow, (uintptr_t) $rvalue.data
  );
}

$cc include <stdlib.h>
$cc include <string.h>
$cc include <stdint.h>
$cc include <unistd.h>
$cc include <jpeglib.h>

$cc code {

  void 
  write_jpeg(FILE* dest, uint8_t* grey, uint32_t width, uint32_t height, uint32_t bytes_per_row)
  {
    JSAMPARRAY image;
    image = calloc(height, sizeof (JSAMPROW));
    for (size_t i = 0; i < height; i++) {
      image[i] = calloc(width * 3, sizeof (JSAMPLE));
      for (size_t j = 0; j < width; j++) {
	image[i][j * 3 + 0] = grey[i * bytes_per_row + j];
	image[i][j * 3 + 1] = grey[i * bytes_per_row + j];
	image[i][j * 3 + 2] = grey[i * bytes_per_row + j];
      }
    }

    struct jpeg_compress_struct compress;
    struct jpeg_error_mgr error;
    compress.err = jpeg_std_error(&error);
    jpeg_create_compress(&compress);
    jpeg_stdio_dest(&compress, dest);

    compress.image_width = width;
    compress.image_height = height;
    compress.input_components = 3;
    compress.in_color_space = JCS_RGB;

    jpeg_set_defaults(&compress);
    jpeg_set_quality(&compress, 100, TRUE);
    jpeg_start_compress(&compress, TRUE);
    jpeg_write_scanlines(&compress, image, height);
    jpeg_finish_compress(&compress);
    jpeg_destroy_compress(&compress);

    for (size_t i = 0; i < height; i++) {
      free(image[i]);
    }
    free(image);
  }
}


$cc proc writeJPEG {image_t im char* filename} void {
    FILE* out = fopen(filename, "w");
    write_jpeg(out, im.data, im.width, im.height, im.bytesPerRow);
    fclose(out);
}

c loadlib [lindex [exec /usr/sbin/ldconfig -p | grep libjpeg] end]
$cc compile

When $this has camera slice /im/ & $this has region /r/ {

  # Serve slice at its coordinates
  lassign [lindex $r 0 0] ox oy
  set x [expr {round(floor($ox / 10) * 10)}]
  set y [expr {round(floor($oy / 10) * 10)}]

  set path "/web-slice/$x-$y$"
  Wish $this is labelled $path

  # TODO: I don't like this [list apply] with parameter capture.
  # Understand why this is needed, and then make it better.
  Wish the web server handles route $path with handler [list apply {{im x y} {

    set filename "/tmp/web-slice-$x-$y.jpg"
    writeJPEG $im $filename
    set fsize [file size $filename]
    set fd [open $filename r]

    fconfigure $fd -encoding binary -translation binary
    set body [read $fd $fsize]
    close $fd

    set headers [join [list \
      "HTTP/1.1 200 OK" \
      "Connection: close" \
      "Content-Type: image/jpeg" \
      "Content-Length: $fsize" \
    ] "\n"]

    dict create statusAndHeaders "$headers\n\n" body $body

  }} $im $x $y]
}

