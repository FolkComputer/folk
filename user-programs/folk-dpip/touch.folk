set cpp [C++]
$cpp cflags -I$::env(HOME)/freenect2/include

$cpp include <libfreenect2/libfreenect2.hpp>
$cpp include <libfreenect2/frame_listener_impl.h>
$cpp include <libfreenect2/packet_pipeline.h>

c loadlib $::env(HOME)/freenect2/lib/libfreenect2.so

$cpp include <iostream>

defineImageType $cpp

$cpp code {
    libfreenect2::Freenect2 freenect2;
    libfreenect2::Freenect2Device *dev = 0;
    libfreenect2::PacketPipeline *pipeline = 0;

    libfreenect2::SyncMultiFrameListener listener(
        libfreenect2::Frame::Color |
        libfreenect2::Frame::Ir |
        libfreenect2::Frame::Depth
    );
    libfreenect2::FrameMap frames;
}

$cpp import ::Heap::cc folkHeapAlloc as folkHeapAlloc
$cpp import ::Heap::cc folkHeapFree as folkHeapFree

$cpp proc initKinect {} bool {
    if (freenect2.enumerateDevices() == 0) {
        std::cout << "no device connected!" << std::endl;
        return false;
    }

    pipeline = new libfreenect2::CpuPacketPipeline();
    dev = freenect2.openDefaultDevice(pipeline);
    dev->setColorFrameListener(&listener);
    dev->setIrAndDepthFrameListener(&listener);
    if (!dev->start()) {
        std::cout << "couldn't start streams!" << std::endl;
        return false;
    }
    if (!listener.waitForNewFrame(frames, 10*1000)) { // timeout after 10 seconds
        std::cout << "timed out waiting for frames!" << std::endl;
        return false;
    }
    libfreenect2::Frame *ir = frames[libfreenect2::Frame::Ir];
    std::cout << "ir width: " << ir->width << std::endl;
    std::cout << "ir height: " << ir->height << std::endl;
    std::cout << "ir bytes_per_pixel: " << ir->bytes_per_pixel << std::endl;
    std::cout << "ir format: " << ir->format << std::endl;
    libfreenect2::Frame *depth = frames[libfreenect2::Frame::Depth];
    std::cout << "depth width: " << depth->width << std::endl;
    std::cout << "depth height: " << depth->height << std::endl;
    std::cout << "depth bytes_per_pixel: " << depth->bytes_per_pixel << std::endl;
    std::cout << "depth format: " << depth->format << std::endl;
    listener.release(frames);
    dev->stop();

    return true;
}

$cpp code {
    image_t newGrayImage() {
        uint8_t* data = (uint8_t *)folkHeapAlloc(512*424);
        return (image_t) {
            .width = 512,
            .height = 424,
            .components = 1,
            .bytesPerRow = 512,
            .data = data
        };
    }
}

$cpp proc freeImage {image_t image} void {
    folkHeapFree(image.data);
}

$cpp proc getDepthFrame {} image_t {
    image_t image = newGrayImage();
    if (!dev->start()) {
        std::cout << "couldn't start dev in depth!" << std::endl;
        return image;
    }
    if (!listener.waitForNewFrame(frames, 10*1000)) { // timeout after 10 seconds
        std::cout << "timed out waiting for depth frames!" << std::endl;
        return image;
    }
    libfreenect2::Frame *depth = frames[libfreenect2::Frame::Depth];

    float* depthData = (float*)depth->data;
    for (long unsigned int i = 0; i < 512*424; i += 1) {
        float depthPixel = depthData[i];
        uint8_t grayPixel = (depthPixel / 5000.0) * 255;
        image.data[i] = grayPixel;
    }
    listener.release(frames);
    dev->stop();
    return image;
}

$cpp proc getIrFrame {} image_t {
    image_t image = newGrayImage();
    if (!dev->start()) {
        std::cout << "couldn't start dev in IR!" << std::endl;
        return image;
    }
    if (!listener.waitForNewFrame(frames, 10*1000)) { // timeout after 10 seconds
        std::cout << "timed out waiting for ir frames!" << std::endl;
        return image;
    }
    libfreenect2::Frame *ir = frames[libfreenect2::Frame::Ir];

    float* irData = (float *)ir->data;
    for (long unsigned int i = 0; i < 512*424; i += 1) {
        float irPixel = irData[i];
        uint8_t grayPixel = (irPixel / 65535.0) * 255;
        image.data[i] = grayPixel;
    }
    listener.release(frames);
    dev->stop();
    return image;
}

$cpp compile

puts "initializing kinect"
if { ![initKinect] } {
    puts "kinect not found! exiting touch tracking"
    return
}
puts "kinect initialized"

Wish the web server handles route {/kinect-ir-frame(?:\?.*)?$} with handler {
    set filename "/tmp/web-ir-frame-kinect.jpg"
    set im [getIrFrame]
    image saveAsJpeg $im $filename
    set fsize [file size $filename]
    set fd [open $filename r]
    fconfigure $fd -encoding binary -translation binary
    set body [read $fd $fsize]
    close $fd
    freeImage $im
    dict create statusAndHeaders "HTTP/1.1 200 OK\nConnection: close\nContent-Type: image/jpeg\nContent-Length: $fsize\n\n" body $body
}

Wish the web server handles route {/kinect-depth-frame(?:\?.*)?$} with handler {
    set filename "/tmp/web-depth-frame-kinect.jpg"
    set im [getDepthFrame]
    image saveAsJpeg $im $filename
    set fsize [file size $filename]
    set fd [open $filename r]
    fconfigure $fd -encoding binary -translation binary
    set body [read $fd $fsize]
    close $fd
    freeImage $im
    dict create statusAndHeaders "HTTP/1.1 200 OK\nConnection: close\nContent-Type: image/jpeg\nContent-Length: $fsize\n\n" body $body
}
